// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef ROTALUMISRESPONSE_HXX
#define ROTALUMISRESPONSE_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-iso8859-1.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type Type;
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;
  typedef ::xsd::cxx::tree::type Container;

  // 8-bit
  //
  typedef signed char Byte;
  typedef unsigned char UnsignedByte;

  // 16-bit
  //
  typedef short Short;
  typedef unsigned short UnsignedShort;

  // 32-bit
  //
  typedef int Int;
  typedef unsigned int UnsignedInt;

  // 64-bit
  //
  typedef long long Long;
  typedef unsigned long long UnsignedLong;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long Integer;
  typedef long long NonPositiveInteger;
  typedef unsigned long long NonNegativeInteger;
  typedef unsigned long long PositiveInteger;
  typedef long long NegativeInteger;

  // Boolean.
  //
  typedef bool Boolean;

  // Floating-point types.
  //
  typedef float Float;
  typedef double Double;
  typedef double Decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;
  typedef ::xsd::cxx::tree::name< char, Token > Name;
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;
  typedef ::xsd::cxx::tree::language< char, Token > Language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > Buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone TimeZone;
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;

  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags Flags;
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity Severity;
  typedef ::xsd::cxx::tree::error< char > Error;
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > Exception;
  typedef ::xsd::cxx::tree::bounds< char > Bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;
  typedef ::xsd::cxx::tree::parsing< char > Parsing;
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;
  typedef ::xsd::cxx::tree::no_type_info< char > NoTypeInfo;
  typedef ::xsd::cxx::tree::not_derived< char > NotDerived;
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace poosl
{
  class T_load_response;
  class T_save_response;
  class T_file_io_result;
  class T_serialize_response;
  class T_deserialize_response;
  class T_compile_response;
  class T_serialize_result;
  class T_parse_result;
  class T_list_classes_response;
  class T_list_files_response;
  class T_get_position_response;
  class T_get_top_level_specification_response;
  class T_get_class_definition_response;
  class T_cluster_class_def;
  class T_process_class_def;
  class T_data_class_def;
  class T_get_method_definition_response;
  class T_process_method_def;
  class T_data_method_def;
  class T_get_object_handle_response;
  class T_rename_object_response;
  class T_rename_object_response_result;
  class T_insert_object_response;
  class T_insert_object_response_result;
  class T_delete_object_response;
  class T_object_query_result;
  class T_instantiate_response;
  class T_instantiate_result;
  class T_command_response;
  class T_get_transitions_response;
  class T_perform_transition_response;
  class T_perform_transition_response_result;
  class T_inspect_response;
  class T_inspect_process;
  class T_inspect_port;
  class T_inspect_instance;
  class T_inspect_cluster;
  class T_inspect_system;
  class T_inspect_channel;
  class T_stackframe;
  class T_inspect_variable_context;
  class T_inspect_variable;
  class T_inspect_data;
  class T_inspect_transition;
  class T_observe_response;
  class T_execution_state_change_response;
  class T_eengine_event_setup_response;
  class T_communication_event;
  class T_eengine_event_error_response;
  class T_communcation_event_node;
  class T_error_stacktrace;
  class T_error_stackframe;
  class T_communication_event_message;
  class T_communication_event_parameter;
  class T_breakpoint;
  class T_breakpoint_info;
  class T_error_info;
  class T_create_breakpoint_response;
  class T_create_breakpoint_response_result;
  class T_set_breakpoint_condition_response;
  class T_set_breakpoint_condition_response_result;
  class T_enable_breakpoint_response;
  class T_disable_breakpoint_response;
  class T_delete_breakpoint_response;
  class T_breakpoint_result;
  class T_breakpoint_result_result;
  class T_var_list;
  class T_variable;
  class T_method_list;
  class T_method;
  class T_executiontree;
  class T_executiontree_base;
  class T_executiontree_statements;
  class T_executiontree_method_call;
  class T_executiontree_message_receive;
  class T_executiontree_expression;
  class T_cluster_instance_interface;
  class T_cluster_instance_port;
  class T_graphics_port;
  class T_graphics_channel;
  class T_channel_node;
  class T_message_location;
  class T_scenario;
  class T_inspector_instance;
  class T_box_name_scenarios;
  class T_set_variable_response;
  class Response;
  class File;
  class Channel;
  class Aspect;
  class Parameter;
  class Node;
  class Instance_port;
  class Cluster_port;
  class Connection;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-iso8859-1.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

#include "rotalumisapitypes.hxx"

#include "pooslmodel.hxx"

namespace poosl
{
  class T_load_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_file_io_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // error
    //
    typedef ::xml_schema::String ErrorType;
    typedef ::xsd::cxx::tree::traits< ErrorType, char > ErrorTraits;

    const ErrorType&
    getError () const;

    ErrorType&
    getError ();

    void
    setError (const ErrorType& x);

    void
    setError (::std::unique_ptr< ErrorType > p);

    // contents
    //
    typedef ::xml_schema::String ContentsType;
    typedef ::xsd::cxx::tree::traits< ContentsType, char > ContentsTraits;

    const ContentsType&
    getContents () const;

    ContentsType&
    getContents ();

    void
    setContents (const ContentsType& x);

    void
    setContents (::std::unique_ptr< ContentsType > p);

    // Constructors.
    //
    T_load_response ();

    T_load_response (const ResultType&,
                     const ErrorType&,
                     const ContentsType&);

    T_load_response (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_load_response (const T_load_response& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual T_load_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_load_response&
    operator= (const T_load_response& x);

    virtual 
    ~T_load_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
    ::xsd::cxx::tree::one< ErrorType > error_;
    ::xsd::cxx::tree::one< ContentsType > contents_;
  };

  class T_save_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_file_io_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // error
    //
    typedef ::xml_schema::String ErrorType;
    typedef ::xsd::cxx::tree::traits< ErrorType, char > ErrorTraits;

    const ErrorType&
    getError () const;

    ErrorType&
    getError ();

    void
    setError (const ErrorType& x);

    void
    setError (::std::unique_ptr< ErrorType > p);

    // Constructors.
    //
    T_save_response ();

    T_save_response (const ResultType&,
                     const ErrorType&);

    T_save_response (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_save_response (const T_save_response& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual T_save_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_save_response&
    operator= (const T_save_response& x);

    virtual 
    ~T_save_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
    ::xsd::cxx::tree::one< ErrorType > error_;
  };

  class T_file_io_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      OK,
      file_does_not_exist,
      cannot_create_file,
      disk_full,
      timed_out
    };

    T_file_io_result ();

    T_file_io_result (Value v);

    T_file_io_result (const char* v);

    T_file_io_result (const ::std::string& v);

    T_file_io_result (const ::xml_schema::String& v);

    T_file_io_result (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_file_io_result (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_file_io_result (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_file_io_result (const T_file_io_result& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual T_file_io_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_file_io_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_file_io_result_convert ();
    }

    protected:
    Value
    _xsd_T_file_io_result_convert () const;

    public:
    static const char* const _xsd_T_file_io_result_literals_[5];
    static const Value _xsd_T_file_io_result_indexes_[5];
  };

  class T_serialize_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_serialize_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // contents
    //
    typedef ::xml_schema::String ContentsType;
    typedef ::xsd::cxx::tree::traits< ContentsType, char > ContentsTraits;

    const ContentsType&
    getContents () const;

    ContentsType&
    getContents ();

    void
    setContents (const ContentsType& x);

    void
    setContents (::std::unique_ptr< ContentsType > p);

    // Constructors.
    //
    T_serialize_response ();

    T_serialize_response (const ResultType&,
                          const ContentsType&);

    T_serialize_response (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    T_serialize_response (const T_serialize_response& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual T_serialize_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_serialize_response&
    operator= (const T_serialize_response& x);

    virtual 
    ~T_serialize_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
    ::xsd::cxx::tree::one< ContentsType > contents_;
  };

  class T_deserialize_response: public ::xml_schema::Type
  {
    public:
    // error
    //
    typedef ::xml_schema::String ErrorType;
    typedef ::xsd::cxx::tree::traits< ErrorType, char > ErrorTraits;

    const ErrorType&
    getError () const;

    ErrorType&
    getError ();

    void
    setError (const ErrorType& x);

    void
    setError (::std::unique_ptr< ErrorType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // Constructors.
    //
    T_deserialize_response ();

    T_deserialize_response (const ErrorType&,
                            const HandleType&);

    T_deserialize_response (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    T_deserialize_response (const T_deserialize_response& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual T_deserialize_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_deserialize_response&
    operator= (const T_deserialize_response& x);

    virtual 
    ~T_deserialize_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ErrorType > error_;
    ::xsd::cxx::tree::one< HandleType > handle_;
  };

  class T_compile_response: public ::xml_schema::Type
  {
    public:
    // error
    //
    typedef ::xml_schema::String ErrorType;
    typedef ::xsd::cxx::tree::traits< ErrorType, char > ErrorTraits;

    const ErrorType&
    getError () const;

    ErrorType&
    getError ();

    void
    setError (const ErrorType& x);

    void
    setError (::std::unique_ptr< ErrorType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // Constructors.
    //
    T_compile_response ();

    T_compile_response (const ErrorType&,
                        const HandleType&);

    T_compile_response (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_compile_response (const T_compile_response& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_compile_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_compile_response&
    operator= (const T_compile_response& x);

    virtual 
    ~T_compile_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ErrorType > error_;
    ::xsd::cxx::tree::one< HandleType > handle_;
  };

  class T_serialize_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      ok,
      unknown_handle
    };

    T_serialize_result ();

    T_serialize_result (Value v);

    T_serialize_result (const char* v);

    T_serialize_result (const ::std::string& v);

    T_serialize_result (const ::xml_schema::String& v);

    T_serialize_result (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_serialize_result (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_serialize_result (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_serialize_result (const T_serialize_result& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_serialize_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_serialize_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_serialize_result_convert ();
    }

    protected:
    Value
    _xsd_T_serialize_result_convert () const;

    public:
    static const char* const _xsd_T_serialize_result_literals_[2];
    static const Value _xsd_T_serialize_result_indexes_[2];
  };

  class T_parse_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      ok,
      failed_to_parse
    };

    T_parse_result ();

    T_parse_result (Value v);

    T_parse_result (const char* v);

    T_parse_result (const ::std::string& v);

    T_parse_result (const ::xml_schema::String& v);

    T_parse_result (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_parse_result (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_parse_result (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_parse_result (const T_parse_result& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual T_parse_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_parse_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_parse_result_convert ();
    }

    protected:
    Value
    _xsd_T_parse_result_convert () const;

    public:
    static const char* const _xsd_T_parse_result_literals_[2];
    static const Value _xsd_T_parse_result_indexes_[2];
  };

  class T_list_classes_response: public ::xml_schema::Type
  {
    public:
    // class_name
    //
    typedef ::poosl::T_class_name Class_nameType;
    typedef ::xsd::cxx::tree::sequence< Class_nameType > Class_nameSequence;
    typedef Class_nameSequence::iterator Class_nameIterator;
    typedef Class_nameSequence::const_iterator Class_nameConstIterator;
    typedef ::xsd::cxx::tree::traits< Class_nameType, char > Class_nameTraits;

    const Class_nameSequence&
    getClass_name () const;

    Class_nameSequence&
    getClass_name ();

    void
    setClass_name (const Class_nameSequence& s);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::sequence< HandleType > HandleSequence;
    typedef HandleSequence::iterator HandleIterator;
    typedef HandleSequence::const_iterator HandleConstIterator;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleSequence&
    getHandle () const;

    HandleSequence&
    getHandle ();

    void
    setHandle (const HandleSequence& s);

    // Constructors.
    //
    T_list_classes_response ();

    T_list_classes_response (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    T_list_classes_response (const T_list_classes_response& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual T_list_classes_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_list_classes_response&
    operator= (const T_list_classes_response& x);

    virtual 
    ~T_list_classes_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Class_nameSequence class_name_;
    HandleSequence handle_;
  };

  class T_list_files_response: public ::xml_schema::Type
  {
    public:
    // file
    //
    typedef ::poosl::File FileType;
    typedef ::xsd::cxx::tree::sequence< FileType > FileSequence;
    typedef FileSequence::iterator FileIterator;
    typedef FileSequence::const_iterator FileConstIterator;
    typedef ::xsd::cxx::tree::traits< FileType, char > FileTraits;

    const FileSequence&
    getFile () const;

    FileSequence&
    getFile ();

    void
    setFile (const FileSequence& s);

    // Constructors.
    //
    T_list_files_response ();

    T_list_files_response (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_list_files_response (const T_list_files_response& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual T_list_files_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_list_files_response&
    operator= (const T_list_files_response& x);

    virtual 
    ~T_list_files_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    FileSequence file_;
  };

  class T_get_position_response: public ::xml_schema::Type
  {
    public:
    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleType&
    getStmt_handle () const;

    Stmt_handleType&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    // begin
    //
    typedef ::poosl::T_source_position BeginType;
    typedef ::xsd::cxx::tree::traits< BeginType, char > BeginTraits;

    const BeginType&
    getBegin () const;

    BeginType&
    getBegin ();

    void
    setBegin (const BeginType& x);

    void
    setBegin (::std::unique_ptr< BeginType > p);

    // end
    //
    typedef ::poosl::T_source_position EndType;
    typedef ::xsd::cxx::tree::traits< EndType, char > EndTraits;

    const EndType&
    getEnd () const;

    EndType&
    getEnd ();

    void
    setEnd (const EndType& x);

    void
    setEnd (::std::unique_ptr< EndType > p);

    // Constructors.
    //
    T_get_position_response ();

    T_get_position_response (const Stmt_handleType&,
                             const BeginType&,
                             const EndType&);

    T_get_position_response (const Stmt_handleType&,
                             ::std::unique_ptr< BeginType >,
                             ::std::unique_ptr< EndType >);

    T_get_position_response (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    T_get_position_response (const T_get_position_response& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual T_get_position_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_get_position_response&
    operator= (const T_get_position_response& x);

    virtual 
    ~T_get_position_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Stmt_handleType > stmt_handle_;
    ::xsd::cxx::tree::one< BeginType > begin_;
    ::xsd::cxx::tree::one< EndType > end_;
  };

  class T_get_top_level_specification_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_object_query_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // class_name
    //
    typedef ::poosl::T_class_name Class_nameType;
    typedef ::xsd::cxx::tree::traits< Class_nameType, char > Class_nameTraits;

    const Class_nameType&
    getClass_name () const;

    Class_nameType&
    getClass_name ();

    void
    setClass_name (const Class_nameType& x);

    void
    setClass_name (::std::unique_ptr< Class_nameType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // Constructors.
    //
    T_get_top_level_specification_response ();

    T_get_top_level_specification_response (const ResultType&,
                                            const Class_nameType&,
                                            const HandleType&);

    T_get_top_level_specification_response (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f = 0,
                                            ::xml_schema::Container* c = 0);

    T_get_top_level_specification_response (const T_get_top_level_specification_response& x,
                                            ::xml_schema::Flags f = 0,
                                            ::xml_schema::Container* c = 0);

    virtual T_get_top_level_specification_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_get_top_level_specification_response&
    operator= (const T_get_top_level_specification_response& x);

    virtual 
    ~T_get_top_level_specification_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
    ::xsd::cxx::tree::one< Class_nameType > class_name_;
    ::xsd::cxx::tree::one< HandleType > handle_;
  };

  class T_get_class_definition_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_object_query_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // cluster_class
    //
    typedef ::poosl::T_cluster_class_def Cluster_classType;
    typedef ::xsd::cxx::tree::optional< Cluster_classType > Cluster_classOptional;
    typedef ::xsd::cxx::tree::traits< Cluster_classType, char > Cluster_classTraits;

    const Cluster_classOptional&
    getCluster_class () const;

    Cluster_classOptional&
    getCluster_class ();

    void
    setCluster_class (const Cluster_classType& x);

    void
    setCluster_class (const Cluster_classOptional& x);

    void
    setCluster_class (::std::unique_ptr< Cluster_classType > p);

    // process_class
    //
    typedef ::poosl::T_process_class_def Process_classType;
    typedef ::xsd::cxx::tree::optional< Process_classType > Process_classOptional;
    typedef ::xsd::cxx::tree::traits< Process_classType, char > Process_classTraits;

    const Process_classOptional&
    getProcess_class () const;

    Process_classOptional&
    getProcess_class ();

    void
    setProcess_class (const Process_classType& x);

    void
    setProcess_class (const Process_classOptional& x);

    void
    setProcess_class (::std::unique_ptr< Process_classType > p);

    // data_class
    //
    typedef ::poosl::T_data_class_def Data_classType;
    typedef ::xsd::cxx::tree::optional< Data_classType > Data_classOptional;
    typedef ::xsd::cxx::tree::traits< Data_classType, char > Data_classTraits;

    const Data_classOptional&
    getData_class () const;

    Data_classOptional&
    getData_class ();

    void
    setData_class (const Data_classType& x);

    void
    setData_class (const Data_classOptional& x);

    void
    setData_class (::std::unique_ptr< Data_classType > p);

    // Constructors.
    //
    T_get_class_definition_response ();

    T_get_class_definition_response (const ResultType&);

    T_get_class_definition_response (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    T_get_class_definition_response (const T_get_class_definition_response& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    virtual T_get_class_definition_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_get_class_definition_response&
    operator= (const T_get_class_definition_response& x);

    virtual 
    ~T_get_class_definition_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
    Cluster_classOptional cluster_class_;
    Process_classOptional process_class_;
    Data_classOptional data_class_;
  };

  class T_cluster_class_def: public ::xml_schema::Type
  {
    public:
    // class
    //
    typedef ::poosl::T_class_name ClassType;
    typedef ::xsd::cxx::tree::traits< ClassType, char > ClassTraits;

    const ClassType&
    getClass () const;

    ClassType&
    getClass ();

    void
    setClass (const ClassType& x);

    void
    setClass (::std::unique_ptr< ClassType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // instatiation_parameters
    //
    typedef ::poosl::T_var_list Instatiation_parametersType;
    typedef ::xsd::cxx::tree::traits< Instatiation_parametersType, char > Instatiation_parametersTraits;

    const Instatiation_parametersType&
    getInstatiation_parameters () const;

    Instatiation_parametersType&
    getInstatiation_parameters ();

    void
    setInstatiation_parameters (const Instatiation_parametersType& x);

    void
    setInstatiation_parameters (::std::unique_ptr< Instatiation_parametersType > p);

    // instance
    //
    typedef ::poosl::T_instance InstanceType;
    typedef ::xsd::cxx::tree::sequence< InstanceType > InstanceSequence;
    typedef InstanceSequence::iterator InstanceIterator;
    typedef InstanceSequence::const_iterator InstanceConstIterator;
    typedef ::xsd::cxx::tree::traits< InstanceType, char > InstanceTraits;

    const InstanceSequence&
    getInstance () const;

    InstanceSequence&
    getInstance ();

    void
    setInstance (const InstanceSequence& s);

    // Constructors.
    //
    T_cluster_class_def ();

    T_cluster_class_def (const ClassType&,
                         const HandleType&,
                         const Instatiation_parametersType&);

    T_cluster_class_def (const ClassType&,
                         const HandleType&,
                         ::std::unique_ptr< Instatiation_parametersType >);

    T_cluster_class_def (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    T_cluster_class_def (const T_cluster_class_def& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual T_cluster_class_def*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_cluster_class_def&
    operator= (const T_cluster_class_def& x);

    virtual 
    ~T_cluster_class_def ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ClassType > class__;
    ::xsd::cxx::tree::one< HandleType > handle_;
    ::xsd::cxx::tree::one< Instatiation_parametersType > instatiation_parameters_;
    InstanceSequence instance_;
  };

  class T_process_class_def: public ::xml_schema::Type
  {
    public:
    // class
    //
    typedef ::poosl::T_class_name ClassType;
    typedef ::xsd::cxx::tree::traits< ClassType, char > ClassTraits;

    const ClassType&
    getClass () const;

    ClassType&
    getClass ();

    void
    setClass (const ClassType& x);

    void
    setClass (::std::unique_ptr< ClassType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // instatiation_parameters
    //
    typedef ::poosl::T_var_list Instatiation_parametersType;
    typedef ::xsd::cxx::tree::traits< Instatiation_parametersType, char > Instatiation_parametersTraits;

    const Instatiation_parametersType&
    getInstatiation_parameters () const;

    Instatiation_parametersType&
    getInstatiation_parameters ();

    void
    setInstatiation_parameters (const Instatiation_parametersType& x);

    void
    setInstatiation_parameters (::std::unique_ptr< Instatiation_parametersType > p);

    // interface
    //
    typedef ::poosl::T_interface InterfaceType;
    typedef ::xsd::cxx::tree::traits< InterfaceType, char > InterfaceTraits;

    const InterfaceType&
    getInterface () const;

    InterfaceType&
    getInterface ();

    void
    setInterface (const InterfaceType& x);

    void
    setInterface (::std::unique_ptr< InterfaceType > p);

    // instance_variables
    //
    typedef ::poosl::T_var_list Instance_variablesType;
    typedef ::xsd::cxx::tree::traits< Instance_variablesType, char > Instance_variablesTraits;

    const Instance_variablesType&
    getInstance_variables () const;

    Instance_variablesType&
    getInstance_variables ();

    void
    setInstance_variables (const Instance_variablesType& x);

    void
    setInstance_variables (::std::unique_ptr< Instance_variablesType > p);

    // initial_method_call
    //
    typedef ::poosl::T_method Initial_method_callType;
    typedef ::xsd::cxx::tree::traits< Initial_method_callType, char > Initial_method_callTraits;

    const Initial_method_callType&
    getInitial_method_call () const;

    Initial_method_callType&
    getInitial_method_call ();

    void
    setInitial_method_call (const Initial_method_callType& x);

    void
    setInitial_method_call (::std::unique_ptr< Initial_method_callType > p);

    // methods
    //
    typedef ::poosl::T_method_list MethodsType;
    typedef ::xsd::cxx::tree::traits< MethodsType, char > MethodsTraits;

    const MethodsType&
    getMethods () const;

    MethodsType&
    getMethods ();

    void
    setMethods (const MethodsType& x);

    void
    setMethods (::std::unique_ptr< MethodsType > p);

    // Constructors.
    //
    T_process_class_def ();

    T_process_class_def (const ClassType&,
                         const HandleType&,
                         const Instatiation_parametersType&,
                         const InterfaceType&,
                         const Instance_variablesType&,
                         const Initial_method_callType&,
                         const MethodsType&);

    T_process_class_def (const ClassType&,
                         const HandleType&,
                         ::std::unique_ptr< Instatiation_parametersType >,
                         ::std::unique_ptr< InterfaceType >,
                         ::std::unique_ptr< Instance_variablesType >,
                         ::std::unique_ptr< Initial_method_callType >,
                         ::std::unique_ptr< MethodsType >);

    T_process_class_def (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    T_process_class_def (const T_process_class_def& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual T_process_class_def*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_process_class_def&
    operator= (const T_process_class_def& x);

    virtual 
    ~T_process_class_def ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ClassType > class__;
    ::xsd::cxx::tree::one< HandleType > handle_;
    ::xsd::cxx::tree::one< Instatiation_parametersType > instatiation_parameters_;
    ::xsd::cxx::tree::one< InterfaceType > interface_;
    ::xsd::cxx::tree::one< Instance_variablesType > instance_variables_;
    ::xsd::cxx::tree::one< Initial_method_callType > initial_method_call_;
    ::xsd::cxx::tree::one< MethodsType > methods_;
  };

  class T_data_class_def: public ::xml_schema::Type
  {
    public:
    // class
    //
    typedef ::poosl::T_class_name ClassType;
    typedef ::xsd::cxx::tree::traits< ClassType, char > ClassTraits;

    const ClassType&
    getClass () const;

    ClassType&
    getClass ();

    void
    setClass (const ClassType& x);

    void
    setClass (::std::unique_ptr< ClassType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // instance_variables
    //
    typedef ::poosl::T_var_list Instance_variablesType;
    typedef ::xsd::cxx::tree::traits< Instance_variablesType, char > Instance_variablesTraits;

    const Instance_variablesType&
    getInstance_variables () const;

    Instance_variablesType&
    getInstance_variables ();

    void
    setInstance_variables (const Instance_variablesType& x);

    void
    setInstance_variables (::std::unique_ptr< Instance_variablesType > p);

    // methods
    //
    typedef ::poosl::T_method_list MethodsType;
    typedef ::xsd::cxx::tree::traits< MethodsType, char > MethodsTraits;

    const MethodsType&
    getMethods () const;

    MethodsType&
    getMethods ();

    void
    setMethods (const MethodsType& x);

    void
    setMethods (::std::unique_ptr< MethodsType > p);

    // Constructors.
    //
    T_data_class_def ();

    T_data_class_def (const ClassType&,
                      const HandleType&,
                      const Instance_variablesType&,
                      const MethodsType&);

    T_data_class_def (const ClassType&,
                      const HandleType&,
                      ::std::unique_ptr< Instance_variablesType >,
                      ::std::unique_ptr< MethodsType >);

    T_data_class_def (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_data_class_def (const T_data_class_def& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual T_data_class_def*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_data_class_def&
    operator= (const T_data_class_def& x);

    virtual 
    ~T_data_class_def ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ClassType > class__;
    ::xsd::cxx::tree::one< HandleType > handle_;
    ::xsd::cxx::tree::one< Instance_variablesType > instance_variables_;
    ::xsd::cxx::tree::one< MethodsType > methods_;
  };

  class T_get_method_definition_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_object_query_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // process_method
    //
    typedef ::poosl::T_process_method_def Process_methodType;
    typedef ::xsd::cxx::tree::optional< Process_methodType > Process_methodOptional;
    typedef ::xsd::cxx::tree::traits< Process_methodType, char > Process_methodTraits;

    const Process_methodOptional&
    getProcess_method () const;

    Process_methodOptional&
    getProcess_method ();

    void
    setProcess_method (const Process_methodType& x);

    void
    setProcess_method (const Process_methodOptional& x);

    void
    setProcess_method (::std::unique_ptr< Process_methodType > p);

    // data_method
    //
    typedef ::poosl::T_data_method_def Data_methodType;
    typedef ::xsd::cxx::tree::optional< Data_methodType > Data_methodOptional;
    typedef ::xsd::cxx::tree::traits< Data_methodType, char > Data_methodTraits;

    const Data_methodOptional&
    getData_method () const;

    Data_methodOptional&
    getData_method ();

    void
    setData_method (const Data_methodType& x);

    void
    setData_method (const Data_methodOptional& x);

    void
    setData_method (::std::unique_ptr< Data_methodType > p);

    // Constructors.
    //
    T_get_method_definition_response ();

    T_get_method_definition_response (const ResultType&);

    T_get_method_definition_response (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    T_get_method_definition_response (const T_get_method_definition_response& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

    virtual T_get_method_definition_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_get_method_definition_response&
    operator= (const T_get_method_definition_response& x);

    virtual 
    ~T_get_method_definition_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
    Process_methodOptional process_method_;
    Data_methodOptional data_method_;
  };

  class T_process_method_def: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::xml_schema::String NameType;
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameOptional&
    getName () const;

    NameOptional&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (const NameOptional& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // input_parameter
    //
    typedef ::poosl::T_variable Input_parameterType;
    typedef ::xsd::cxx::tree::sequence< Input_parameterType > Input_parameterSequence;
    typedef Input_parameterSequence::iterator Input_parameterIterator;
    typedef Input_parameterSequence::const_iterator Input_parameterConstIterator;
    typedef ::xsd::cxx::tree::traits< Input_parameterType, char > Input_parameterTraits;

    const Input_parameterSequence&
    getInput_parameter () const;

    Input_parameterSequence&
    getInput_parameter ();

    void
    setInput_parameter (const Input_parameterSequence& s);

    // output_parameter
    //
    typedef ::poosl::T_variable Output_parameterType;
    typedef ::xsd::cxx::tree::sequence< Output_parameterType > Output_parameterSequence;
    typedef Output_parameterSequence::iterator Output_parameterIterator;
    typedef Output_parameterSequence::const_iterator Output_parameterConstIterator;
    typedef ::xsd::cxx::tree::traits< Output_parameterType, char > Output_parameterTraits;

    const Output_parameterSequence&
    getOutput_parameter () const;

    Output_parameterSequence&
    getOutput_parameter ();

    void
    setOutput_parameter (const Output_parameterSequence& s);

    // local_variable
    //
    typedef ::poosl::T_variable Local_variableType;
    typedef ::xsd::cxx::tree::sequence< Local_variableType > Local_variableSequence;
    typedef Local_variableSequence::iterator Local_variableIterator;
    typedef Local_variableSequence::const_iterator Local_variableConstIterator;
    typedef ::xsd::cxx::tree::traits< Local_variableType, char > Local_variableTraits;

    const Local_variableSequence&
    getLocal_variable () const;

    Local_variableSequence&
    getLocal_variable ();

    void
    setLocal_variable (const Local_variableSequence& s);

    // body_text
    //
    typedef ::xml_schema::String Body_textType;
    typedef ::xsd::cxx::tree::traits< Body_textType, char > Body_textTraits;

    const Body_textType&
    getBody_text () const;

    Body_textType&
    getBody_text ();

    void
    setBody_text (const Body_textType& x);

    void
    setBody_text (::std::unique_ptr< Body_textType > p);

    // body_statements
    //
    typedef ::poosl::T_statement Body_statementsType;
    typedef ::xsd::cxx::tree::optional< Body_statementsType > Body_statementsOptional;
    typedef ::xsd::cxx::tree::traits< Body_statementsType, char > Body_statementsTraits;

    const Body_statementsOptional&
    getBody_statements () const;

    Body_statementsOptional&
    getBody_statements ();

    void
    setBody_statements (const Body_statementsType& x);

    void
    setBody_statements (const Body_statementsOptional& x);

    void
    setBody_statements (::std::unique_ptr< Body_statementsType > p);

    // Constructors.
    //
    T_process_method_def ();

    T_process_method_def (const Body_textType&);

    T_process_method_def (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    T_process_method_def (const T_process_method_def& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual T_process_method_def*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_process_method_def&
    operator= (const T_process_method_def& x);

    virtual 
    ~T_process_method_def ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NameOptional name_;
    Input_parameterSequence input_parameter_;
    Output_parameterSequence output_parameter_;
    Local_variableSequence local_variable_;
    ::xsd::cxx::tree::one< Body_textType > body_text_;
    Body_statementsOptional body_statements_;
  };

  class T_data_method_def: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::xml_schema::String NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // argument
    //
    typedef ::poosl::T_variable ArgumentType;
    typedef ::xsd::cxx::tree::sequence< ArgumentType > ArgumentSequence;
    typedef ArgumentSequence::iterator ArgumentIterator;
    typedef ArgumentSequence::const_iterator ArgumentConstIterator;
    typedef ::xsd::cxx::tree::traits< ArgumentType, char > ArgumentTraits;

    const ArgumentSequence&
    getArgument () const;

    ArgumentSequence&
    getArgument ();

    void
    setArgument (const ArgumentSequence& s);

    // local_variable
    //
    typedef ::poosl::T_variable Local_variableType;
    typedef ::xsd::cxx::tree::sequence< Local_variableType > Local_variableSequence;
    typedef Local_variableSequence::iterator Local_variableIterator;
    typedef Local_variableSequence::const_iterator Local_variableConstIterator;
    typedef ::xsd::cxx::tree::traits< Local_variableType, char > Local_variableTraits;

    const Local_variableSequence&
    getLocal_variable () const;

    Local_variableSequence&
    getLocal_variable ();

    void
    setLocal_variable (const Local_variableSequence& s);

    // body_text
    //
    typedef ::xml_schema::String Body_textType;
    typedef ::xsd::cxx::tree::traits< Body_textType, char > Body_textTraits;

    const Body_textType&
    getBody_text () const;

    Body_textType&
    getBody_text ();

    void
    setBody_text (const Body_textType& x);

    void
    setBody_text (::std::unique_ptr< Body_textType > p);

    // body_expression
    //
    typedef ::poosl::T_expression Body_expressionType;
    typedef ::xsd::cxx::tree::optional< Body_expressionType > Body_expressionOptional;
    typedef ::xsd::cxx::tree::traits< Body_expressionType, char > Body_expressionTraits;

    const Body_expressionOptional&
    getBody_expression () const;

    Body_expressionOptional&
    getBody_expression ();

    void
    setBody_expression (const Body_expressionType& x);

    void
    setBody_expression (const Body_expressionOptional& x);

    void
    setBody_expression (::std::unique_ptr< Body_expressionType > p);

    // return_type
    //
    typedef ::poosl::T_poosl_type Return_typeType;
    typedef ::xsd::cxx::tree::traits< Return_typeType, char > Return_typeTraits;

    const Return_typeType&
    getReturn_type () const;

    Return_typeType&
    getReturn_type ();

    void
    setReturn_type (const Return_typeType& x);

    void
    setReturn_type (::std::unique_ptr< Return_typeType > p);

    // Constructors.
    //
    T_data_method_def ();

    T_data_method_def (const NameType&,
                       const Body_textType&,
                       const Return_typeType&);

    T_data_method_def (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_data_method_def (const T_data_method_def& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_data_method_def*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_data_method_def&
    operator= (const T_data_method_def& x);

    virtual 
    ~T_data_method_def ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ArgumentSequence argument_;
    Local_variableSequence local_variable_;
    ::xsd::cxx::tree::one< Body_textType > body_text_;
    Body_expressionOptional body_expression_;
    ::xsd::cxx::tree::one< Return_typeType > return_type_;
  };

  class T_get_object_handle_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_object_query_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // Constructors.
    //
    T_get_object_handle_response ();

    T_get_object_handle_response (const ResultType&,
                                  const HandleType&);

    T_get_object_handle_response (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    T_get_object_handle_response (const T_get_object_handle_response& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    virtual T_get_object_handle_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_get_object_handle_response&
    operator= (const T_get_object_handle_response& x);

    virtual 
    ~T_get_object_handle_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
    ::xsd::cxx::tree::one< HandleType > handle_;
  };

  class T_rename_object_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_rename_object_response_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // Constructors.
    //
    T_rename_object_response ();

    T_rename_object_response (const ResultType&);

    T_rename_object_response (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    T_rename_object_response (const T_rename_object_response& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual T_rename_object_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_rename_object_response&
    operator= (const T_rename_object_response& x);

    virtual 
    ~T_rename_object_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
  };

  class T_rename_object_response_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      ok,
      name_clash,
      unknown_handle
    };

    T_rename_object_response_result ();

    T_rename_object_response_result (Value v);

    T_rename_object_response_result (const char* v);

    T_rename_object_response_result (const ::std::string& v);

    T_rename_object_response_result (const ::xml_schema::String& v);

    T_rename_object_response_result (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    T_rename_object_response_result (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    T_rename_object_response_result (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    T_rename_object_response_result (const T_rename_object_response_result& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    virtual T_rename_object_response_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_rename_object_response_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_rename_object_response_result_convert ();
    }

    protected:
    Value
    _xsd_T_rename_object_response_result_convert () const;

    public:
    static const char* const _xsd_T_rename_object_response_result_literals_[3];
    static const Value _xsd_T_rename_object_response_result_indexes_[3];
  };

  class T_insert_object_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_insert_object_response_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // Constructors.
    //
    T_insert_object_response ();

    T_insert_object_response (const ResultType&);

    T_insert_object_response (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    T_insert_object_response (const T_insert_object_response& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual T_insert_object_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_insert_object_response&
    operator= (const T_insert_object_response& x);

    virtual 
    ~T_insert_object_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
  };

  class T_insert_object_response_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      ok,
      unknown_property,
      invalid_owner_handle,
      invalid_value_handle
    };

    T_insert_object_response_result ();

    T_insert_object_response_result (Value v);

    T_insert_object_response_result (const char* v);

    T_insert_object_response_result (const ::std::string& v);

    T_insert_object_response_result (const ::xml_schema::String& v);

    T_insert_object_response_result (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    T_insert_object_response_result (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    T_insert_object_response_result (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    T_insert_object_response_result (const T_insert_object_response_result& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    virtual T_insert_object_response_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_insert_object_response_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_insert_object_response_result_convert ();
    }

    protected:
    Value
    _xsd_T_insert_object_response_result_convert () const;

    public:
    static const char* const _xsd_T_insert_object_response_result_literals_[4];
    static const Value _xsd_T_insert_object_response_result_indexes_[4];
  };

  class T_delete_object_response: public ::xml_schema::Type
  {
    public:
    // object
    //
    typedef ::xml_schema::Integer ObjectType;
    typedef ::xsd::cxx::tree::sequence< ObjectType > ObjectSequence;
    typedef ObjectSequence::iterator ObjectIterator;
    typedef ObjectSequence::const_iterator ObjectConstIterator;
    typedef ::xsd::cxx::tree::traits< ObjectType, char > ObjectTraits;

    const ObjectSequence&
    getObject () const;

    ObjectSequence&
    getObject ();

    void
    setObject (const ObjectSequence& s);

    // result
    //
    typedef ::poosl::T_object_query_result ResultType;
    typedef ::xsd::cxx::tree::sequence< ResultType > ResultSequence;
    typedef ResultSequence::iterator ResultIterator;
    typedef ResultSequence::const_iterator ResultConstIterator;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultSequence&
    getResult () const;

    ResultSequence&
    getResult ();

    void
    setResult (const ResultSequence& s);

    // Constructors.
    //
    T_delete_object_response ();

    T_delete_object_response (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    T_delete_object_response (const T_delete_object_response& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual T_delete_object_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_delete_object_response&
    operator= (const T_delete_object_response& x);

    virtual 
    ~T_delete_object_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ObjectSequence object_;
    ResultSequence result_;
  };

  class T_object_query_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      ok,
      unknown_object,
      unknown_handle
    };

    T_object_query_result ();

    T_object_query_result (Value v);

    T_object_query_result (const char* v);

    T_object_query_result (const ::std::string& v);

    T_object_query_result (const ::xml_schema::String& v);

    T_object_query_result (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_object_query_result (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_object_query_result (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_object_query_result (const T_object_query_result& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual T_object_query_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_object_query_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_object_query_result_convert ();
    }

    protected:
    Value
    _xsd_T_object_query_result_convert () const;

    public:
    static const char* const _xsd_T_object_query_result_literals_[3];
    static const Value _xsd_T_object_query_result_indexes_[3];
  };

  class T_instantiate_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_instantiate_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // Constructors.
    //
    T_instantiate_response ();

    T_instantiate_response (const ResultType&);

    T_instantiate_response (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    T_instantiate_response (const T_instantiate_response& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual T_instantiate_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_instantiate_response&
    operator= (const T_instantiate_response& x);

    virtual 
    ~T_instantiate_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
  };

  class T_instantiate_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      ok,
      invalid_specification,
      unknown_handle
    };

    T_instantiate_result ();

    T_instantiate_result (Value v);

    T_instantiate_result (const char* v);

    T_instantiate_result (const ::std::string& v);

    T_instantiate_result (const ::xml_schema::String& v);

    T_instantiate_result (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    T_instantiate_result (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    T_instantiate_result (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    T_instantiate_result (const T_instantiate_result& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual T_instantiate_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_instantiate_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_instantiate_result_convert ();
    }

    protected:
    Value
    _xsd_T_instantiate_result_convert () const;

    public:
    static const char* const _xsd_T_instantiate_result_literals_[3];
    static const Value _xsd_T_instantiate_result_indexes_[3];
  };

  class T_command_response: public ::xml_schema::Type
  {
    public:
    // type
    //
    typedef ::poosl::T_command TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    getType () const;

    TypeOptional&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (const TypeOptional& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // result
    //
    typedef ::xml_schema::String ResultType;
    typedef ::xsd::cxx::tree::optional< ResultType > ResultOptional;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultOptional&
    getResult () const;

    ResultOptional&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (const ResultOptional& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // Constructors.
    //
    T_command_response ();

    T_command_response (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_command_response (const T_command_response& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_command_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_command_response&
    operator= (const T_command_response& x);

    virtual 
    ~T_command_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TypeOptional type_;
    ResultOptional result_;
  };

  class T_get_transitions_response: public ::xml_schema::Type
  {
    public:
    // transitions
    //
    typedef ::poosl::T_transition_list TransitionsType;
    typedef ::xsd::cxx::tree::traits< TransitionsType, char > TransitionsTraits;

    const TransitionsType&
    getTransitions () const;

    TransitionsType&
    getTransitions ();

    void
    setTransitions (const TransitionsType& x);

    void
    setTransitions (::std::unique_ptr< TransitionsType > p);

    // Constructors.
    //
    T_get_transitions_response ();

    T_get_transitions_response (const TransitionsType&);

    T_get_transitions_response (::std::unique_ptr< TransitionsType >);

    T_get_transitions_response (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    T_get_transitions_response (const T_get_transitions_response& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual T_get_transitions_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_get_transitions_response&
    operator= (const T_get_transitions_response& x);

    virtual 
    ~T_get_transitions_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TransitionsType > transitions_;
  };

  class T_perform_transition_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_perform_transition_response_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // Constructors.
    //
    T_perform_transition_response ();

    T_perform_transition_response (const ResultType&);

    T_perform_transition_response (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    T_perform_transition_response (const T_perform_transition_response& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    virtual T_perform_transition_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_perform_transition_response&
    operator= (const T_perform_transition_response& x);

    virtual 
    ~T_perform_transition_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
  };

  class T_perform_transition_response_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      ok,
      inexecutable,
      invalid_transition,
      invalid_handle
    };

    T_perform_transition_response_result ();

    T_perform_transition_response_result (Value v);

    T_perform_transition_response_result (const char* v);

    T_perform_transition_response_result (const ::std::string& v);

    T_perform_transition_response_result (const ::xml_schema::String& v);

    T_perform_transition_response_result (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    T_perform_transition_response_result (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    T_perform_transition_response_result (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    T_perform_transition_response_result (const T_perform_transition_response_result& x,
                                          ::xml_schema::Flags f = 0,
                                          ::xml_schema::Container* c = 0);

    virtual T_perform_transition_response_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_perform_transition_response_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_perform_transition_response_result_convert ();
    }

    protected:
    Value
    _xsd_T_perform_transition_response_result_convert () const;

    public:
    static const char* const _xsd_T_perform_transition_response_result_literals_[4];
    static const Value _xsd_T_perform_transition_response_result_indexes_[4];
  };

  class T_inspect_response: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::poosl::T_instance_name NameType;
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameOptional&
    getName () const;

    NameOptional&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (const NameOptional& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // result
    //
    typedef ::poosl::T_object_query_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // process
    //
    typedef ::poosl::T_inspect_process ProcessType;
    typedef ::xsd::cxx::tree::optional< ProcessType > ProcessOptional;
    typedef ::xsd::cxx::tree::traits< ProcessType, char > ProcessTraits;

    const ProcessOptional&
    getProcess () const;

    ProcessOptional&
    getProcess ();

    void
    setProcess (const ProcessType& x);

    void
    setProcess (const ProcessOptional& x);

    void
    setProcess (::std::unique_ptr< ProcessType > p);

    // data
    //
    typedef ::poosl::T_inspect_data DataType;
    typedef ::xsd::cxx::tree::optional< DataType > DataOptional;
    typedef ::xsd::cxx::tree::traits< DataType, char > DataTraits;

    const DataOptional&
    getData () const;

    DataOptional&
    getData ();

    void
    setData (const DataType& x);

    void
    setData (const DataOptional& x);

    void
    setData (::std::unique_ptr< DataType > p);

    // system
    //
    typedef ::poosl::T_inspect_system SystemType;
    typedef ::xsd::cxx::tree::optional< SystemType > SystemOptional;
    typedef ::xsd::cxx::tree::traits< SystemType, char > SystemTraits;

    const SystemOptional&
    getSystem () const;

    SystemOptional&
    getSystem ();

    void
    setSystem (const SystemType& x);

    void
    setSystem (const SystemOptional& x);

    void
    setSystem (::std::unique_ptr< SystemType > p);

    // channel
    //
    typedef ::poosl::T_inspect_channel ChannelType;
    typedef ::xsd::cxx::tree::optional< ChannelType > ChannelOptional;
    typedef ::xsd::cxx::tree::traits< ChannelType, char > ChannelTraits;

    const ChannelOptional&
    getChannel () const;

    ChannelOptional&
    getChannel ();

    void
    setChannel (const ChannelType& x);

    void
    setChannel (const ChannelOptional& x);

    void
    setChannel (::std::unique_ptr< ChannelType > p);

    // stackframe
    //
    typedef ::poosl::T_stackframe StackframeType;
    typedef ::xsd::cxx::tree::optional< StackframeType > StackframeOptional;
    typedef ::xsd::cxx::tree::traits< StackframeType, char > StackframeTraits;

    const StackframeOptional&
    getStackframe () const;

    StackframeOptional&
    getStackframe ();

    void
    setStackframe (const StackframeType& x);

    void
    setStackframe (const StackframeOptional& x);

    void
    setStackframe (::std::unique_ptr< StackframeType > p);

    // variable
    //
    typedef ::poosl::T_inspect_variable VariableType;
    typedef ::xsd::cxx::tree::optional< VariableType > VariableOptional;
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    const VariableOptional&
    getVariable () const;

    VariableOptional&
    getVariable ();

    void
    setVariable (const VariableType& x);

    void
    setVariable (const VariableOptional& x);

    void
    setVariable (::std::unique_ptr< VariableType > p);

    // variable_context
    //
    typedef ::poosl::T_inspect_variable_context Variable_contextType;
    typedef ::xsd::cxx::tree::optional< Variable_contextType > Variable_contextOptional;
    typedef ::xsd::cxx::tree::traits< Variable_contextType, char > Variable_contextTraits;

    const Variable_contextOptional&
    getVariable_context () const;

    Variable_contextOptional&
    getVariable_context ();

    void
    setVariable_context (const Variable_contextType& x);

    void
    setVariable_context (const Variable_contextOptional& x);

    void
    setVariable_context (::std::unique_ptr< Variable_contextType > p);

    // transition
    //
    typedef ::poosl::T_inspect_transition TransitionType;
    typedef ::xsd::cxx::tree::optional< TransitionType > TransitionOptional;
    typedef ::xsd::cxx::tree::traits< TransitionType, char > TransitionTraits;

    const TransitionOptional&
    getTransition () const;

    TransitionOptional&
    getTransition ();

    void
    setTransition (const TransitionType& x);

    void
    setTransition (const TransitionOptional& x);

    void
    setTransition (::std::unique_ptr< TransitionType > p);

    // Constructors.
    //
    T_inspect_response ();

    T_inspect_response (const HandleType&,
                        const ResultType&);

    T_inspect_response (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_inspect_response (const T_inspect_response& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_inspect_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_response&
    operator= (const T_inspect_response& x);

    virtual 
    ~T_inspect_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NameOptional name_;
    ::xsd::cxx::tree::one< HandleType > handle_;
    ::xsd::cxx::tree::one< ResultType > result_;
    ProcessOptional process_;
    DataOptional data_;
    SystemOptional system_;
    ChannelOptional channel_;
    StackframeOptional stackframe_;
    VariableOptional variable_;
    Variable_contextOptional variable_context_;
    TransitionOptional transition_;
  };

  class T_inspect_process: public ::xml_schema::Type
  {
    public:
    // instance_variables
    //
    typedef ::poosl::T_var_list Instance_variablesType;
    typedef ::xsd::cxx::tree::traits< Instance_variablesType, char > Instance_variablesTraits;

    const Instance_variablesType&
    getInstance_variables () const;

    Instance_variablesType&
    getInstance_variables ();

    void
    setInstance_variables (const Instance_variablesType& x);

    void
    setInstance_variables (::std::unique_ptr< Instance_variablesType > p);

    // execution_tree
    //
    typedef ::poosl::T_executiontree Execution_treeType;
    typedef ::xsd::cxx::tree::traits< Execution_treeType, char > Execution_treeTraits;

    const Execution_treeType&
    getExecution_tree () const;

    Execution_treeType&
    getExecution_tree ();

    void
    setExecution_tree (const Execution_treeType& x);

    void
    setExecution_tree (::std::unique_ptr< Execution_treeType > p);

    // Constructors.
    //
    T_inspect_process ();

    T_inspect_process (const Instance_variablesType&,
                       const Execution_treeType&);

    T_inspect_process (::std::unique_ptr< Instance_variablesType >,
                       ::std::unique_ptr< Execution_treeType >);

    T_inspect_process (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_inspect_process (const T_inspect_process& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_inspect_process*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_process&
    operator= (const T_inspect_process& x);

    virtual 
    ~T_inspect_process ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Instance_variablesType > instance_variables_;
    ::xsd::cxx::tree::one< Execution_treeType > execution_tree_;
  };

  class T_inspect_port: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::xml_schema::String NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // up_channel
    //
    typedef ::poosl::T_inspect_channel Up_channelType;
    typedef ::xsd::cxx::tree::optional< Up_channelType > Up_channelOptional;
    typedef ::xsd::cxx::tree::traits< Up_channelType, char > Up_channelTraits;

    const Up_channelOptional&
    getUp_channel () const;

    Up_channelOptional&
    getUp_channel ();

    void
    setUp_channel (const Up_channelType& x);

    void
    setUp_channel (const Up_channelOptional& x);

    void
    setUp_channel (::std::unique_ptr< Up_channelType > p);

    // down_channel
    //
    typedef ::poosl::T_inspect_channel Down_channelType;
    typedef ::xsd::cxx::tree::optional< Down_channelType > Down_channelOptional;
    typedef ::xsd::cxx::tree::traits< Down_channelType, char > Down_channelTraits;

    const Down_channelOptional&
    getDown_channel () const;

    Down_channelOptional&
    getDown_channel ();

    void
    setDown_channel (const Down_channelType& x);

    void
    setDown_channel (const Down_channelOptional& x);

    void
    setDown_channel (::std::unique_ptr< Down_channelType > p);

    // Constructors.
    //
    T_inspect_port ();

    T_inspect_port (const NameType&);

    T_inspect_port (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_inspect_port (const T_inspect_port& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual T_inspect_port*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_port&
    operator= (const T_inspect_port& x);

    virtual 
    ~T_inspect_port ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    Up_channelOptional up_channel_;
    Down_channelOptional down_channel_;
  };

  class T_inspect_instance: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::xml_schema::String NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // type
    //
    typedef ::xml_schema::String TypeType;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeType&
    getType () const;

    TypeType&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // process_path
    //
    typedef ::xml_schema::String Process_pathType;
    typedef ::xsd::cxx::tree::traits< Process_pathType, char > Process_pathTraits;

    const Process_pathType&
    getProcess_path () const;

    Process_pathType&
    getProcess_path ();

    void
    setProcess_path (const Process_pathType& x);

    void
    setProcess_path (::std::unique_ptr< Process_pathType > p);

    // cluster
    //
    typedef ::poosl::T_inspect_cluster ClusterType;
    typedef ::xsd::cxx::tree::optional< ClusterType > ClusterOptional;
    typedef ::xsd::cxx::tree::traits< ClusterType, char > ClusterTraits;

    const ClusterOptional&
    getCluster () const;

    ClusterOptional&
    getCluster ();

    void
    setCluster (const ClusterType& x);

    void
    setCluster (const ClusterOptional& x);

    void
    setCluster (::std::unique_ptr< ClusterType > p);

    // port
    //
    typedef ::poosl::T_inspect_port PortType;
    typedef ::xsd::cxx::tree::sequence< PortType > PortSequence;
    typedef PortSequence::iterator PortIterator;
    typedef PortSequence::const_iterator PortConstIterator;
    typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

    const PortSequence&
    getPort () const;

    PortSequence&
    getPort ();

    void
    setPort (const PortSequence& s);

    // Constructors.
    //
    T_inspect_instance ();

    T_inspect_instance (const NameType&,
                        const TypeType&,
                        const Process_pathType&);

    T_inspect_instance (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_inspect_instance (const T_inspect_instance& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_inspect_instance*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_instance&
    operator= (const T_inspect_instance& x);

    virtual 
    ~T_inspect_instance ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ::xsd::cxx::tree::one< TypeType > type_;
    ::xsd::cxx::tree::one< Process_pathType > process_path_;
    ClusterOptional cluster_;
    PortSequence port_;
  };

  class T_inspect_cluster: public ::xml_schema::Type
  {
    public:
    // channel
    //
    typedef ::poosl::Channel ChannelType;
    typedef ::xsd::cxx::tree::sequence< ChannelType > ChannelSequence;
    typedef ChannelSequence::iterator ChannelIterator;
    typedef ChannelSequence::const_iterator ChannelConstIterator;
    typedef ::xsd::cxx::tree::traits< ChannelType, char > ChannelTraits;

    const ChannelSequence&
    getChannel () const;

    ChannelSequence&
    getChannel ();

    void
    setChannel (const ChannelSequence& s);

    // instance
    //
    typedef ::poosl::T_inspect_instance InstanceType;
    typedef ::xsd::cxx::tree::sequence< InstanceType > InstanceSequence;
    typedef InstanceSequence::iterator InstanceIterator;
    typedef InstanceSequence::const_iterator InstanceConstIterator;
    typedef ::xsd::cxx::tree::traits< InstanceType, char > InstanceTraits;

    const InstanceSequence&
    getInstance () const;

    InstanceSequence&
    getInstance ();

    void
    setInstance (const InstanceSequence& s);

    // Constructors.
    //
    T_inspect_cluster ();

    T_inspect_cluster (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_inspect_cluster (const T_inspect_cluster& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_inspect_cluster*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_cluster&
    operator= (const T_inspect_cluster& x);

    virtual 
    ~T_inspect_cluster ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ChannelSequence channel_;
    InstanceSequence instance_;
  };

  class T_inspect_system: public ::xml_schema::Type
  {
    public:
    // channel
    //
    typedef ::poosl::Channel ChannelType;
    typedef ::xsd::cxx::tree::sequence< ChannelType > ChannelSequence;
    typedef ChannelSequence::iterator ChannelIterator;
    typedef ChannelSequence::const_iterator ChannelConstIterator;
    typedef ::xsd::cxx::tree::traits< ChannelType, char > ChannelTraits;

    const ChannelSequence&
    getChannel () const;

    ChannelSequence&
    getChannel ();

    void
    setChannel (const ChannelSequence& s);

    // instance
    //
    typedef ::poosl::T_inspect_instance InstanceType;
    typedef ::xsd::cxx::tree::sequence< InstanceType > InstanceSequence;
    typedef InstanceSequence::iterator InstanceIterator;
    typedef InstanceSequence::const_iterator InstanceConstIterator;
    typedef ::xsd::cxx::tree::traits< InstanceType, char > InstanceTraits;

    const InstanceSequence&
    getInstance () const;

    InstanceSequence&
    getInstance ();

    void
    setInstance (const InstanceSequence& s);

    // Constructors.
    //
    T_inspect_system ();

    T_inspect_system (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_inspect_system (const T_inspect_system& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual T_inspect_system*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_system&
    operator= (const T_inspect_system& x);

    virtual 
    ~T_inspect_system ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ChannelSequence channel_;
    InstanceSequence instance_;
  };

  class T_inspect_channel: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::xml_schema::String NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // is_root
    //
    typedef ::xml_schema::Boolean Is_rootType;
    typedef ::xsd::cxx::tree::traits< Is_rootType, char > Is_rootTraits;

    const Is_rootType&
    getIs_root () const;

    Is_rootType&
    getIs_root ();

    void
    setIs_root (const Is_rootType& x);

    // Constructors.
    //
    T_inspect_channel ();

    T_inspect_channel (const NameType&,
                       const Is_rootType&);

    T_inspect_channel (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_inspect_channel (const T_inspect_channel& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_inspect_channel*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_channel&
    operator= (const T_inspect_channel& x);

    virtual 
    ~T_inspect_channel ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ::xsd::cxx::tree::one< Is_rootType > is_root_;
  };

  class T_stackframe: public ::xml_schema::Type
  {
    public:
    // dataclass_handle
    //
    typedef ::xml_schema::Integer Dataclass_handleType;
    typedef ::xsd::cxx::tree::traits< Dataclass_handleType, char > Dataclass_handleTraits;

    const Dataclass_handleType&
    getDataclass_handle () const;

    Dataclass_handleType&
    getDataclass_handle ();

    void
    setDataclass_handle (const Dataclass_handleType& x);

    // dataclass_name
    //
    typedef ::poosl::T_class_name Dataclass_nameType;
    typedef ::xsd::cxx::tree::traits< Dataclass_nameType, char > Dataclass_nameTraits;

    const Dataclass_nameType&
    getDataclass_name () const;

    Dataclass_nameType&
    getDataclass_name ();

    void
    setDataclass_name (const Dataclass_nameType& x);

    void
    setDataclass_name (::std::unique_ptr< Dataclass_nameType > p);

    // method_name
    //
    typedef ::xml_schema::String Method_nameType;
    typedef ::xsd::cxx::tree::traits< Method_nameType, char > Method_nameTraits;

    const Method_nameType&
    getMethod_name () const;

    Method_nameType&
    getMethod_name ();

    void
    setMethod_name (const Method_nameType& x);

    void
    setMethod_name (::std::unique_ptr< Method_nameType > p);

    // local_variables
    //
    typedef ::poosl::T_var_list Local_variablesType;
    typedef ::xsd::cxx::tree::traits< Local_variablesType, char > Local_variablesTraits;

    const Local_variablesType&
    getLocal_variables () const;

    Local_variablesType&
    getLocal_variables ();

    void
    setLocal_variables (const Local_variablesType& x);

    void
    setLocal_variables (::std::unique_ptr< Local_variablesType > p);

    // downframe
    //
    typedef ::xml_schema::Integer DownframeType;
    typedef ::xsd::cxx::tree::traits< DownframeType, char > DownframeTraits;

    const DownframeType&
    getDownframe () const;

    DownframeType&
    getDownframe ();

    void
    setDownframe (const DownframeType& x);

    // upframe
    //
    typedef ::xml_schema::Integer UpframeType;
    typedef ::xsd::cxx::tree::traits< UpframeType, char > UpframeTraits;

    const UpframeType&
    getUpframe () const;

    UpframeType&
    getUpframe ();

    void
    setUpframe (const UpframeType& x);

    // Constructors.
    //
    T_stackframe ();

    T_stackframe (const Dataclass_handleType&,
                  const Dataclass_nameType&,
                  const Method_nameType&,
                  const Local_variablesType&,
                  const DownframeType&,
                  const UpframeType&);

    T_stackframe (const Dataclass_handleType&,
                  const Dataclass_nameType&,
                  const Method_nameType&,
                  ::std::unique_ptr< Local_variablesType >,
                  const DownframeType&,
                  const UpframeType&);

    T_stackframe (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    T_stackframe (const T_stackframe& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual T_stackframe*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_stackframe&
    operator= (const T_stackframe& x);

    virtual 
    ~T_stackframe ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Dataclass_handleType > dataclass_handle_;
    ::xsd::cxx::tree::one< Dataclass_nameType > dataclass_name_;
    ::xsd::cxx::tree::one< Method_nameType > method_name_;
    ::xsd::cxx::tree::one< Local_variablesType > local_variables_;
    ::xsd::cxx::tree::one< DownframeType > downframe_;
    ::xsd::cxx::tree::one< UpframeType > upframe_;
  };

  class T_inspect_variable_context: public ::xml_schema::Type
  {
    public:
    // variable
    //
    typedef ::poosl::T_variable VariableType;
    typedef ::xsd::cxx::tree::sequence< VariableType > VariableSequence;
    typedef VariableSequence::iterator VariableIterator;
    typedef VariableSequence::const_iterator VariableConstIterator;
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    const VariableSequence&
    getVariable () const;

    VariableSequence&
    getVariable ();

    void
    setVariable (const VariableSequence& s);

    // Constructors.
    //
    T_inspect_variable_context ();

    T_inspect_variable_context (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    T_inspect_variable_context (const T_inspect_variable_context& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual T_inspect_variable_context*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_variable_context&
    operator= (const T_inspect_variable_context& x);

    virtual 
    ~T_inspect_variable_context ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    VariableSequence variable_;
  };

  class T_inspect_variable: public ::xml_schema::Type
  {
    public:
    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // object
    //
    typedef ::xml_schema::Integer ObjectType;
    typedef ::xsd::cxx::tree::traits< ObjectType, char > ObjectTraits;

    const ObjectType&
    getObject () const;

    ObjectType&
    getObject ();

    void
    setObject (const ObjectType& x);

    // type
    //
    typedef ::poosl::T_class_name TypeType;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeType&
    getType () const;

    TypeType&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // literal
    //
    typedef ::xml_schema::String LiteralType;
    typedef ::xsd::cxx::tree::optional< LiteralType > LiteralOptional;
    typedef ::xsd::cxx::tree::traits< LiteralType, char > LiteralTraits;

    const LiteralOptional&
    getLiteral () const;

    LiteralOptional&
    getLiteral ();

    void
    setLiteral (const LiteralType& x);

    void
    setLiteral (const LiteralOptional& x);

    void
    setLiteral (::std::unique_ptr< LiteralType > p);

    // Constructors.
    //
    T_inspect_variable ();

    T_inspect_variable (const HandleType&,
                        const ObjectType&,
                        const TypeType&);

    T_inspect_variable (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_inspect_variable (const T_inspect_variable& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_inspect_variable*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_variable&
    operator= (const T_inspect_variable& x);

    virtual 
    ~T_inspect_variable ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HandleType > handle_;
    ::xsd::cxx::tree::one< ObjectType > object_;
    ::xsd::cxx::tree::one< TypeType > type_;
    LiteralOptional literal_;
  };

  class T_inspect_data: public ::xml_schema::Type
  {
    public:
    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // type
    //
    typedef ::poosl::T_class_name TypeType;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeType&
    getType () const;

    TypeType&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // literal
    //
    typedef ::xml_schema::String LiteralType;
    typedef ::xsd::cxx::tree::optional< LiteralType > LiteralOptional;
    typedef ::xsd::cxx::tree::traits< LiteralType, char > LiteralTraits;

    const LiteralOptional&
    getLiteral () const;

    LiteralOptional&
    getLiteral ();

    void
    setLiteral (const LiteralType& x);

    void
    setLiteral (const LiteralOptional& x);

    void
    setLiteral (::std::unique_ptr< LiteralType > p);

    // variables
    //
    typedef ::poosl::T_var_list VariablesType;
    typedef ::xsd::cxx::tree::optional< VariablesType > VariablesOptional;
    typedef ::xsd::cxx::tree::traits< VariablesType, char > VariablesTraits;

    const VariablesOptional&
    getVariables () const;

    VariablesOptional&
    getVariables ();

    void
    setVariables (const VariablesType& x);

    void
    setVariables (const VariablesOptional& x);

    void
    setVariables (::std::unique_ptr< VariablesType > p);

    // Constructors.
    //
    T_inspect_data ();

    T_inspect_data (const HandleType&,
                    const TypeType&);

    T_inspect_data (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_inspect_data (const T_inspect_data& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual T_inspect_data*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_data&
    operator= (const T_inspect_data& x);

    virtual 
    ~T_inspect_data ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HandleType > handle_;
    ::xsd::cxx::tree::one< TypeType > type_;
    LiteralOptional literal_;
    VariablesOptional variables_;
  };

  class T_inspect_transition: public ::xml_schema::Type
  {
    public:
    // transition
    //
    typedef ::poosl::T_transition TransitionType;
    typedef ::xsd::cxx::tree::traits< TransitionType, char > TransitionTraits;

    const TransitionType&
    getTransition () const;

    TransitionType&
    getTransition ();

    void
    setTransition (const TransitionType& x);

    void
    setTransition (::std::unique_ptr< TransitionType > p);

    // Constructors.
    //
    T_inspect_transition ();

    T_inspect_transition (const TransitionType&);

    T_inspect_transition (::std::unique_ptr< TransitionType >);

    T_inspect_transition (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    T_inspect_transition (const T_inspect_transition& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual T_inspect_transition*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_transition&
    operator= (const T_inspect_transition& x);

    virtual 
    ~T_inspect_transition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TransitionType > transition_;
  };

  class T_observe_response: public ::xml_schema::Type
  {
    public:
    // aspect
    //
    typedef ::poosl::Aspect AspectType;
    typedef ::xsd::cxx::tree::traits< AspectType, char > AspectTraits;

    const AspectType&
    getAspect () const;

    AspectType&
    getAspect ();

    void
    setAspect (const AspectType& x);

    void
    setAspect (::std::unique_ptr< AspectType > p);

    // type
    //
    typedef ::poosl::T_instance_type TypeType;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeType&
    getType () const;

    TypeType&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // Constructors.
    //
    T_observe_response ();

    T_observe_response (const AspectType&,
                        const TypeType&,
                        const HandleType&);

    T_observe_response (::std::unique_ptr< AspectType >,
                        const TypeType&,
                        const HandleType&);

    T_observe_response (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_observe_response (const T_observe_response& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_observe_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_observe_response&
    operator= (const T_observe_response& x);

    virtual 
    ~T_observe_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AspectType > aspect_;
    ::xsd::cxx::tree::one< TypeType > type_;
    ::xsd::cxx::tree::one< HandleType > handle_;
  };

  class T_execution_state_change_response: public ::xml_schema::Type
  {
    public:
    // breakpoints
    //
    typedef ::poosl::T_breakpoint BreakpointsType;
    typedef ::xsd::cxx::tree::optional< BreakpointsType > BreakpointsOptional;
    typedef ::xsd::cxx::tree::traits< BreakpointsType, char > BreakpointsTraits;

    const BreakpointsOptional&
    getBreakpoints () const;

    BreakpointsOptional&
    getBreakpoints ();

    void
    setBreakpoints (const BreakpointsType& x);

    void
    setBreakpoints (const BreakpointsOptional& x);

    void
    setBreakpoints (::std::unique_ptr< BreakpointsType > p);

    // error
    //
    typedef ::poosl::T_error_info ErrorType;
    typedef ::xsd::cxx::tree::optional< ErrorType > ErrorOptional;
    typedef ::xsd::cxx::tree::traits< ErrorType, char > ErrorTraits;

    const ErrorOptional&
    getError () const;

    ErrorOptional&
    getError ();

    void
    setError (const ErrorType& x);

    void
    setError (const ErrorOptional& x);

    void
    setError (::std::unique_ptr< ErrorType > p);

    // transition
    //
    typedef ::poosl::T_transition TransitionType;
    typedef ::xsd::cxx::tree::optional< TransitionType > TransitionOptional;
    typedef ::xsd::cxx::tree::traits< TransitionType, char > TransitionTraits;

    const TransitionOptional&
    getTransition () const;

    TransitionOptional&
    getTransition ();

    void
    setTransition (const TransitionType& x);

    void
    setTransition (const TransitionOptional& x);

    void
    setTransition (::std::unique_ptr< TransitionType > p);

    // message
    //
    typedef ::xml_schema::String MessageType;
    typedef ::xsd::cxx::tree::optional< MessageType > MessageOptional;
    typedef ::xsd::cxx::tree::traits< MessageType, char > MessageTraits;

    const MessageOptional&
    getMessage () const;

    MessageOptional&
    getMessage ();

    void
    setMessage (const MessageType& x);

    void
    setMessage (const MessageOptional& x);

    void
    setMessage (::std::unique_ptr< MessageType > p);

    // state
    //
    typedef ::xml_schema::String StateType;
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    const StateType&
    getState () const;

    StateType&
    getState ();

    void
    setState (const StateType& x);

    void
    setState (::std::unique_ptr< StateType > p);

    // time
    //
    typedef ::xml_schema::Decimal TimeType;
    typedef ::xsd::cxx::tree::traits< TimeType, char, ::xsd::cxx::tree::schema_type::decimal > TimeTraits;

    const TimeType&
    getTime () const;

    TimeType&
    getTime ();

    void
    setTime (const TimeType& x);

    // minimal_time_step
    //
    typedef ::xml_schema::Double Minimal_time_stepType;
    typedef ::xsd::cxx::tree::traits< Minimal_time_stepType, char, ::xsd::cxx::tree::schema_type::double_ > Minimal_time_stepTraits;

    const Minimal_time_stepType&
    getMinimal_time_step () const;

    Minimal_time_stepType&
    getMinimal_time_step ();

    void
    setMinimal_time_step (const Minimal_time_stepType& x);

    // Constructors.
    //
    T_execution_state_change_response ();

    T_execution_state_change_response (const StateType&,
                                       const TimeType&,
                                       const Minimal_time_stepType&);

    T_execution_state_change_response (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    T_execution_state_change_response (const T_execution_state_change_response& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

    virtual T_execution_state_change_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_execution_state_change_response&
    operator= (const T_execution_state_change_response& x);

    virtual 
    ~T_execution_state_change_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    BreakpointsOptional breakpoints_;
    ErrorOptional error_;
    TransitionOptional transition_;
    MessageOptional message_;
    ::xsd::cxx::tree::one< StateType > state_;
    ::xsd::cxx::tree::one< TimeType > time_;
    ::xsd::cxx::tree::one< Minimal_time_stepType > minimal_time_step_;
  };

  class T_eengine_event_setup_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::xml_schema::String ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // Constructors.
    //
    T_eengine_event_setup_response ();

    T_eengine_event_setup_response (const ResultType&);

    T_eengine_event_setup_response (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    T_eengine_event_setup_response (const T_eengine_event_setup_response& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    virtual T_eengine_event_setup_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_eengine_event_setup_response&
    operator= (const T_eengine_event_setup_response& x);

    virtual 
    ~T_eengine_event_setup_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
  };

  class T_communication_event: public ::xml_schema::Type
  {
    public:
    // simulation_time
    //
    typedef ::xml_schema::Decimal Simulation_timeType;
    typedef ::xsd::cxx::tree::traits< Simulation_timeType, char, ::xsd::cxx::tree::schema_type::decimal > Simulation_timeTraits;

    const Simulation_timeType&
    getSimulation_time () const;

    Simulation_timeType&
    getSimulation_time ();

    void
    setSimulation_time (const Simulation_timeType& x);

    // sender
    //
    typedef ::poosl::T_communcation_event_node SenderType;
    typedef ::xsd::cxx::tree::traits< SenderType, char > SenderTraits;

    const SenderType&
    getSender () const;

    SenderType&
    getSender ();

    void
    setSender (const SenderType& x);

    void
    setSender (::std::unique_ptr< SenderType > p);

    // receiver
    //
    typedef ::poosl::T_communcation_event_node ReceiverType;
    typedef ::xsd::cxx::tree::traits< ReceiverType, char > ReceiverTraits;

    const ReceiverType&
    getReceiver () const;

    ReceiverType&
    getReceiver ();

    void
    setReceiver (const ReceiverType& x);

    void
    setReceiver (::std::unique_ptr< ReceiverType > p);

    // message
    //
    typedef ::poosl::T_communication_event_message MessageType;
    typedef ::xsd::cxx::tree::traits< MessageType, char > MessageTraits;

    const MessageType&
    getMessage () const;

    MessageType&
    getMessage ();

    void
    setMessage (const MessageType& x);

    void
    setMessage (::std::unique_ptr< MessageType > p);

    // Constructors.
    //
    T_communication_event ();

    T_communication_event (const Simulation_timeType&,
                           const SenderType&,
                           const ReceiverType&,
                           const MessageType&);

    T_communication_event (const Simulation_timeType&,
                           ::std::unique_ptr< SenderType >,
                           ::std::unique_ptr< ReceiverType >,
                           ::std::unique_ptr< MessageType >);

    T_communication_event (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_communication_event (const T_communication_event& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual T_communication_event*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_communication_event&
    operator= (const T_communication_event& x);

    virtual 
    ~T_communication_event ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Simulation_timeType > simulation_time_;
    ::xsd::cxx::tree::one< SenderType > sender_;
    ::xsd::cxx::tree::one< ReceiverType > receiver_;
    ::xsd::cxx::tree::one< MessageType > message_;
  };

  class T_eengine_event_error_response: public ::xml_schema::Type
  {
    public:
    // error
    //
    typedef ::xml_schema::String ErrorType;
    typedef ::xsd::cxx::tree::traits< ErrorType, char > ErrorTraits;

    const ErrorType&
    getError () const;

    ErrorType&
    getError ();

    void
    setError (const ErrorType& x);

    void
    setError (::std::unique_ptr< ErrorType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleType&
    getStmt_handle () const;

    Stmt_handleType&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    // process_path
    //
    typedef ::xml_schema::String Process_pathType;
    typedef ::xsd::cxx::tree::traits< Process_pathType, char > Process_pathTraits;

    const Process_pathType&
    getProcess_path () const;

    Process_pathType&
    getProcess_path ();

    void
    setProcess_path (const Process_pathType& x);

    void
    setProcess_path (::std::unique_ptr< Process_pathType > p);

    // stacktrace
    //
    typedef ::poosl::T_error_stacktrace StacktraceType;
    typedef ::xsd::cxx::tree::traits< StacktraceType, char > StacktraceTraits;

    const StacktraceType&
    getStacktrace () const;

    StacktraceType&
    getStacktrace ();

    void
    setStacktrace (const StacktraceType& x);

    void
    setStacktrace (::std::unique_ptr< StacktraceType > p);

    // Constructors.
    //
    T_eengine_event_error_response ();

    T_eengine_event_error_response (const ErrorType&,
                                    const Stmt_handleType&,
                                    const Process_pathType&,
                                    const StacktraceType&);

    T_eengine_event_error_response (const ErrorType&,
                                    const Stmt_handleType&,
                                    const Process_pathType&,
                                    ::std::unique_ptr< StacktraceType >);

    T_eengine_event_error_response (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    T_eengine_event_error_response (const T_eengine_event_error_response& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

    virtual T_eengine_event_error_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_eengine_event_error_response&
    operator= (const T_eengine_event_error_response& x);

    virtual 
    ~T_eengine_event_error_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ErrorType > error_;
    ::xsd::cxx::tree::one< Stmt_handleType > stmt_handle_;
    ::xsd::cxx::tree::one< Process_pathType > process_path_;
    ::xsd::cxx::tree::one< StacktraceType > stacktrace_;
  };

  class T_communcation_event_node: public ::xml_schema::Type
  {
    public:
    // process_path
    //
    typedef ::xml_schema::String Process_pathType;
    typedef ::xsd::cxx::tree::traits< Process_pathType, char > Process_pathTraits;

    const Process_pathType&
    getProcess_path () const;

    Process_pathType&
    getProcess_path ();

    void
    setProcess_path (const Process_pathType& x);

    void
    setProcess_path (::std::unique_ptr< Process_pathType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Integer Stmt_handleType;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleType&
    getStmt_handle () const;

    Stmt_handleType&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    // port_name
    //
    typedef ::poosl::T_port_name Port_nameType;
    typedef ::xsd::cxx::tree::traits< Port_nameType, char > Port_nameTraits;

    const Port_nameType&
    getPort_name () const;

    Port_nameType&
    getPort_name ();

    void
    setPort_name (const Port_nameType& x);

    void
    setPort_name (::std::unique_ptr< Port_nameType > p);

    // Constructors.
    //
    T_communcation_event_node ();

    T_communcation_event_node (const Process_pathType&,
                               const Stmt_handleType&,
                               const Port_nameType&);

    T_communcation_event_node (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    T_communcation_event_node (const T_communcation_event_node& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual T_communcation_event_node*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_communcation_event_node&
    operator= (const T_communcation_event_node& x);

    virtual 
    ~T_communcation_event_node ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Process_pathType > process_path_;
    ::xsd::cxx::tree::one< Stmt_handleType > stmt_handle_;
    ::xsd::cxx::tree::one< Port_nameType > port_name_;
  };

  class T_error_stacktrace: public ::xml_schema::Type
  {
    public:
    // stackframe
    //
    typedef ::poosl::T_error_stackframe StackframeType;
    typedef ::xsd::cxx::tree::sequence< StackframeType > StackframeSequence;
    typedef StackframeSequence::iterator StackframeIterator;
    typedef StackframeSequence::const_iterator StackframeConstIterator;
    typedef ::xsd::cxx::tree::traits< StackframeType, char > StackframeTraits;

    const StackframeSequence&
    getStackframe () const;

    StackframeSequence&
    getStackframe ();

    void
    setStackframe (const StackframeSequence& s);

    // Constructors.
    //
    T_error_stacktrace ();

    T_error_stacktrace (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_error_stacktrace (const T_error_stacktrace& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_error_stacktrace*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_error_stacktrace&
    operator= (const T_error_stacktrace& x);

    virtual 
    ~T_error_stacktrace ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    StackframeSequence stackframe_;
  };

  class T_error_stackframe: public ::xml_schema::Type
  {
    public:
    // method
    //
    typedef ::xml_schema::String MethodType;
    typedef ::xsd::cxx::tree::traits< MethodType, char > MethodTraits;

    const MethodType&
    getMethod () const;

    MethodType&
    getMethod ();

    void
    setMethod (const MethodType& x);

    void
    setMethod (::std::unique_ptr< MethodType > p);

    // stmt_handle
    //
    typedef ::xml_schema::String Stmt_handleType;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleType&
    getStmt_handle () const;

    Stmt_handleType&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (::std::unique_ptr< Stmt_handleType > p);

    // variable_context_global
    //
    typedef ::poosl::T_var_list Variable_context_globalType;
    typedef ::xsd::cxx::tree::traits< Variable_context_globalType, char > Variable_context_globalTraits;

    const Variable_context_globalType&
    getVariable_context_global () const;

    Variable_context_globalType&
    getVariable_context_global ();

    void
    setVariable_context_global (const Variable_context_globalType& x);

    void
    setVariable_context_global (::std::unique_ptr< Variable_context_globalType > p);

    // variable_context_local
    //
    typedef ::poosl::T_var_list Variable_context_localType;
    typedef ::xsd::cxx::tree::traits< Variable_context_localType, char > Variable_context_localTraits;

    const Variable_context_localType&
    getVariable_context_local () const;

    Variable_context_localType&
    getVariable_context_local ();

    void
    setVariable_context_local (const Variable_context_localType& x);

    void
    setVariable_context_local (::std::unique_ptr< Variable_context_localType > p);

    // id
    //
    typedef ::xml_schema::Int IdType;
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdOptional&
    getId () const;

    IdOptional&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (const IdOptional& x);

    // Constructors.
    //
    T_error_stackframe ();

    T_error_stackframe (const MethodType&,
                        const Stmt_handleType&,
                        const Variable_context_globalType&,
                        const Variable_context_localType&);

    T_error_stackframe (const MethodType&,
                        const Stmt_handleType&,
                        ::std::unique_ptr< Variable_context_globalType >,
                        ::std::unique_ptr< Variable_context_localType >);

    T_error_stackframe (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_error_stackframe (const T_error_stackframe& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_error_stackframe*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_error_stackframe&
    operator= (const T_error_stackframe& x);

    virtual 
    ~T_error_stackframe ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MethodType > method_;
    ::xsd::cxx::tree::one< Stmt_handleType > stmt_handle_;
    ::xsd::cxx::tree::one< Variable_context_globalType > variable_context_global_;
    ::xsd::cxx::tree::one< Variable_context_localType > variable_context_local_;
    IdOptional id_;
  };

  class T_communication_event_message: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::poosl::T_identifier NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // parameters
    //
    typedef ::poosl::T_communication_event_parameter ParametersType;
    typedef ::xsd::cxx::tree::traits< ParametersType, char > ParametersTraits;

    const ParametersType&
    getParameters () const;

    ParametersType&
    getParameters ();

    void
    setParameters (const ParametersType& x);

    void
    setParameters (::std::unique_ptr< ParametersType > p);

    // Constructors.
    //
    T_communication_event_message ();

    T_communication_event_message (const NameType&,
                                   const ParametersType&);

    T_communication_event_message (const NameType&,
                                   ::std::unique_ptr< ParametersType >);

    T_communication_event_message (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    T_communication_event_message (const T_communication_event_message& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    virtual T_communication_event_message*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_communication_event_message&
    operator= (const T_communication_event_message& x);

    virtual 
    ~T_communication_event_message ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ::xsd::cxx::tree::one< ParametersType > parameters_;
  };

  class T_communication_event_parameter: public ::xml_schema::Type
  {
    public:
    // parameter
    //
    typedef ::poosl::Parameter ParameterType;
    typedef ::xsd::cxx::tree::sequence< ParameterType > ParameterSequence;
    typedef ParameterSequence::iterator ParameterIterator;
    typedef ParameterSequence::const_iterator ParameterConstIterator;
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    const ParameterSequence&
    getParameter () const;

    ParameterSequence&
    getParameter ();

    void
    setParameter (const ParameterSequence& s);

    // Constructors.
    //
    T_communication_event_parameter ();

    T_communication_event_parameter (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    T_communication_event_parameter (const T_communication_event_parameter& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    virtual T_communication_event_parameter*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_communication_event_parameter&
    operator= (const T_communication_event_parameter& x);

    virtual 
    ~T_communication_event_parameter ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ParameterSequence parameter_;
  };

  class T_breakpoint: public ::xml_schema::Type
  {
    public:
    // breakpoint
    //
    typedef ::poosl::T_breakpoint_info BreakpointType;
    typedef ::xsd::cxx::tree::sequence< BreakpointType > BreakpointSequence;
    typedef BreakpointSequence::iterator BreakpointIterator;
    typedef BreakpointSequence::const_iterator BreakpointConstIterator;
    typedef ::xsd::cxx::tree::traits< BreakpointType, char > BreakpointTraits;

    const BreakpointSequence&
    getBreakpoint () const;

    BreakpointSequence&
    getBreakpoint ();

    void
    setBreakpoint (const BreakpointSequence& s);

    // Constructors.
    //
    T_breakpoint ();

    T_breakpoint (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    T_breakpoint (const T_breakpoint& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual T_breakpoint*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_breakpoint&
    operator= (const T_breakpoint& x);

    virtual 
    ~T_breakpoint ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    BreakpointSequence breakpoint_;
  };

  class T_breakpoint_info: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::poosl::T_identifier NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // breakpoint_id
    //
    typedef ::xml_schema::Integer Breakpoint_idType;
    typedef ::xsd::cxx::tree::traits< Breakpoint_idType, char > Breakpoint_idTraits;

    const Breakpoint_idType&
    getBreakpoint_id () const;

    Breakpoint_idType&
    getBreakpoint_id ();

    void
    setBreakpoint_id (const Breakpoint_idType& x);

    // control_point
    //
    typedef ::xml_schema::Integer Control_pointType;
    typedef ::xsd::cxx::tree::traits< Control_pointType, char > Control_pointTraits;

    const Control_pointType&
    getControl_point () const;

    Control_pointType&
    getControl_point ();

    void
    setControl_point (const Control_pointType& x);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleType&
    getStmt_handle () const;

    Stmt_handleType&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    // is_active
    //
    typedef ::xml_schema::Boolean Is_activeType;
    typedef ::xsd::cxx::tree::traits< Is_activeType, char > Is_activeTraits;

    const Is_activeType&
    getIs_active () const;

    Is_activeType&
    getIs_active ();

    void
    setIs_active (const Is_activeType& x);

    // hit_count
    //
    typedef ::xml_schema::Int Hit_countType;
    typedef ::xsd::cxx::tree::traits< Hit_countType, char > Hit_countTraits;

    const Hit_countType&
    getHit_count () const;

    Hit_countType&
    getHit_count ();

    void
    setHit_count (const Hit_countType& x);

    // Constructors.
    //
    T_breakpoint_info ();

    T_breakpoint_info (const NameType&,
                       const Breakpoint_idType&,
                       const Control_pointType&,
                       const Stmt_handleType&,
                       const Is_activeType&,
                       const Hit_countType&);

    T_breakpoint_info (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_breakpoint_info (const T_breakpoint_info& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_breakpoint_info*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_breakpoint_info&
    operator= (const T_breakpoint_info& x);

    virtual 
    ~T_breakpoint_info ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ::xsd::cxx::tree::one< Breakpoint_idType > breakpoint_id_;
    ::xsd::cxx::tree::one< Control_pointType > control_point_;
    ::xsd::cxx::tree::one< Stmt_handleType > stmt_handle_;
    ::xsd::cxx::tree::one< Is_activeType > is_active_;
    ::xsd::cxx::tree::one< Hit_countType > hit_count_;
  };

  class T_error_info: public ::xml_schema::Type
  {
    public:
    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleType&
    getStmt_handle () const;

    Stmt_handleType&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    // message
    //
    typedef ::xml_schema::String MessageType;
    typedef ::xsd::cxx::tree::traits< MessageType, char > MessageTraits;

    const MessageType&
    getMessage () const;

    MessageType&
    getMessage ();

    void
    setMessage (const MessageType& x);

    void
    setMessage (::std::unique_ptr< MessageType > p);

    // process_path
    //
    typedef ::xml_schema::String Process_pathType;
    typedef ::xsd::cxx::tree::optional< Process_pathType > Process_pathOptional;
    typedef ::xsd::cxx::tree::traits< Process_pathType, char > Process_pathTraits;

    const Process_pathOptional&
    getProcess_path () const;

    Process_pathOptional&
    getProcess_path ();

    void
    setProcess_path (const Process_pathType& x);

    void
    setProcess_path (const Process_pathOptional& x);

    void
    setProcess_path (::std::unique_ptr< Process_pathType > p);

    // node
    //
    typedef ::xml_schema::Int NodeType;
    typedef ::xsd::cxx::tree::traits< NodeType, char > NodeTraits;

    const NodeType&
    getNode () const;

    NodeType&
    getNode ();

    void
    setNode (const NodeType& x);

    // Constructors.
    //
    T_error_info ();

    T_error_info (const Stmt_handleType&,
                  const MessageType&,
                  const NodeType&);

    T_error_info (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    T_error_info (const T_error_info& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual T_error_info*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_error_info&
    operator= (const T_error_info& x);

    virtual 
    ~T_error_info ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Stmt_handleType > stmt_handle_;
    ::xsd::cxx::tree::one< MessageType > message_;
    Process_pathOptional process_path_;
    ::xsd::cxx::tree::one< NodeType > node_;
  };

  class T_create_breakpoint_response: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::poosl::T_identifier NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // breakpoint_id
    //
    typedef ::xml_schema::Integer Breakpoint_idType;
    typedef ::xsd::cxx::tree::traits< Breakpoint_idType, char > Breakpoint_idTraits;

    const Breakpoint_idType&
    getBreakpoint_id () const;

    Breakpoint_idType&
    getBreakpoint_id ();

    void
    setBreakpoint_id (const Breakpoint_idType& x);

    // result
    //
    typedef ::xml_schema::String ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // control_point
    //
    typedef ::xml_schema::Integer Control_pointType;
    typedef ::xsd::cxx::tree::traits< Control_pointType, char > Control_pointTraits;

    const Control_pointType&
    getControl_point () const;

    Control_pointType&
    getControl_point ();

    void
    setControl_point (const Control_pointType& x);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleType&
    getStmt_handle () const;

    Stmt_handleType&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    // position
    //
    typedef ::poosl::T_source_position PositionType;
    typedef ::xsd::cxx::tree::optional< PositionType > PositionOptional;
    typedef ::xsd::cxx::tree::traits< PositionType, char > PositionTraits;

    const PositionOptional&
    getPosition () const;

    PositionOptional&
    getPosition ();

    void
    setPosition (const PositionType& x);

    void
    setPosition (const PositionOptional& x);

    void
    setPosition (::std::unique_ptr< PositionType > p);

    // Constructors.
    //
    T_create_breakpoint_response ();

    T_create_breakpoint_response (const NameType&,
                                  const Breakpoint_idType&,
                                  const ResultType&,
                                  const Control_pointType&,
                                  const Stmt_handleType&);

    T_create_breakpoint_response (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    T_create_breakpoint_response (const T_create_breakpoint_response& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    virtual T_create_breakpoint_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_create_breakpoint_response&
    operator= (const T_create_breakpoint_response& x);

    virtual 
    ~T_create_breakpoint_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ::xsd::cxx::tree::one< Breakpoint_idType > breakpoint_id_;
    ::xsd::cxx::tree::one< ResultType > result_;
    ::xsd::cxx::tree::one< Control_pointType > control_point_;
    ::xsd::cxx::tree::one< Stmt_handleType > stmt_handle_;
    PositionOptional position_;
  };

  class T_create_breakpoint_response_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      ok,
      breakpoint_already_exists
    };

    T_create_breakpoint_response_result ();

    T_create_breakpoint_response_result (Value v);

    T_create_breakpoint_response_result (const char* v);

    T_create_breakpoint_response_result (const ::std::string& v);

    T_create_breakpoint_response_result (const ::xml_schema::String& v);

    T_create_breakpoint_response_result (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    T_create_breakpoint_response_result (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    T_create_breakpoint_response_result (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    T_create_breakpoint_response_result (const T_create_breakpoint_response_result& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    virtual T_create_breakpoint_response_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_create_breakpoint_response_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_create_breakpoint_response_result_convert ();
    }

    protected:
    Value
    _xsd_T_create_breakpoint_response_result_convert () const;

    public:
    static const char* const _xsd_T_create_breakpoint_response_result_literals_[2];
    static const Value _xsd_T_create_breakpoint_response_result_indexes_[2];
  };

  class T_set_breakpoint_condition_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_set_breakpoint_condition_response_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // error
    //
    typedef ::xml_schema::String ErrorType;
    typedef ::xsd::cxx::tree::traits< ErrorType, char > ErrorTraits;

    const ErrorType&
    getError () const;

    ErrorType&
    getError ();

    void
    setError (const ErrorType& x);

    void
    setError (::std::unique_ptr< ErrorType > p);

    // Constructors.
    //
    T_set_breakpoint_condition_response ();

    T_set_breakpoint_condition_response (const ResultType&,
                                         const ErrorType&);

    T_set_breakpoint_condition_response (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    T_set_breakpoint_condition_response (const T_set_breakpoint_condition_response& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    virtual T_set_breakpoint_condition_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_set_breakpoint_condition_response&
    operator= (const T_set_breakpoint_condition_response& x);

    virtual 
    ~T_set_breakpoint_condition_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
    ::xsd::cxx::tree::one< ErrorType > error_;
  };

  class T_set_breakpoint_condition_response_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      ok,
      error
    };

    T_set_breakpoint_condition_response_result ();

    T_set_breakpoint_condition_response_result (Value v);

    T_set_breakpoint_condition_response_result (const char* v);

    T_set_breakpoint_condition_response_result (const ::std::string& v);

    T_set_breakpoint_condition_response_result (const ::xml_schema::String& v);

    T_set_breakpoint_condition_response_result (const ::xercesc::DOMElement& e,
                                                ::xml_schema::Flags f = 0,
                                                ::xml_schema::Container* c = 0);

    T_set_breakpoint_condition_response_result (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::Flags f = 0,
                                                ::xml_schema::Container* c = 0);

    T_set_breakpoint_condition_response_result (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::Flags f = 0,
                                                ::xml_schema::Container* c = 0);

    T_set_breakpoint_condition_response_result (const T_set_breakpoint_condition_response_result& x,
                                                ::xml_schema::Flags f = 0,
                                                ::xml_schema::Container* c = 0);

    virtual T_set_breakpoint_condition_response_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_set_breakpoint_condition_response_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_set_breakpoint_condition_response_result_convert ();
    }

    protected:
    Value
    _xsd_T_set_breakpoint_condition_response_result_convert () const;

    public:
    static const char* const _xsd_T_set_breakpoint_condition_response_result_literals_[2];
    static const Value _xsd_T_set_breakpoint_condition_response_result_indexes_[2];
  };

  class T_enable_breakpoint_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::xml_schema::String ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // Constructors.
    //
    T_enable_breakpoint_response ();

    T_enable_breakpoint_response (const ResultType&);

    T_enable_breakpoint_response (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    T_enable_breakpoint_response (const T_enable_breakpoint_response& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    virtual T_enable_breakpoint_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_enable_breakpoint_response&
    operator= (const T_enable_breakpoint_response& x);

    virtual 
    ~T_enable_breakpoint_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
  };

  class T_disable_breakpoint_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::xml_schema::String ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // Constructors.
    //
    T_disable_breakpoint_response ();

    T_disable_breakpoint_response (const ResultType&);

    T_disable_breakpoint_response (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    T_disable_breakpoint_response (const T_disable_breakpoint_response& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    virtual T_disable_breakpoint_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_disable_breakpoint_response&
    operator= (const T_disable_breakpoint_response& x);

    virtual 
    ~T_disable_breakpoint_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
  };

  class T_delete_breakpoint_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::xml_schema::String ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // Constructors.
    //
    T_delete_breakpoint_response ();

    T_delete_breakpoint_response (const ResultType&);

    T_delete_breakpoint_response (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    T_delete_breakpoint_response (const T_delete_breakpoint_response& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    virtual T_delete_breakpoint_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_delete_breakpoint_response&
    operator= (const T_delete_breakpoint_response& x);

    virtual 
    ~T_delete_breakpoint_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
  };

  class T_breakpoint_result: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_breakpoint_result_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // Constructors.
    //
    T_breakpoint_result ();

    T_breakpoint_result (const ResultType&);

    T_breakpoint_result (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    T_breakpoint_result (const T_breakpoint_result& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual T_breakpoint_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_breakpoint_result&
    operator= (const T_breakpoint_result& x);

    virtual 
    ~T_breakpoint_result ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
  };

  class T_breakpoint_result_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      ok,
      invalid_breakpoint
    };

    T_breakpoint_result_result ();

    T_breakpoint_result_result (Value v);

    T_breakpoint_result_result (const char* v);

    T_breakpoint_result_result (const ::std::string& v);

    T_breakpoint_result_result (const ::xml_schema::String& v);

    T_breakpoint_result_result (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    T_breakpoint_result_result (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    T_breakpoint_result_result (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    T_breakpoint_result_result (const T_breakpoint_result_result& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual T_breakpoint_result_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_breakpoint_result_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_breakpoint_result_result_convert ();
    }

    protected:
    Value
    _xsd_T_breakpoint_result_result_convert () const;

    public:
    static const char* const _xsd_T_breakpoint_result_result_literals_[2];
    static const Value _xsd_T_breakpoint_result_result_indexes_[2];
  };

  class T_var_list: public ::xml_schema::Type
  {
    public:
    // variable
    //
    typedef ::poosl::T_variable VariableType;
    typedef ::xsd::cxx::tree::sequence< VariableType > VariableSequence;
    typedef VariableSequence::iterator VariableIterator;
    typedef VariableSequence::const_iterator VariableConstIterator;
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    const VariableSequence&
    getVariable () const;

    VariableSequence&
    getVariable ();

    void
    setVariable (const VariableSequence& s);

    // Constructors.
    //
    T_var_list ();

    T_var_list (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    T_var_list (const T_var_list& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual T_var_list*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_var_list&
    operator= (const T_var_list& x);

    virtual 
    ~T_var_list ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    VariableSequence variable_;
  };

  class T_variable: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::poosl::T_identifier NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // class
    //
    typedef ::poosl::T_class_name ClassType;
    typedef ::xsd::cxx::tree::optional< ClassType > ClassOptional;
    typedef ::xsd::cxx::tree::traits< ClassType, char > ClassTraits;

    const ClassOptional&
    getClass () const;

    ClassOptional&
    getClass ();

    void
    setClass (const ClassType& x);

    void
    setClass (const ClassOptional& x);

    void
    setClass (::std::unique_ptr< ClassType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // type
    //
    typedef ::xml_schema::String TypeType;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeType&
    getType () const;

    TypeType&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // literal
    //
    typedef ::xml_schema::String LiteralType;
    typedef ::xsd::cxx::tree::traits< LiteralType, char > LiteralTraits;

    const LiteralType&
    getLiteral () const;

    LiteralType&
    getLiteral ();

    void
    setLiteral (const LiteralType& x);

    void
    setLiteral (::std::unique_ptr< LiteralType > p);

    // object
    //
    typedef ::xml_schema::Integer ObjectType;
    typedef ::xsd::cxx::tree::traits< ObjectType, char > ObjectTraits;

    const ObjectType&
    getObject () const;

    ObjectType&
    getObject ();

    void
    setObject (const ObjectType& x);

    // Constructors.
    //
    T_variable ();

    T_variable (const NameType&,
                const HandleType&,
                const TypeType&,
                const LiteralType&,
                const ObjectType&);

    T_variable (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    T_variable (const T_variable& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual T_variable*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_variable&
    operator= (const T_variable& x);

    virtual 
    ~T_variable ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ClassOptional class__;
    ::xsd::cxx::tree::one< HandleType > handle_;
    ::xsd::cxx::tree::one< TypeType > type_;
    ::xsd::cxx::tree::one< LiteralType > literal_;
    ::xsd::cxx::tree::one< ObjectType > object_;
  };

  class T_method_list: public ::xml_schema::Type
  {
    public:
    // method
    //
    typedef ::poosl::T_method MethodType;
    typedef ::xsd::cxx::tree::sequence< MethodType > MethodSequence;
    typedef MethodSequence::iterator MethodIterator;
    typedef MethodSequence::const_iterator MethodConstIterator;
    typedef ::xsd::cxx::tree::traits< MethodType, char > MethodTraits;

    const MethodSequence&
    getMethod () const;

    MethodSequence&
    getMethod ();

    void
    setMethod (const MethodSequence& s);

    // Constructors.
    //
    T_method_list ();

    T_method_list (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    T_method_list (const T_method_list& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual T_method_list*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_method_list&
    operator= (const T_method_list& x);

    virtual 
    ~T_method_list ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MethodSequence method_;
  };

  class T_method: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::poosl::T_method_name NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // Constructors.
    //
    T_method ();

    T_method (const NameType&,
              const HandleType&);

    T_method (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    T_method (const T_method& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual T_method*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_method&
    operator= (const T_method& x);

    virtual 
    ~T_method ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ::xsd::cxx::tree::one< HandleType > handle_;
  };

  class T_executiontree: public ::xml_schema::Type
  {
    public:
    // sequential
    //
    typedef ::poosl::T_executiontree_statements SequentialType;
    typedef ::xsd::cxx::tree::sequence< SequentialType > SequentialSequence;
    typedef SequentialSequence::iterator SequentialIterator;
    typedef SequentialSequence::const_iterator SequentialConstIterator;
    typedef ::xsd::cxx::tree::traits< SequentialType, char > SequentialTraits;

    const SequentialSequence&
    getSequential () const;

    SequentialSequence&
    getSequential ();

    void
    setSequential (const SequentialSequence& s);

    // method_call
    //
    typedef ::poosl::T_executiontree_method_call Method_callType;
    typedef ::xsd::cxx::tree::sequence< Method_callType > Method_callSequence;
    typedef Method_callSequence::iterator Method_callIterator;
    typedef Method_callSequence::const_iterator Method_callConstIterator;
    typedef ::xsd::cxx::tree::traits< Method_callType, char > Method_callTraits;

    const Method_callSequence&
    getMethod_call () const;

    Method_callSequence&
    getMethod_call ();

    void
    setMethod_call (const Method_callSequence& s);

    // parallel
    //
    typedef ::poosl::T_executiontree_statements ParallelType;
    typedef ::xsd::cxx::tree::sequence< ParallelType > ParallelSequence;
    typedef ParallelSequence::iterator ParallelIterator;
    typedef ParallelSequence::const_iterator ParallelConstIterator;
    typedef ::xsd::cxx::tree::traits< ParallelType, char > ParallelTraits;

    const ParallelSequence&
    getParallel () const;

    ParallelSequence&
    getParallel ();

    void
    setParallel (const ParallelSequence& s);

    // select
    //
    typedef ::poosl::T_executiontree_statements SelectType;
    typedef ::xsd::cxx::tree::sequence< SelectType > SelectSequence;
    typedef SelectSequence::iterator SelectIterator;
    typedef SelectSequence::const_iterator SelectConstIterator;
    typedef ::xsd::cxx::tree::traits< SelectType, char > SelectTraits;

    const SelectSequence&
    getSelect () const;

    SelectSequence&
    getSelect ();

    void
    setSelect (const SelectSequence& s);

    // statement
    //
    typedef ::poosl::T_executiontree_base StatementType;
    typedef ::xsd::cxx::tree::sequence< StatementType > StatementSequence;
    typedef StatementSequence::iterator StatementIterator;
    typedef StatementSequence::const_iterator StatementConstIterator;
    typedef ::xsd::cxx::tree::traits< StatementType, char > StatementTraits;

    const StatementSequence&
    getStatement () const;

    StatementSequence&
    getStatement ();

    void
    setStatement (const StatementSequence& s);

    // expression
    //
    typedef ::poosl::T_executiontree_expression ExpressionType;
    typedef ::xsd::cxx::tree::sequence< ExpressionType > ExpressionSequence;
    typedef ExpressionSequence::iterator ExpressionIterator;
    typedef ExpressionSequence::const_iterator ExpressionConstIterator;
    typedef ::xsd::cxx::tree::traits< ExpressionType, char > ExpressionTraits;

    const ExpressionSequence&
    getExpression () const;

    ExpressionSequence&
    getExpression ();

    void
    setExpression (const ExpressionSequence& s);

    // process_method_call
    //
    typedef ::poosl::T_executiontree_base Process_method_callType;
    typedef ::xsd::cxx::tree::sequence< Process_method_callType > Process_method_callSequence;
    typedef Process_method_callSequence::iterator Process_method_callIterator;
    typedef Process_method_callSequence::const_iterator Process_method_callConstIterator;
    typedef ::xsd::cxx::tree::traits< Process_method_callType, char > Process_method_callTraits;

    const Process_method_callSequence&
    getProcess_method_call () const;

    Process_method_callSequence&
    getProcess_method_call ();

    void
    setProcess_method_call (const Process_method_callSequence& s);

    // message_send
    //
    typedef ::poosl::T_executiontree_base Message_sendType;
    typedef ::xsd::cxx::tree::sequence< Message_sendType > Message_sendSequence;
    typedef Message_sendSequence::iterator Message_sendIterator;
    typedef Message_sendSequence::const_iterator Message_sendConstIterator;
    typedef ::xsd::cxx::tree::traits< Message_sendType, char > Message_sendTraits;

    const Message_sendSequence&
    getMessage_send () const;

    Message_sendSequence&
    getMessage_send ();

    void
    setMessage_send (const Message_sendSequence& s);

    // message_receive
    //
    typedef ::poosl::T_executiontree_message_receive Message_receiveType;
    typedef ::xsd::cxx::tree::sequence< Message_receiveType > Message_receiveSequence;
    typedef Message_receiveSequence::iterator Message_receiveIterator;
    typedef Message_receiveSequence::const_iterator Message_receiveConstIterator;
    typedef ::xsd::cxx::tree::traits< Message_receiveType, char > Message_receiveTraits;

    const Message_receiveSequence&
    getMessage_receive () const;

    Message_receiveSequence&
    getMessage_receive ();

    void
    setMessage_receive (const Message_receiveSequence& s);

    // guard
    //
    typedef ::poosl::T_executiontree_base GuardType;
    typedef ::xsd::cxx::tree::sequence< GuardType > GuardSequence;
    typedef GuardSequence::iterator GuardIterator;
    typedef GuardSequence::const_iterator GuardConstIterator;
    typedef ::xsd::cxx::tree::traits< GuardType, char > GuardTraits;

    const GuardSequence&
    getGuard () const;

    GuardSequence&
    getGuard ();

    void
    setGuard (const GuardSequence& s);

    // while
    //
    typedef ::poosl::T_executiontree_base WhileType;
    typedef ::xsd::cxx::tree::sequence< WhileType > WhileSequence;
    typedef WhileSequence::iterator WhileIterator;
    typedef WhileSequence::const_iterator WhileConstIterator;
    typedef ::xsd::cxx::tree::traits< WhileType, char > WhileTraits;

    const WhileSequence&
    getWhile () const;

    WhileSequence&
    getWhile ();

    void
    setWhile (const WhileSequence& s);

    // abort
    //
    typedef ::poosl::T_executiontree_base AbortType;
    typedef ::xsd::cxx::tree::sequence< AbortType > AbortSequence;
    typedef AbortSequence::iterator AbortIterator;
    typedef AbortSequence::const_iterator AbortConstIterator;
    typedef ::xsd::cxx::tree::traits< AbortType, char > AbortTraits;

    const AbortSequence&
    getAbort () const;

    AbortSequence&
    getAbort ();

    void
    setAbort (const AbortSequence& s);

    // interrupt
    //
    typedef ::poosl::T_executiontree_base InterruptType;
    typedef ::xsd::cxx::tree::sequence< InterruptType > InterruptSequence;
    typedef InterruptSequence::iterator InterruptIterator;
    typedef InterruptSequence::const_iterator InterruptConstIterator;
    typedef ::xsd::cxx::tree::traits< InterruptType, char > InterruptTraits;

    const InterruptSequence&
    getInterrupt () const;

    InterruptSequence&
    getInterrupt ();

    void
    setInterrupt (const InterruptSequence& s);

    // skip
    //
    typedef ::poosl::T_executiontree_base SkipType;
    typedef ::xsd::cxx::tree::sequence< SkipType > SkipSequence;
    typedef SkipSequence::iterator SkipIterator;
    typedef SkipSequence::const_iterator SkipConstIterator;
    typedef ::xsd::cxx::tree::traits< SkipType, char > SkipTraits;

    const SkipSequence&
    getSkip () const;

    SkipSequence&
    getSkip ();

    void
    setSkip (const SkipSequence& s);

    // delay
    //
    typedef ::poosl::T_executiontree_base DelayType;
    typedef ::xsd::cxx::tree::sequence< DelayType > DelaySequence;
    typedef DelaySequence::iterator DelayIterator;
    typedef DelaySequence::const_iterator DelayConstIterator;
    typedef ::xsd::cxx::tree::traits< DelayType, char > DelayTraits;

    const DelaySequence&
    getDelay () const;

    DelaySequence&
    getDelay ();

    void
    setDelay (const DelaySequence& s);

    // sequence_of_expressions
    //
    typedef ::poosl::T_executiontree_base Sequence_of_expressionsType;
    typedef ::xsd::cxx::tree::sequence< Sequence_of_expressionsType > Sequence_of_expressionsSequence;
    typedef Sequence_of_expressionsSequence::iterator Sequence_of_expressionsIterator;
    typedef Sequence_of_expressionsSequence::const_iterator Sequence_of_expressionsConstIterator;
    typedef ::xsd::cxx::tree::traits< Sequence_of_expressionsType, char > Sequence_of_expressionsTraits;

    const Sequence_of_expressionsSequence&
    getSequence_of_expressions () const;

    Sequence_of_expressionsSequence&
    getSequence_of_expressions ();

    void
    setSequence_of_expressions (const Sequence_of_expressionsSequence& s);

    // assignment
    //
    typedef ::poosl::T_executiontree_base AssignmentType;
    typedef ::xsd::cxx::tree::sequence< AssignmentType > AssignmentSequence;
    typedef AssignmentSequence::iterator AssignmentIterator;
    typedef AssignmentSequence::const_iterator AssignmentConstIterator;
    typedef ::xsd::cxx::tree::traits< AssignmentType, char > AssignmentTraits;

    const AssignmentSequence&
    getAssignment () const;

    AssignmentSequence&
    getAssignment ();

    void
    setAssignment (const AssignmentSequence& s);

    // data_method_call
    //
    typedef ::poosl::T_executiontree_base Data_method_callType;
    typedef ::xsd::cxx::tree::sequence< Data_method_callType > Data_method_callSequence;
    typedef Data_method_callSequence::iterator Data_method_callIterator;
    typedef Data_method_callSequence::const_iterator Data_method_callConstIterator;
    typedef ::xsd::cxx::tree::traits< Data_method_callType, char > Data_method_callTraits;

    const Data_method_callSequence&
    getData_method_call () const;

    Data_method_callSequence&
    getData_method_call ();

    void
    setData_method_call (const Data_method_callSequence& s);

    // constant
    //
    typedef ::poosl::T_executiontree_base ConstantType;
    typedef ::xsd::cxx::tree::sequence< ConstantType > ConstantSequence;
    typedef ConstantSequence::iterator ConstantIterator;
    typedef ConstantSequence::const_iterator ConstantConstIterator;
    typedef ::xsd::cxx::tree::traits< ConstantType, char > ConstantTraits;

    const ConstantSequence&
    getConstant () const;

    ConstantSequence&
    getConstant ();

    void
    setConstant (const ConstantSequence& s);

    // variable
    //
    typedef ::poosl::T_executiontree_base VariableType;
    typedef ::xsd::cxx::tree::sequence< VariableType > VariableSequence;
    typedef VariableSequence::iterator VariableIterator;
    typedef VariableSequence::const_iterator VariableConstIterator;
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    const VariableSequence&
    getVariable () const;

    VariableSequence&
    getVariable ();

    void
    setVariable (const VariableSequence& s);

    // binary_operation
    //
    typedef ::poosl::T_executiontree_base Binary_operationType;
    typedef ::xsd::cxx::tree::sequence< Binary_operationType > Binary_operationSequence;
    typedef Binary_operationSequence::iterator Binary_operationIterator;
    typedef Binary_operationSequence::const_iterator Binary_operationConstIterator;
    typedef ::xsd::cxx::tree::traits< Binary_operationType, char > Binary_operationTraits;

    const Binary_operationSequence&
    getBinary_operation () const;

    Binary_operationSequence&
    getBinary_operation ();

    void
    setBinary_operation (const Binary_operationSequence& s);

    // unary_operation
    //
    typedef ::poosl::T_executiontree_base Unary_operationType;
    typedef ::xsd::cxx::tree::sequence< Unary_operationType > Unary_operationSequence;
    typedef Unary_operationSequence::iterator Unary_operationIterator;
    typedef Unary_operationSequence::const_iterator Unary_operationConstIterator;
    typedef ::xsd::cxx::tree::traits< Unary_operationType, char > Unary_operationTraits;

    const Unary_operationSequence&
    getUnary_operation () const;

    Unary_operationSequence&
    getUnary_operation ();

    void
    setUnary_operation (const Unary_operationSequence& s);

    // self
    //
    typedef ::poosl::T_executiontree_base SelfType;
    typedef ::xsd::cxx::tree::sequence< SelfType > SelfSequence;
    typedef SelfSequence::iterator SelfIterator;
    typedef SelfSequence::const_iterator SelfConstIterator;
    typedef ::xsd::cxx::tree::traits< SelfType, char > SelfTraits;

    const SelfSequence&
    getSelf () const;

    SelfSequence&
    getSelf ();

    void
    setSelf (const SelfSequence& s);

    // nil
    //
    typedef ::poosl::T_executiontree_base NilType;
    typedef ::xsd::cxx::tree::sequence< NilType > NilSequence;
    typedef NilSequence::iterator NilIterator;
    typedef NilSequence::const_iterator NilConstIterator;
    typedef ::xsd::cxx::tree::traits< NilType, char > NilTraits;

    const NilSequence&
    getNil () const;

    NilSequence&
    getNil ();

    void
    setNil (const NilSequence& s);

    // current_time
    //
    typedef ::poosl::T_executiontree_base Current_timeType;
    typedef ::xsd::cxx::tree::sequence< Current_timeType > Current_timeSequence;
    typedef Current_timeSequence::iterator Current_timeIterator;
    typedef Current_timeSequence::const_iterator Current_timeConstIterator;
    typedef ::xsd::cxx::tree::traits< Current_timeType, char > Current_timeTraits;

    const Current_timeSequence&
    getCurrent_time () const;

    Current_timeSequence&
    getCurrent_time ();

    void
    setCurrent_time (const Current_timeSequence& s);

    // if
    //
    typedef ::poosl::T_executiontree_base IfType;
    typedef ::xsd::cxx::tree::sequence< IfType > IfSequence;
    typedef IfSequence::iterator IfIterator;
    typedef IfSequence::const_iterator IfConstIterator;
    typedef ::xsd::cxx::tree::traits< IfType, char > IfTraits;

    const IfSequence&
    getIf () const;

    IfSequence&
    getIf ();

    void
    setIf (const IfSequence& s);

    // switch
    //
    typedef ::poosl::T_executiontree_base SwitchType;
    typedef ::xsd::cxx::tree::sequence< SwitchType > SwitchSequence;
    typedef SwitchSequence::iterator SwitchIterator;
    typedef SwitchSequence::const_iterator SwitchConstIterator;
    typedef ::xsd::cxx::tree::traits< SwitchType, char > SwitchTraits;

    const SwitchSequence&
    getSwitch () const;

    SwitchSequence&
    getSwitch ();

    void
    setSwitch (const SwitchSequence& s);

    // new
    //
    typedef ::poosl::T_executiontree_base NewType;
    typedef ::xsd::cxx::tree::sequence< NewType > NewSequence;
    typedef NewSequence::iterator NewIterator;
    typedef NewSequence::const_iterator NewConstIterator;
    typedef ::xsd::cxx::tree::traits< NewType, char > NewTraits;

    const NewSequence&
    getNew () const;

    NewSequence&
    getNew ();

    void
    setNew (const NewSequence& s);

    // return
    //
    typedef ::poosl::T_executiontree_base ReturnType;
    typedef ::xsd::cxx::tree::sequence< ReturnType > ReturnSequence;
    typedef ReturnSequence::iterator ReturnIterator;
    typedef ReturnSequence::const_iterator ReturnConstIterator;
    typedef ::xsd::cxx::tree::traits< ReturnType, char > ReturnTraits;

    const ReturnSequence&
    getReturn () const;

    ReturnSequence&
    getReturn ();

    void
    setReturn (const ReturnSequence& s);

    // execution_tree
    //
    typedef ::poosl::T_executiontree Execution_treeType;
    typedef ::xsd::cxx::tree::sequence< Execution_treeType > Execution_treeSequence;
    typedef Execution_treeSequence::iterator Execution_treeIterator;
    typedef Execution_treeSequence::const_iterator Execution_treeConstIterator;
    typedef ::xsd::cxx::tree::traits< Execution_treeType, char > Execution_treeTraits;

    const Execution_treeSequence&
    getExecution_tree () const;

    Execution_treeSequence&
    getExecution_tree ();

    void
    setExecution_tree (const Execution_treeSequence& s);

    // Constructors.
    //
    T_executiontree ();

    T_executiontree (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_executiontree (const T_executiontree& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual T_executiontree*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_executiontree&
    operator= (const T_executiontree& x);

    virtual 
    ~T_executiontree ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SequentialSequence sequential_;
    Method_callSequence method_call_;
    ParallelSequence parallel_;
    SelectSequence select_;
    StatementSequence statement_;
    ExpressionSequence expression_;
    Process_method_callSequence process_method_call_;
    Message_sendSequence message_send_;
    Message_receiveSequence message_receive_;
    GuardSequence guard_;
    WhileSequence while__;
    AbortSequence abort_;
    InterruptSequence interrupt_;
    SkipSequence skip_;
    DelaySequence delay_;
    Sequence_of_expressionsSequence sequence_of_expressions_;
    AssignmentSequence assignment_;
    Data_method_callSequence data_method_call_;
    ConstantSequence constant_;
    VariableSequence variable_;
    Binary_operationSequence binary_operation_;
    Unary_operationSequence unary_operation_;
    SelfSequence self_;
    NilSequence nil_;
    Current_timeSequence current_time_;
    IfSequence if__;
    SwitchSequence switch__;
    NewSequence new__;
    ReturnSequence return__;
    Execution_treeSequence execution_tree_;
  };

  class T_executiontree_base: public ::xml_schema::Type
  {
    public:
    // process
    //
    typedef ::xml_schema::Integer ProcessType;
    typedef ::xsd::cxx::tree::optional< ProcessType > ProcessOptional;
    typedef ::xsd::cxx::tree::traits< ProcessType, char > ProcessTraits;

    const ProcessOptional&
    getProcess () const;

    ProcessOptional&
    getProcess ();

    void
    setProcess (const ProcessType& x);

    void
    setProcess (const ProcessOptional& x);

    // parent
    //
    typedef ::xml_schema::Integer ParentType;
    typedef ::xsd::cxx::tree::optional< ParentType > ParentOptional;
    typedef ::xsd::cxx::tree::traits< ParentType, char > ParentTraits;

    const ParentOptional&
    getParent () const;

    ParentOptional&
    getParent ();

    void
    setParent (const ParentType& x);

    void
    setParent (const ParentOptional& x);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::optional< HandleType > HandleOptional;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleOptional&
    getHandle () const;

    HandleOptional&
    getHandle ();

    void
    setHandle (const HandleType& x);

    void
    setHandle (const HandleOptional& x);

    // global
    //
    typedef ::xml_schema::Integer GlobalType;
    typedef ::xsd::cxx::tree::optional< GlobalType > GlobalOptional;
    typedef ::xsd::cxx::tree::traits< GlobalType, char > GlobalTraits;

    const GlobalOptional&
    getGlobal () const;

    GlobalOptional&
    getGlobal ();

    void
    setGlobal (const GlobalType& x);

    void
    setGlobal (const GlobalOptional& x);

    // local
    //
    typedef ::xml_schema::Integer LocalType;
    typedef ::xsd::cxx::tree::optional< LocalType > LocalOptional;
    typedef ::xsd::cxx::tree::traits< LocalType, char > LocalTraits;

    const LocalOptional&
    getLocal () const;

    LocalOptional&
    getLocal ();

    void
    setLocal (const LocalType& x);

    void
    setLocal (const LocalOptional& x);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_executiontree_base ();

    T_executiontree_base (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    T_executiontree_base (const T_executiontree_base& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual T_executiontree_base*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_executiontree_base&
    operator= (const T_executiontree_base& x);

    virtual 
    ~T_executiontree_base ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ProcessOptional process_;
    ParentOptional parent_;
    HandleOptional handle_;
    GlobalOptional global_;
    LocalOptional local_;
    Stmt_handleOptional stmt_handle_;
  };

  class T_executiontree_statements: public ::poosl::T_executiontree_base
  {
    public:
    // statement
    //
    typedef ::xml_schema::Integer StatementType;
    typedef ::xsd::cxx::tree::sequence< StatementType > StatementSequence;
    typedef StatementSequence::iterator StatementIterator;
    typedef StatementSequence::const_iterator StatementConstIterator;
    typedef ::xsd::cxx::tree::traits< StatementType, char > StatementTraits;

    const StatementSequence&
    getStatement () const;

    StatementSequence&
    getStatement ();

    void
    setStatement (const StatementSequence& s);

    // Constructors.
    //
    T_executiontree_statements ();

    T_executiontree_statements (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    T_executiontree_statements (const T_executiontree_statements& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual T_executiontree_statements*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_executiontree_statements&
    operator= (const T_executiontree_statements& x);

    virtual 
    ~T_executiontree_statements ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    StatementSequence statement_;
  };

  class T_executiontree_method_call: public ::poosl::T_executiontree_base
  {
    public:
    // name
    //
    typedef ::poosl::T_identifier NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // state
    //
    typedef ::xml_schema::String StateType;
    typedef ::xsd::cxx::tree::optional< StateType > StateOptional;
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    const StateOptional&
    getState () const;

    StateOptional&
    getState ();

    void
    setState (const StateType& x);

    void
    setState (const StateOptional& x);

    void
    setState (::std::unique_ptr< StateType > p);

    // Constructors.
    //
    T_executiontree_method_call ();

    T_executiontree_method_call (const NameType&);

    T_executiontree_method_call (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    T_executiontree_method_call (const T_executiontree_method_call& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual T_executiontree_method_call*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_executiontree_method_call&
    operator= (const T_executiontree_method_call& x);

    virtual 
    ~T_executiontree_method_call ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    StateOptional state_;
  };

  class T_executiontree_message_receive: public ::poosl::T_executiontree_base
  {
    public:
    // port
    //
    typedef ::xml_schema::String PortType;
    typedef ::xsd::cxx::tree::optional< PortType > PortOptional;
    typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

    const PortOptional&
    getPort () const;

    PortOptional&
    getPort ();

    void
    setPort (const PortType& x);

    void
    setPort (const PortOptional& x);

    void
    setPort (::std::unique_ptr< PortType > p);

    // message
    //
    typedef ::xml_schema::String MessageType;
    typedef ::xsd::cxx::tree::optional< MessageType > MessageOptional;
    typedef ::xsd::cxx::tree::traits< MessageType, char > MessageTraits;

    const MessageOptional&
    getMessage () const;

    MessageOptional&
    getMessage ();

    void
    setMessage (const MessageType& x);

    void
    setMessage (const MessageOptional& x);

    void
    setMessage (::std::unique_ptr< MessageType > p);

    // parameter_count
    //
    typedef ::xml_schema::Integer Parameter_countType;
    typedef ::xsd::cxx::tree::optional< Parameter_countType > Parameter_countOptional;
    typedef ::xsd::cxx::tree::traits< Parameter_countType, char > Parameter_countTraits;

    const Parameter_countOptional&
    getParameter_count () const;

    Parameter_countOptional&
    getParameter_count ();

    void
    setParameter_count (const Parameter_countType& x);

    void
    setParameter_count (const Parameter_countOptional& x);

    // Constructors.
    //
    T_executiontree_message_receive ();

    T_executiontree_message_receive (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    T_executiontree_message_receive (const T_executiontree_message_receive& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

    virtual T_executiontree_message_receive*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_executiontree_message_receive&
    operator= (const T_executiontree_message_receive& x);

    virtual 
    ~T_executiontree_message_receive ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PortOptional port_;
    MessageOptional message_;
    Parameter_countOptional parameter_count_;
  };

  class T_executiontree_expression: public ::poosl::T_executiontree_base
  {
    public:
    // Constructors.
    //
    T_executiontree_expression ();

    T_executiontree_expression (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    T_executiontree_expression (const T_executiontree_expression& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual T_executiontree_expression*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_executiontree_expression ();
  };

  class T_cluster_instance_interface: public ::xml_schema::Type
  {
    public:
    // port
    //
    typedef ::poosl::T_cluster_instance_port PortType;
    typedef ::xsd::cxx::tree::sequence< PortType > PortSequence;
    typedef PortSequence::iterator PortIterator;
    typedef PortSequence::const_iterator PortConstIterator;
    typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

    const PortSequence&
    getPort () const;

    PortSequence&
    getPort ();

    void
    setPort (const PortSequence& s);

    // Constructors.
    //
    T_cluster_instance_interface ();

    T_cluster_instance_interface (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    T_cluster_instance_interface (const T_cluster_instance_interface& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    virtual T_cluster_instance_interface*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_cluster_instance_interface&
    operator= (const T_cluster_instance_interface& x);

    virtual 
    ~T_cluster_instance_interface ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PortSequence port_;
  };

  class T_cluster_instance_port: public ::xml_schema::Type
  {
    public:
    // graphics
    //
    typedef ::poosl::T_graphics_port GraphicsType;
    typedef ::xsd::cxx::tree::optional< GraphicsType > GraphicsOptional;
    typedef ::xsd::cxx::tree::traits< GraphicsType, char > GraphicsTraits;

    const GraphicsOptional&
    getGraphics () const;

    GraphicsOptional&
    getGraphics ();

    void
    setGraphics (const GraphicsType& x);

    void
    setGraphics (const GraphicsOptional& x);

    void
    setGraphics (::std::unique_ptr< GraphicsType > p);

    // name
    //
    typedef ::xml_schema::String NameType;
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameOptional&
    getName () const;

    NameOptional&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (const NameOptional& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // Constructors.
    //
    T_cluster_instance_port ();

    T_cluster_instance_port (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    T_cluster_instance_port (const T_cluster_instance_port& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual T_cluster_instance_port*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_cluster_instance_port&
    operator= (const T_cluster_instance_port& x);

    virtual 
    ~T_cluster_instance_port ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    GraphicsOptional graphics_;
    NameOptional name_;
  };

  class T_graphics_port: public ::xml_schema::Type
  {
    public:
    // location
    //
    typedef ::poosl::T_point LocationType;
    typedef ::xsd::cxx::tree::traits< LocationType, char > LocationTraits;

    const LocationType&
    getLocation () const;

    LocationType&
    getLocation ();

    void
    setLocation (const LocationType& x);

    void
    setLocation (::std::unique_ptr< LocationType > p);

    // name_location
    //
    typedef ::poosl::T_point Name_locationType;
    typedef ::xsd::cxx::tree::traits< Name_locationType, char > Name_locationTraits;

    const Name_locationType&
    getName_location () const;

    Name_locationType&
    getName_location ();

    void
    setName_location (const Name_locationType& x);

    void
    setName_location (::std::unique_ptr< Name_locationType > p);

    // Constructors.
    //
    T_graphics_port ();

    T_graphics_port (const LocationType&,
                     const Name_locationType&);

    T_graphics_port (::std::unique_ptr< LocationType >,
                     ::std::unique_ptr< Name_locationType >);

    T_graphics_port (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_graphics_port (const T_graphics_port& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual T_graphics_port*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_graphics_port&
    operator= (const T_graphics_port& x);

    virtual 
    ~T_graphics_port ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LocationType > location_;
    ::xsd::cxx::tree::one< Name_locationType > name_location_;
  };

  class T_graphics_channel: public ::xml_schema::Type
  {
    public:
    // node
    //
    typedef ::poosl::T_point NodeType;
    typedef ::xsd::cxx::tree::sequence< NodeType > NodeSequence;
    typedef NodeSequence::iterator NodeIterator;
    typedef NodeSequence::const_iterator NodeConstIterator;
    typedef ::xsd::cxx::tree::traits< NodeType, char > NodeTraits;

    const NodeSequence&
    getNode () const;

    NodeSequence&
    getNode ();

    void
    setNode (const NodeSequence& s);

    // segment
    //
    typedef ::poosl::T_channel_node SegmentType;
    typedef ::xsd::cxx::tree::sequence< SegmentType > SegmentSequence;
    typedef SegmentSequence::iterator SegmentIterator;
    typedef SegmentSequence::const_iterator SegmentConstIterator;
    typedef ::xsd::cxx::tree::traits< SegmentType, char > SegmentTraits;

    const SegmentSequence&
    getSegment () const;

    SegmentSequence&
    getSegment ();

    void
    setSegment (const SegmentSequence& s);

    // name_location
    //
    typedef ::poosl::T_point Name_locationType;
    typedef ::xsd::cxx::tree::traits< Name_locationType, char > Name_locationTraits;

    const Name_locationType&
    getName_location () const;

    Name_locationType&
    getName_location ();

    void
    setName_location (const Name_locationType& x);

    void
    setName_location (::std::unique_ptr< Name_locationType > p);

    // message_location
    //
    typedef ::poosl::T_message_location Message_locationType;
    typedef ::xsd::cxx::tree::traits< Message_locationType, char > Message_locationTraits;

    const Message_locationType&
    getMessage_location () const;

    Message_locationType&
    getMessage_location ();

    void
    setMessage_location (const Message_locationType& x);

    void
    setMessage_location (::std::unique_ptr< Message_locationType > p);

    // scenario
    //
    typedef ::poosl::T_scenario ScenarioType;
    typedef ::xsd::cxx::tree::sequence< ScenarioType > ScenarioSequence;
    typedef ScenarioSequence::iterator ScenarioIterator;
    typedef ScenarioSequence::const_iterator ScenarioConstIterator;
    typedef ::xsd::cxx::tree::traits< ScenarioType, char > ScenarioTraits;

    const ScenarioSequence&
    getScenario () const;

    ScenarioSequence&
    getScenario ();

    void
    setScenario (const ScenarioSequence& s);

    // Constructors.
    //
    T_graphics_channel ();

    T_graphics_channel (const Name_locationType&,
                        const Message_locationType&);

    T_graphics_channel (::std::unique_ptr< Name_locationType >,
                        ::std::unique_ptr< Message_locationType >);

    T_graphics_channel (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_graphics_channel (const T_graphics_channel& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_graphics_channel*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_graphics_channel&
    operator= (const T_graphics_channel& x);

    virtual 
    ~T_graphics_channel ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NodeSequence node_;
    SegmentSequence segment_;
    ::xsd::cxx::tree::one< Name_locationType > name_location_;
    ::xsd::cxx::tree::one< Message_locationType > message_location_;
    ScenarioSequence scenario_;
  };

  class T_channel_node: public ::xml_schema::Type
  {
    public:
    // node
    //
    typedef ::poosl::Node NodeType;
    typedef ::xsd::cxx::tree::sequence< NodeType > NodeSequence;
    typedef NodeSequence::iterator NodeIterator;
    typedef NodeSequence::const_iterator NodeConstIterator;
    typedef ::xsd::cxx::tree::traits< NodeType, char > NodeTraits;

    const NodeSequence&
    getNode () const;

    NodeSequence&
    getNode ();

    void
    setNode (const NodeSequence& s);

    // instance_port
    //
    typedef ::poosl::Instance_port Instance_portType;
    typedef ::xsd::cxx::tree::sequence< Instance_portType > Instance_portSequence;
    typedef Instance_portSequence::iterator Instance_portIterator;
    typedef Instance_portSequence::const_iterator Instance_portConstIterator;
    typedef ::xsd::cxx::tree::traits< Instance_portType, char > Instance_portTraits;

    const Instance_portSequence&
    getInstance_port () const;

    Instance_portSequence&
    getInstance_port ();

    void
    setInstance_port (const Instance_portSequence& s);

    // cluster_port
    //
    typedef ::poosl::Cluster_port Cluster_portType;
    typedef ::xsd::cxx::tree::sequence< Cluster_portType > Cluster_portSequence;
    typedef Cluster_portSequence::iterator Cluster_portIterator;
    typedef Cluster_portSequence::const_iterator Cluster_portConstIterator;
    typedef ::xsd::cxx::tree::traits< Cluster_portType, char > Cluster_portTraits;

    const Cluster_portSequence&
    getCluster_port () const;

    Cluster_portSequence&
    getCluster_port ();

    void
    setCluster_port (const Cluster_portSequence& s);

    // Constructors.
    //
    T_channel_node ();

    T_channel_node (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_channel_node (const T_channel_node& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual T_channel_node*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_channel_node&
    operator= (const T_channel_node& x);

    virtual 
    ~T_channel_node ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NodeSequence node_;
    Instance_portSequence instance_port_;
    Cluster_portSequence cluster_port_;
  };

  class T_message_location: public ::poosl::T_point
  {
    public:
    // width
    //
    typedef ::xml_schema::NonNegativeInteger WidthType;
    typedef ::xsd::cxx::tree::optional< WidthType > WidthOptional;
    typedef ::xsd::cxx::tree::traits< WidthType, char > WidthTraits;

    const WidthOptional&
    getWidth () const;

    WidthOptional&
    getWidth ();

    void
    setWidth (const WidthType& x);

    void
    setWidth (const WidthOptional& x);

    // Constructors.
    //
    T_message_location ();

    T_message_location (const ::poosl::T_point&);

    T_message_location (const XType&,
                        const YType&);

    T_message_location (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_message_location (const T_message_location& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_message_location*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_message_location&
    operator= (const T_message_location& x);

    virtual 
    ~T_message_location ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    WidthOptional width_;
  };

  class T_scenario: public ::poosl::T_identifier
  {
    public:
    // Constructors.
    //
    T_scenario ();

    T_scenario (const char*);

    T_scenario (const ::std::string&);

    T_scenario (const ::xml_schema::String&);

    T_scenario (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    T_scenario (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    T_scenario (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    T_scenario (const T_scenario& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual T_scenario*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_scenario ();
  };

  class T_inspector_instance: public ::xml_schema::Type
  {
    public:
    // connection
    //
    typedef ::poosl::Connection ConnectionType;
    typedef ::xsd::cxx::tree::sequence< ConnectionType > ConnectionSequence;
    typedef ConnectionSequence::iterator ConnectionIterator;
    typedef ConnectionSequence::const_iterator ConnectionConstIterator;
    typedef ::xsd::cxx::tree::traits< ConnectionType, char > ConnectionTraits;

    const ConnectionSequence&
    getConnection () const;

    ConnectionSequence&
    getConnection ();

    void
    setConnection (const ConnectionSequence& s);

    // graphics
    //
    typedef ::poosl::T_box_name_scenarios GraphicsType;
    typedef ::xsd::cxx::tree::optional< GraphicsType > GraphicsOptional;
    typedef ::xsd::cxx::tree::traits< GraphicsType, char > GraphicsTraits;

    const GraphicsOptional&
    getGraphics () const;

    GraphicsOptional&
    getGraphics ();

    void
    setGraphics (const GraphicsType& x);

    void
    setGraphics (const GraphicsOptional& x);

    void
    setGraphics (::std::unique_ptr< GraphicsType > p);

    // type
    //
    typedef ::poosl::T_instance_type TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    getType () const;

    TypeOptional&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (const TypeOptional& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // class
    //
    typedef ::xml_schema::String ClassType;
    typedef ::xsd::cxx::tree::optional< ClassType > ClassOptional;
    typedef ::xsd::cxx::tree::traits< ClassType, char > ClassTraits;

    const ClassOptional&
    getClass () const;

    ClassOptional&
    getClass ();

    void
    setClass (const ClassType& x);

    void
    setClass (const ClassOptional& x);

    void
    setClass (::std::unique_ptr< ClassType > p);

    // name
    //
    typedef ::xml_schema::String NameType;
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameOptional&
    getName () const;

    NameOptional&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (const NameOptional& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // Constructors.
    //
    T_inspector_instance ();

    T_inspector_instance (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    T_inspector_instance (const T_inspector_instance& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual T_inspector_instance*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspector_instance&
    operator= (const T_inspector_instance& x);

    virtual 
    ~T_inspector_instance ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ConnectionSequence connection_;
    GraphicsOptional graphics_;
    TypeOptional type_;
    ClassOptional class__;
    NameOptional name_;
  };

  class T_box_name_scenarios: public ::xml_schema::Type
  {
    public:
    // box
    //
    typedef ::poosl::T_box BoxType;
    typedef ::xsd::cxx::tree::traits< BoxType, char > BoxTraits;

    const BoxType&
    getBox () const;

    BoxType&
    getBox ();

    void
    setBox (const BoxType& x);

    void
    setBox (::std::unique_ptr< BoxType > p);

    // name_location
    //
    typedef ::poosl::T_point Name_locationType;
    typedef ::xsd::cxx::tree::traits< Name_locationType, char > Name_locationTraits;

    const Name_locationType&
    getName_location () const;

    Name_locationType&
    getName_location ();

    void
    setName_location (const Name_locationType& x);

    void
    setName_location (::std::unique_ptr< Name_locationType > p);

    // scenario
    //
    typedef ::poosl::T_scenario ScenarioType;
    typedef ::xsd::cxx::tree::sequence< ScenarioType > ScenarioSequence;
    typedef ScenarioSequence::iterator ScenarioIterator;
    typedef ScenarioSequence::const_iterator ScenarioConstIterator;
    typedef ::xsd::cxx::tree::traits< ScenarioType, char > ScenarioTraits;

    const ScenarioSequence&
    getScenario () const;

    ScenarioSequence&
    getScenario ();

    void
    setScenario (const ScenarioSequence& s);

    // Constructors.
    //
    T_box_name_scenarios ();

    T_box_name_scenarios (const BoxType&,
                          const Name_locationType&);

    T_box_name_scenarios (::std::unique_ptr< BoxType >,
                          ::std::unique_ptr< Name_locationType >);

    T_box_name_scenarios (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    T_box_name_scenarios (const T_box_name_scenarios& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual T_box_name_scenarios*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_box_name_scenarios&
    operator= (const T_box_name_scenarios& x);

    virtual 
    ~T_box_name_scenarios ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< BoxType > box_;
    ::xsd::cxx::tree::one< Name_locationType > name_location_;
    ScenarioSequence scenario_;
  };

  class T_set_variable_response: public ::xml_schema::Type
  {
    public:
    // result
    //
    typedef ::poosl::T_set_variable_result ResultType;
    typedef ::xsd::cxx::tree::traits< ResultType, char > ResultTraits;

    const ResultType&
    getResult () const;

    ResultType&
    getResult ();

    void
    setResult (const ResultType& x);

    void
    setResult (::std::unique_ptr< ResultType > p);

    // var_handle
    //
    typedef ::poosl::T_handle_id Var_handleType;
    typedef ::xsd::cxx::tree::traits< Var_handleType, char > Var_handleTraits;

    const Var_handleType&
    getVar_handle () const;

    Var_handleType&
    getVar_handle ();

    void
    setVar_handle (const Var_handleType& x);

    void
    setVar_handle (::std::unique_ptr< Var_handleType > p);

    // list_handle
    //
    typedef ::poosl::T_handle_id List_handleType;
    typedef ::xsd::cxx::tree::traits< List_handleType, char > List_handleTraits;

    const List_handleType&
    getList_handle () const;

    List_handleType&
    getList_handle ();

    void
    setList_handle (const List_handleType& x);

    void
    setList_handle (::std::unique_ptr< List_handleType > p);

    // error
    //
    typedef ::xml_schema::String ErrorType;
    typedef ::xsd::cxx::tree::traits< ErrorType, char > ErrorTraits;

    const ErrorType&
    getError () const;

    ErrorType&
    getError ();

    void
    setError (const ErrorType& x);

    void
    setError (::std::unique_ptr< ErrorType > p);

    // Constructors.
    //
    T_set_variable_response ();

    T_set_variable_response (const ResultType&,
                             const Var_handleType&,
                             const List_handleType&,
                             const ErrorType&);

    T_set_variable_response (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    T_set_variable_response (const T_set_variable_response& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual T_set_variable_response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_set_variable_response&
    operator= (const T_set_variable_response& x);

    virtual 
    ~T_set_variable_response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ResultType > result_;
    ::xsd::cxx::tree::one< Var_handleType > var_handle_;
    ::xsd::cxx::tree::one< List_handleType > list_handle_;
    ::xsd::cxx::tree::one< ErrorType > error_;
  };

  class Response: public ::xml_schema::Type
  {
    public:
    // load
    //
    typedef ::poosl::T_load_response LoadType;
    typedef ::xsd::cxx::tree::optional< LoadType > LoadOptional;
    typedef ::xsd::cxx::tree::traits< LoadType, char > LoadTraits;

    const LoadOptional&
    getLoad () const;

    LoadOptional&
    getLoad ();

    void
    setLoad (const LoadType& x);

    void
    setLoad (const LoadOptional& x);

    void
    setLoad (::std::unique_ptr< LoadType > p);

    // save
    //
    typedef ::poosl::T_save_response SaveType;
    typedef ::xsd::cxx::tree::optional< SaveType > SaveOptional;
    typedef ::xsd::cxx::tree::traits< SaveType, char > SaveTraits;

    const SaveOptional&
    getSave () const;

    SaveOptional&
    getSave ();

    void
    setSave (const SaveType& x);

    void
    setSave (const SaveOptional& x);

    void
    setSave (::std::unique_ptr< SaveType > p);

    // serialize
    //
    typedef ::poosl::T_serialize_response SerializeType;
    typedef ::xsd::cxx::tree::optional< SerializeType > SerializeOptional;
    typedef ::xsd::cxx::tree::traits< SerializeType, char > SerializeTraits;

    const SerializeOptional&
    getSerialize () const;

    SerializeOptional&
    getSerialize ();

    void
    setSerialize (const SerializeType& x);

    void
    setSerialize (const SerializeOptional& x);

    void
    setSerialize (::std::unique_ptr< SerializeType > p);

    // deserialize
    //
    typedef ::poosl::T_deserialize_response DeserializeType;
    typedef ::xsd::cxx::tree::optional< DeserializeType > DeserializeOptional;
    typedef ::xsd::cxx::tree::traits< DeserializeType, char > DeserializeTraits;

    const DeserializeOptional&
    getDeserialize () const;

    DeserializeOptional&
    getDeserialize ();

    void
    setDeserialize (const DeserializeType& x);

    void
    setDeserialize (const DeserializeOptional& x);

    void
    setDeserialize (::std::unique_ptr< DeserializeType > p);

    // compile
    //
    typedef ::poosl::T_compile_response CompileType;
    typedef ::xsd::cxx::tree::optional< CompileType > CompileOptional;
    typedef ::xsd::cxx::tree::traits< CompileType, char > CompileTraits;

    const CompileOptional&
    getCompile () const;

    CompileOptional&
    getCompile ();

    void
    setCompile (const CompileType& x);

    void
    setCompile (const CompileOptional& x);

    void
    setCompile (::std::unique_ptr< CompileType > p);

    // list_files
    //
    typedef ::poosl::T_list_files_response List_filesType;
    typedef ::xsd::cxx::tree::optional< List_filesType > List_filesOptional;
    typedef ::xsd::cxx::tree::traits< List_filesType, char > List_filesTraits;

    const List_filesOptional&
    getList_files () const;

    List_filesOptional&
    getList_files ();

    void
    setList_files (const List_filesType& x);

    void
    setList_files (const List_filesOptional& x);

    void
    setList_files (::std::unique_ptr< List_filesType > p);

    // get_position
    //
    typedef ::poosl::T_get_position_response Get_positionType;
    typedef ::xsd::cxx::tree::optional< Get_positionType > Get_positionOptional;
    typedef ::xsd::cxx::tree::traits< Get_positionType, char > Get_positionTraits;

    const Get_positionOptional&
    getGet_position () const;

    Get_positionOptional&
    getGet_position ();

    void
    setGet_position (const Get_positionType& x);

    void
    setGet_position (const Get_positionOptional& x);

    void
    setGet_position (::std::unique_ptr< Get_positionType > p);

    // list_classes
    //
    typedef ::poosl::T_list_classes_response List_classesType;
    typedef ::xsd::cxx::tree::optional< List_classesType > List_classesOptional;
    typedef ::xsd::cxx::tree::traits< List_classesType, char > List_classesTraits;

    const List_classesOptional&
    getList_classes () const;

    List_classesOptional&
    getList_classes ();

    void
    setList_classes (const List_classesType& x);

    void
    setList_classes (const List_classesOptional& x);

    void
    setList_classes (::std::unique_ptr< List_classesType > p);

    // get_top_level_specification
    //
    typedef ::poosl::T_get_top_level_specification_response Get_top_level_specificationType;
    typedef ::xsd::cxx::tree::optional< Get_top_level_specificationType > Get_top_level_specificationOptional;
    typedef ::xsd::cxx::tree::traits< Get_top_level_specificationType, char > Get_top_level_specificationTraits;

    const Get_top_level_specificationOptional&
    getGet_top_level_specification () const;

    Get_top_level_specificationOptional&
    getGet_top_level_specification ();

    void
    setGet_top_level_specification (const Get_top_level_specificationType& x);

    void
    setGet_top_level_specification (const Get_top_level_specificationOptional& x);

    void
    setGet_top_level_specification (::std::unique_ptr< Get_top_level_specificationType > p);

    // get_class_definition
    //
    typedef ::poosl::T_get_class_definition_response Get_class_definitionType;
    typedef ::xsd::cxx::tree::optional< Get_class_definitionType > Get_class_definitionOptional;
    typedef ::xsd::cxx::tree::traits< Get_class_definitionType, char > Get_class_definitionTraits;

    const Get_class_definitionOptional&
    getGet_class_definition () const;

    Get_class_definitionOptional&
    getGet_class_definition ();

    void
    setGet_class_definition (const Get_class_definitionType& x);

    void
    setGet_class_definition (const Get_class_definitionOptional& x);

    void
    setGet_class_definition (::std::unique_ptr< Get_class_definitionType > p);

    // get_method_definition
    //
    typedef ::poosl::T_get_method_definition_response Get_method_definitionType;
    typedef ::xsd::cxx::tree::optional< Get_method_definitionType > Get_method_definitionOptional;
    typedef ::xsd::cxx::tree::traits< Get_method_definitionType, char > Get_method_definitionTraits;

    const Get_method_definitionOptional&
    getGet_method_definition () const;

    Get_method_definitionOptional&
    getGet_method_definition ();

    void
    setGet_method_definition (const Get_method_definitionType& x);

    void
    setGet_method_definition (const Get_method_definitionOptional& x);

    void
    setGet_method_definition (::std::unique_ptr< Get_method_definitionType > p);

    // get_object_handle
    //
    typedef ::poosl::T_get_object_handle_response Get_object_handleType;
    typedef ::xsd::cxx::tree::optional< Get_object_handleType > Get_object_handleOptional;
    typedef ::xsd::cxx::tree::traits< Get_object_handleType, char > Get_object_handleTraits;

    const Get_object_handleOptional&
    getGet_object_handle () const;

    Get_object_handleOptional&
    getGet_object_handle ();

    void
    setGet_object_handle (const Get_object_handleType& x);

    void
    setGet_object_handle (const Get_object_handleOptional& x);

    void
    setGet_object_handle (::std::unique_ptr< Get_object_handleType > p);

    // rename_object_response
    //
    typedef ::poosl::T_rename_object_response Rename_object_responseType;
    typedef ::xsd::cxx::tree::optional< Rename_object_responseType > Rename_object_responseOptional;
    typedef ::xsd::cxx::tree::traits< Rename_object_responseType, char > Rename_object_responseTraits;

    const Rename_object_responseOptional&
    getRename_object_response () const;

    Rename_object_responseOptional&
    getRename_object_response ();

    void
    setRename_object_response (const Rename_object_responseType& x);

    void
    setRename_object_response (const Rename_object_responseOptional& x);

    void
    setRename_object_response (::std::unique_ptr< Rename_object_responseType > p);

    // insert_object_response
    //
    typedef ::poosl::T_insert_object_response Insert_object_responseType;
    typedef ::xsd::cxx::tree::optional< Insert_object_responseType > Insert_object_responseOptional;
    typedef ::xsd::cxx::tree::traits< Insert_object_responseType, char > Insert_object_responseTraits;

    const Insert_object_responseOptional&
    getInsert_object_response () const;

    Insert_object_responseOptional&
    getInsert_object_response ();

    void
    setInsert_object_response (const Insert_object_responseType& x);

    void
    setInsert_object_response (const Insert_object_responseOptional& x);

    void
    setInsert_object_response (::std::unique_ptr< Insert_object_responseType > p);

    // delete_object_response
    //
    typedef ::poosl::T_delete_object_response Delete_object_responseType;
    typedef ::xsd::cxx::tree::optional< Delete_object_responseType > Delete_object_responseOptional;
    typedef ::xsd::cxx::tree::traits< Delete_object_responseType, char > Delete_object_responseTraits;

    const Delete_object_responseOptional&
    getDelete_object_response () const;

    Delete_object_responseOptional&
    getDelete_object_response ();

    void
    setDelete_object_response (const Delete_object_responseType& x);

    void
    setDelete_object_response (const Delete_object_responseOptional& x);

    void
    setDelete_object_response (::std::unique_ptr< Delete_object_responseType > p);

    // instantiate
    //
    typedef ::poosl::T_instantiate_response InstantiateType;
    typedef ::xsd::cxx::tree::optional< InstantiateType > InstantiateOptional;
    typedef ::xsd::cxx::tree::traits< InstantiateType, char > InstantiateTraits;

    const InstantiateOptional&
    getInstantiate () const;

    InstantiateOptional&
    getInstantiate ();

    void
    setInstantiate (const InstantiateType& x);

    void
    setInstantiate (const InstantiateOptional& x);

    void
    setInstantiate (::std::unique_ptr< InstantiateType > p);

    // command
    //
    typedef ::poosl::T_command_response CommandType;
    typedef ::xsd::cxx::tree::optional< CommandType > CommandOptional;
    typedef ::xsd::cxx::tree::traits< CommandType, char > CommandTraits;

    const CommandOptional&
    getCommand () const;

    CommandOptional&
    getCommand ();

    void
    setCommand (const CommandType& x);

    void
    setCommand (const CommandOptional& x);

    void
    setCommand (::std::unique_ptr< CommandType > p);

    // execution_state
    //
    typedef ::poosl::T_execution_state_change_response Execution_stateType;
    typedef ::xsd::cxx::tree::optional< Execution_stateType > Execution_stateOptional;
    typedef ::xsd::cxx::tree::traits< Execution_stateType, char > Execution_stateTraits;

    const Execution_stateOptional&
    getExecution_state () const;

    Execution_stateOptional&
    getExecution_state ();

    void
    setExecution_state (const Execution_stateType& x);

    void
    setExecution_state (const Execution_stateOptional& x);

    void
    setExecution_state (::std::unique_ptr< Execution_stateType > p);

    // get_transitions
    //
    typedef ::poosl::T_get_transitions_response Get_transitionsType;
    typedef ::xsd::cxx::tree::optional< Get_transitionsType > Get_transitionsOptional;
    typedef ::xsd::cxx::tree::traits< Get_transitionsType, char > Get_transitionsTraits;

    const Get_transitionsOptional&
    getGet_transitions () const;

    Get_transitionsOptional&
    getGet_transitions ();

    void
    setGet_transitions (const Get_transitionsType& x);

    void
    setGet_transitions (const Get_transitionsOptional& x);

    void
    setGet_transitions (::std::unique_ptr< Get_transitionsType > p);

    // perform_transition
    //
    typedef ::poosl::T_perform_transition_response Perform_transitionType;
    typedef ::xsd::cxx::tree::optional< Perform_transitionType > Perform_transitionOptional;
    typedef ::xsd::cxx::tree::traits< Perform_transitionType, char > Perform_transitionTraits;

    const Perform_transitionOptional&
    getPerform_transition () const;

    Perform_transitionOptional&
    getPerform_transition ();

    void
    setPerform_transition (const Perform_transitionType& x);

    void
    setPerform_transition (const Perform_transitionOptional& x);

    void
    setPerform_transition (::std::unique_ptr< Perform_transitionType > p);

    // inspect
    //
    typedef ::poosl::T_inspect_response InspectType;
    typedef ::xsd::cxx::tree::optional< InspectType > InspectOptional;
    typedef ::xsd::cxx::tree::traits< InspectType, char > InspectTraits;

    const InspectOptional&
    getInspect () const;

    InspectOptional&
    getInspect ();

    void
    setInspect (const InspectType& x);

    void
    setInspect (const InspectOptional& x);

    void
    setInspect (::std::unique_ptr< InspectType > p);

    // observe
    //
    typedef ::poosl::T_observe_response ObserveType;
    typedef ::xsd::cxx::tree::optional< ObserveType > ObserveOptional;
    typedef ::xsd::cxx::tree::traits< ObserveType, char > ObserveTraits;

    const ObserveOptional&
    getObserve () const;

    ObserveOptional&
    getObserve ();

    void
    setObserve (const ObserveType& x);

    void
    setObserve (const ObserveOptional& x);

    void
    setObserve (::std::unique_ptr< ObserveType > p);

    // create_breakpoint
    //
    typedef ::poosl::T_create_breakpoint_response Create_breakpointType;
    typedef ::xsd::cxx::tree::optional< Create_breakpointType > Create_breakpointOptional;
    typedef ::xsd::cxx::tree::traits< Create_breakpointType, char > Create_breakpointTraits;

    const Create_breakpointOptional&
    getCreate_breakpoint () const;

    Create_breakpointOptional&
    getCreate_breakpoint ();

    void
    setCreate_breakpoint (const Create_breakpointType& x);

    void
    setCreate_breakpoint (const Create_breakpointOptional& x);

    void
    setCreate_breakpoint (::std::unique_ptr< Create_breakpointType > p);

    // set_breakpoint_condition
    //
    typedef ::poosl::T_set_breakpoint_condition_response Set_breakpoint_conditionType;
    typedef ::xsd::cxx::tree::optional< Set_breakpoint_conditionType > Set_breakpoint_conditionOptional;
    typedef ::xsd::cxx::tree::traits< Set_breakpoint_conditionType, char > Set_breakpoint_conditionTraits;

    const Set_breakpoint_conditionOptional&
    getSet_breakpoint_condition () const;

    Set_breakpoint_conditionOptional&
    getSet_breakpoint_condition ();

    void
    setSet_breakpoint_condition (const Set_breakpoint_conditionType& x);

    void
    setSet_breakpoint_condition (const Set_breakpoint_conditionOptional& x);

    void
    setSet_breakpoint_condition (::std::unique_ptr< Set_breakpoint_conditionType > p);

    // enable_breakpoint
    //
    typedef ::poosl::T_enable_breakpoint_response Enable_breakpointType;
    typedef ::xsd::cxx::tree::optional< Enable_breakpointType > Enable_breakpointOptional;
    typedef ::xsd::cxx::tree::traits< Enable_breakpointType, char > Enable_breakpointTraits;

    const Enable_breakpointOptional&
    getEnable_breakpoint () const;

    Enable_breakpointOptional&
    getEnable_breakpoint ();

    void
    setEnable_breakpoint (const Enable_breakpointType& x);

    void
    setEnable_breakpoint (const Enable_breakpointOptional& x);

    void
    setEnable_breakpoint (::std::unique_ptr< Enable_breakpointType > p);

    // disable_breakpoint
    //
    typedef ::poosl::T_disable_breakpoint_response Disable_breakpointType;
    typedef ::xsd::cxx::tree::optional< Disable_breakpointType > Disable_breakpointOptional;
    typedef ::xsd::cxx::tree::traits< Disable_breakpointType, char > Disable_breakpointTraits;

    const Disable_breakpointOptional&
    getDisable_breakpoint () const;

    Disable_breakpointOptional&
    getDisable_breakpoint ();

    void
    setDisable_breakpoint (const Disable_breakpointType& x);

    void
    setDisable_breakpoint (const Disable_breakpointOptional& x);

    void
    setDisable_breakpoint (::std::unique_ptr< Disable_breakpointType > p);

    // delete_breakpoint
    //
    typedef ::poosl::T_delete_breakpoint_response Delete_breakpointType;
    typedef ::xsd::cxx::tree::optional< Delete_breakpointType > Delete_breakpointOptional;
    typedef ::xsd::cxx::tree::traits< Delete_breakpointType, char > Delete_breakpointTraits;

    const Delete_breakpointOptional&
    getDelete_breakpoint () const;

    Delete_breakpointOptional&
    getDelete_breakpoint ();

    void
    setDelete_breakpoint (const Delete_breakpointType& x);

    void
    setDelete_breakpoint (const Delete_breakpointOptional& x);

    void
    setDelete_breakpoint (::std::unique_ptr< Delete_breakpointType > p);

    // eengine_event_setup
    //
    typedef ::poosl::T_eengine_event_setup_response Eengine_event_setupType;
    typedef ::xsd::cxx::tree::optional< Eengine_event_setupType > Eengine_event_setupOptional;
    typedef ::xsd::cxx::tree::traits< Eengine_event_setupType, char > Eengine_event_setupTraits;

    const Eengine_event_setupOptional&
    getEengine_event_setup () const;

    Eengine_event_setupOptional&
    getEengine_event_setup ();

    void
    setEengine_event_setup (const Eengine_event_setupType& x);

    void
    setEengine_event_setup (const Eengine_event_setupOptional& x);

    void
    setEengine_event_setup (::std::unique_ptr< Eengine_event_setupType > p);

    // communication_event
    //
    typedef ::poosl::T_communication_event Communication_eventType;
    typedef ::xsd::cxx::tree::optional< Communication_eventType > Communication_eventOptional;
    typedef ::xsd::cxx::tree::traits< Communication_eventType, char > Communication_eventTraits;

    const Communication_eventOptional&
    getCommunication_event () const;

    Communication_eventOptional&
    getCommunication_event ();

    void
    setCommunication_event (const Communication_eventType& x);

    void
    setCommunication_event (const Communication_eventOptional& x);

    void
    setCommunication_event (::std::unique_ptr< Communication_eventType > p);

    // eengine_event_error
    //
    typedef ::poosl::T_eengine_event_error_response Eengine_event_errorType;
    typedef ::xsd::cxx::tree::optional< Eengine_event_errorType > Eengine_event_errorOptional;
    typedef ::xsd::cxx::tree::traits< Eengine_event_errorType, char > Eengine_event_errorTraits;

    const Eengine_event_errorOptional&
    getEengine_event_error () const;

    Eengine_event_errorOptional&
    getEengine_event_error ();

    void
    setEengine_event_error (const Eengine_event_errorType& x);

    void
    setEengine_event_error (const Eengine_event_errorOptional& x);

    void
    setEengine_event_error (::std::unique_ptr< Eengine_event_errorType > p);

    // set_variable
    //
    typedef ::poosl::T_set_variable_response Set_variableType;
    typedef ::xsd::cxx::tree::optional< Set_variableType > Set_variableOptional;
    typedef ::xsd::cxx::tree::traits< Set_variableType, char > Set_variableTraits;

    const Set_variableOptional&
    getSet_variable () const;

    Set_variableOptional&
    getSet_variable ();

    void
    setSet_variable (const Set_variableType& x);

    void
    setSet_variable (const Set_variableOptional& x);

    void
    setSet_variable (::std::unique_ptr< Set_variableType > p);

    // Constructors.
    //
    Response ();

    Response (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    Response (const Response& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual Response*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Response&
    operator= (const Response& x);

    virtual 
    ~Response ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LoadOptional load_;
    SaveOptional save_;
    SerializeOptional serialize_;
    DeserializeOptional deserialize_;
    CompileOptional compile_;
    List_filesOptional list_files_;
    Get_positionOptional get_position_;
    List_classesOptional list_classes_;
    Get_top_level_specificationOptional get_top_level_specification_;
    Get_class_definitionOptional get_class_definition_;
    Get_method_definitionOptional get_method_definition_;
    Get_object_handleOptional get_object_handle_;
    Rename_object_responseOptional rename_object_response_;
    Insert_object_responseOptional insert_object_response_;
    Delete_object_responseOptional delete_object_response_;
    InstantiateOptional instantiate_;
    CommandOptional command_;
    Execution_stateOptional execution_state_;
    Get_transitionsOptional get_transitions_;
    Perform_transitionOptional perform_transition_;
    InspectOptional inspect_;
    ObserveOptional observe_;
    Create_breakpointOptional create_breakpoint_;
    Set_breakpoint_conditionOptional set_breakpoint_condition_;
    Enable_breakpointOptional enable_breakpoint_;
    Disable_breakpointOptional disable_breakpoint_;
    Delete_breakpointOptional delete_breakpoint_;
    Eengine_event_setupOptional eengine_event_setup_;
    Communication_eventOptional communication_event_;
    Eengine_event_errorOptional eengine_event_error_;
    Set_variableOptional set_variable_;
  };

  class File: public ::xml_schema::String
  {
    public:
    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::optional< HandleType > HandleOptional;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleOptional&
    getHandle () const;

    HandleOptional&
    getHandle ();

    void
    setHandle (const HandleType& x);

    void
    setHandle (const HandleOptional& x);

    // Constructors.
    //
    File ();

    File (const char*);

    File (const ::std::string&);

    File (const ::xml_schema::String&);

    File (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    File (const File& x,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    virtual File*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    File&
    operator= (const File& x);

    virtual 
    ~File ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    HandleOptional handle_;
  };

  class Channel: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::xml_schema::String NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // output_port
    //
    typedef ::xml_schema::String Output_portType;
    typedef ::xsd::cxx::tree::optional< Output_portType > Output_portOptional;
    typedef ::xsd::cxx::tree::traits< Output_portType, char > Output_portTraits;

    const Output_portOptional&
    getOutput_port () const;

    Output_portOptional&
    getOutput_port ();

    void
    setOutput_port (const Output_portType& x);

    void
    setOutput_port (const Output_portOptional& x);

    void
    setOutput_port (::std::unique_ptr< Output_portType > p);

    // Constructors.
    //
    Channel ();

    Channel (const NameType&);

    Channel (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    Channel (const Channel& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    virtual Channel*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Channel&
    operator= (const Channel& x);

    virtual 
    ~Channel ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    Output_portOptional output_port_;
  };

  class Aspect: public ::xml_schema::Type
  {
    public:
    // type
    //
    typedef ::poosl::T_observe_aspect TypeType;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeType&
    getType () const;

    TypeType&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // Constructors.
    //
    Aspect ();

    Aspect (const TypeType&);

    Aspect (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    Aspect (const Aspect& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    virtual Aspect*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Aspect&
    operator= (const Aspect& x);

    virtual 
    ~Aspect ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TypeType > type_;
  };

  class Parameter: public ::xml_schema::Type
  {
    public:
    // value
    //
    typedef ::xml_schema::String ValueType;
    typedef ::xsd::cxx::tree::optional< ValueType > ValueOptional;
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    const ValueOptional&
    getValue () const;

    ValueOptional&
    getValue ();

    void
    setValue (const ValueType& x);

    void
    setValue (const ValueOptional& x);

    void
    setValue (::std::unique_ptr< ValueType > p);

    // type
    //
    typedef ::xml_schema::String TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    getType () const;

    TypeOptional&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (const TypeOptional& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // Constructors.
    //
    Parameter ();

    Parameter (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    Parameter (const Parameter& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual Parameter*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Parameter&
    operator= (const Parameter& x);

    virtual 
    ~Parameter ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ValueOptional value_;
    TypeOptional type_;
  };

  class Node: public ::xml_schema::Type
  {
    public:
    // number
    //
    typedef ::xml_schema::NonNegativeInteger NumberType;
    typedef ::xsd::cxx::tree::traits< NumberType, char > NumberTraits;

    const NumberType&
    getNumber () const;

    NumberType&
    getNumber ();

    void
    setNumber (const NumberType& x);

    // Constructors.
    //
    Node ();

    Node (const NumberType&);

    Node (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    Node (const Node& x,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    virtual Node*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Node&
    operator= (const Node& x);

    virtual 
    ~Node ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NumberType > number_;
  };

  class Instance_port: public ::xml_schema::Type
  {
    public:
    // instance_name
    //
    typedef ::poosl::T_identifier Instance_nameType;
    typedef ::xsd::cxx::tree::traits< Instance_nameType, char > Instance_nameTraits;

    const Instance_nameType&
    getInstance_name () const;

    Instance_nameType&
    getInstance_name ();

    void
    setInstance_name (const Instance_nameType& x);

    void
    setInstance_name (::std::unique_ptr< Instance_nameType > p);

    // port_name
    //
    typedef ::poosl::T_identifier Port_nameType;
    typedef ::xsd::cxx::tree::traits< Port_nameType, char > Port_nameTraits;

    const Port_nameType&
    getPort_name () const;

    Port_nameType&
    getPort_name ();

    void
    setPort_name (const Port_nameType& x);

    void
    setPort_name (::std::unique_ptr< Port_nameType > p);

    // Constructors.
    //
    Instance_port ();

    Instance_port (const Instance_nameType&,
                   const Port_nameType&);

    Instance_port (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    Instance_port (const Instance_port& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual Instance_port*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Instance_port&
    operator= (const Instance_port& x);

    virtual 
    ~Instance_port ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Instance_nameType > instance_name_;
    ::xsd::cxx::tree::one< Port_nameType > port_name_;
  };

  class Cluster_port: public ::xml_schema::Type
  {
    public:
    // port_name
    //
    typedef ::poosl::T_identifier Port_nameType;
    typedef ::xsd::cxx::tree::traits< Port_nameType, char > Port_nameTraits;

    const Port_nameType&
    getPort_name () const;

    Port_nameType&
    getPort_name ();

    void
    setPort_name (const Port_nameType& x);

    void
    setPort_name (::std::unique_ptr< Port_nameType > p);

    // Constructors.
    //
    Cluster_port ();

    Cluster_port (const Port_nameType&);

    Cluster_port (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    Cluster_port (const Cluster_port& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual Cluster_port*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Cluster_port&
    operator= (const Cluster_port& x);

    virtual 
    ~Cluster_port ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Port_nameType > port_name_;
  };

  class Connection: public ::xml_schema::Type
  {
    public:
    // graphics
    //
    typedef ::poosl::T_graphics_port GraphicsType;
    typedef ::xsd::cxx::tree::optional< GraphicsType > GraphicsOptional;
    typedef ::xsd::cxx::tree::traits< GraphicsType, char > GraphicsTraits;

    const GraphicsOptional&
    getGraphics () const;

    GraphicsOptional&
    getGraphics ();

    void
    setGraphics (const GraphicsType& x);

    void
    setGraphics (const GraphicsOptional& x);

    void
    setGraphics (::std::unique_ptr< GraphicsType > p);

    // port
    //
    typedef ::poosl::T_identifier PortType;
    typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

    const PortType&
    getPort () const;

    PortType&
    getPort ();

    void
    setPort (const PortType& x);

    void
    setPort (::std::unique_ptr< PortType > p);

    // channel
    //
    typedef ::poosl::T_identifier ChannelType;
    typedef ::xsd::cxx::tree::traits< ChannelType, char > ChannelTraits;

    const ChannelType&
    getChannel () const;

    ChannelType&
    getChannel ();

    void
    setChannel (const ChannelType& x);

    void
    setChannel (::std::unique_ptr< ChannelType > p);

    // Constructors.
    //
    Connection ();

    Connection (const PortType&,
                const ChannelType&);

    Connection (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    Connection (const Connection& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual Connection*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Connection&
    operator= (const Connection& x);

    virtual 
    ~Connection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    GraphicsOptional graphics_;
    ::xsd::cxx::tree::one< PortType > port_;
    ::xsd::cxx::tree::one< ChannelType > channel_;
  };
}

#include <iosfwd>

namespace poosl
{
  ::std::ostream&
  operator<< (::std::ostream&, const T_load_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_save_response&);

  ::std::ostream&
  operator<< (::std::ostream&, T_file_io_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_file_io_result&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_serialize_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_deserialize_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_compile_response&);

  ::std::ostream&
  operator<< (::std::ostream&, T_serialize_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_serialize_result&);

  ::std::ostream&
  operator<< (::std::ostream&, T_parse_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_parse_result&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_list_classes_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_list_files_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_get_position_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_get_top_level_specification_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_get_class_definition_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_cluster_class_def&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_process_class_def&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_data_class_def&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_get_method_definition_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_process_method_def&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_data_method_def&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_get_object_handle_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_rename_object_response&);

  ::std::ostream&
  operator<< (::std::ostream&, T_rename_object_response_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_rename_object_response_result&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_insert_object_response&);

  ::std::ostream&
  operator<< (::std::ostream&, T_insert_object_response_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_insert_object_response_result&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_delete_object_response&);

  ::std::ostream&
  operator<< (::std::ostream&, T_object_query_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_object_query_result&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_instantiate_response&);

  ::std::ostream&
  operator<< (::std::ostream&, T_instantiate_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_instantiate_result&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_command_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_get_transitions_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_perform_transition_response&);

  ::std::ostream&
  operator<< (::std::ostream&, T_perform_transition_response_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_perform_transition_response_result&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_process&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_port&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_instance&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_cluster&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_system&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_channel&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_stackframe&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_variable_context&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_variable&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_data&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_transition&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_observe_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_execution_state_change_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_eengine_event_setup_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_communication_event&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_eengine_event_error_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_communcation_event_node&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_error_stacktrace&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_error_stackframe&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_communication_event_message&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_communication_event_parameter&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_breakpoint&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_breakpoint_info&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_error_info&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_create_breakpoint_response&);

  ::std::ostream&
  operator<< (::std::ostream&, T_create_breakpoint_response_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_create_breakpoint_response_result&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_set_breakpoint_condition_response&);

  ::std::ostream&
  operator<< (::std::ostream&, T_set_breakpoint_condition_response_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_set_breakpoint_condition_response_result&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_enable_breakpoint_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_disable_breakpoint_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_delete_breakpoint_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_breakpoint_result&);

  ::std::ostream&
  operator<< (::std::ostream&, T_breakpoint_result_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_breakpoint_result_result&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_var_list&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_variable&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_method_list&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_method&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_executiontree&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_executiontree_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_executiontree_statements&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_executiontree_method_call&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_executiontree_message_receive&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_executiontree_expression&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_cluster_instance_interface&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_cluster_instance_port&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_graphics_port&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_graphics_channel&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_channel_node&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_message_location&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_scenario&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspector_instance&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_box_name_scenarios&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_set_variable_response&);

  ::std::ostream&
  operator<< (::std::ostream&, const Response&);

  ::std::ostream&
  operator<< (::std::ostream&, const File&);

  ::std::ostream&
  operator<< (::std::ostream&, const Channel&);

  ::std::ostream&
  operator<< (::std::ostream&, const Aspect&);

  ::std::ostream&
  operator<< (::std::ostream&, const Parameter&);

  ::std::ostream&
  operator<< (::std::ostream&, const Node&);

  ::std::ostream&
  operator<< (::std::ostream&, const Instance_port&);

  ::std::ostream&
  operator<< (::std::ostream&, const Cluster_port&);

  ::std::ostream&
  operator<< (::std::ostream&, const Connection&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace poosl
{
  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (const ::std::string& uri,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (const ::std::string& uri,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (const ::std::string& uri,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 const ::std::string& id,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::xercesc::InputSource& is,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::xercesc::InputSource& is,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::xercesc::InputSource& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (const ::xercesc::DOMDocument& d,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace poosl
{
  // Serialize to std::ostream.
  //

  void
  serializeResponse (::std::ostream& os,
                     const ::poosl::Response& x, 
                     const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                     const ::std::string& e = "UTF-8",
                     ::xml_schema::Flags f = 0);

  void
  serializeResponse (::std::ostream& os,
                     const ::poosl::Response& x, 
                     ::xml_schema::ErrorHandler& eh,
                     const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                     const ::std::string& e = "UTF-8",
                     ::xml_schema::Flags f = 0);

  void
  serializeResponse (::std::ostream& os,
                     const ::poosl::Response& x, 
                     ::xercesc::DOMErrorHandler& eh,
                     const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                     const ::std::string& e = "UTF-8",
                     ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  serializeResponse (::xercesc::XMLFormatTarget& ft,
                     const ::poosl::Response& x, 
                     const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                     const ::std::string& e = "UTF-8",
                     ::xml_schema::Flags f = 0);

  void
  serializeResponse (::xercesc::XMLFormatTarget& ft,
                     const ::poosl::Response& x, 
                     ::xml_schema::ErrorHandler& eh,
                     const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                     const ::std::string& e = "UTF-8",
                     ::xml_schema::Flags f = 0);

  void
  serializeResponse (::xercesc::XMLFormatTarget& ft,
                     const ::poosl::Response& x, 
                     ::xercesc::DOMErrorHandler& eh,
                     const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                     const ::std::string& e = "UTF-8",
                     ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  serializeResponse (::xercesc::DOMDocument& d,
                     const ::poosl::Response& x,
                     ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeResponse (const ::poosl::Response& x, 
                     const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                     ::xml_schema::Flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const T_load_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_save_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_file_io_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_file_io_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_file_io_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_serialize_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_deserialize_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_compile_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_serialize_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_serialize_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_serialize_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_parse_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_parse_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_parse_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_list_classes_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_list_files_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_get_position_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_get_top_level_specification_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_get_class_definition_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_cluster_class_def&);

  void
  operator<< (::xercesc::DOMElement&, const T_process_class_def&);

  void
  operator<< (::xercesc::DOMElement&, const T_data_class_def&);

  void
  operator<< (::xercesc::DOMElement&, const T_get_method_definition_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_process_method_def&);

  void
  operator<< (::xercesc::DOMElement&, const T_data_method_def&);

  void
  operator<< (::xercesc::DOMElement&, const T_get_object_handle_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_rename_object_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_rename_object_response_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_rename_object_response_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_rename_object_response_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_insert_object_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_insert_object_response_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_insert_object_response_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_insert_object_response_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_delete_object_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_object_query_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_object_query_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_object_query_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_instantiate_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_instantiate_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_instantiate_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_instantiate_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_command_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_get_transitions_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_perform_transition_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_perform_transition_response_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_perform_transition_response_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_perform_transition_response_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_process&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_port&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_instance&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_cluster&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_system&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_channel&);

  void
  operator<< (::xercesc::DOMElement&, const T_stackframe&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_variable_context&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_variable&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_data&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_transition&);

  void
  operator<< (::xercesc::DOMElement&, const T_observe_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_execution_state_change_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_eengine_event_setup_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_communication_event&);

  void
  operator<< (::xercesc::DOMElement&, const T_eengine_event_error_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_communcation_event_node&);

  void
  operator<< (::xercesc::DOMElement&, const T_error_stacktrace&);

  void
  operator<< (::xercesc::DOMElement&, const T_error_stackframe&);

  void
  operator<< (::xercesc::DOMElement&, const T_communication_event_message&);

  void
  operator<< (::xercesc::DOMElement&, const T_communication_event_parameter&);

  void
  operator<< (::xercesc::DOMElement&, const T_breakpoint&);

  void
  operator<< (::xercesc::DOMElement&, const T_breakpoint_info&);

  void
  operator<< (::xercesc::DOMElement&, const T_error_info&);

  void
  operator<< (::xercesc::DOMElement&, const T_create_breakpoint_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_create_breakpoint_response_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_create_breakpoint_response_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_create_breakpoint_response_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_set_breakpoint_condition_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_set_breakpoint_condition_response_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_set_breakpoint_condition_response_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_set_breakpoint_condition_response_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_enable_breakpoint_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_disable_breakpoint_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_delete_breakpoint_response&);

  void
  operator<< (::xercesc::DOMElement&, const T_breakpoint_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_breakpoint_result_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_breakpoint_result_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_breakpoint_result_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_var_list&);

  void
  operator<< (::xercesc::DOMElement&, const T_variable&);

  void
  operator<< (::xercesc::DOMElement&, const T_method_list&);

  void
  operator<< (::xercesc::DOMElement&, const T_method&);

  void
  operator<< (::xercesc::DOMElement&, const T_executiontree&);

  void
  operator<< (::xercesc::DOMElement&, const T_executiontree_base&);

  void
  operator<< (::xercesc::DOMElement&, const T_executiontree_statements&);

  void
  operator<< (::xercesc::DOMElement&, const T_executiontree_method_call&);

  void
  operator<< (::xercesc::DOMElement&, const T_executiontree_message_receive&);

  void
  operator<< (::xercesc::DOMElement&, const T_executiontree_expression&);

  void
  operator<< (::xercesc::DOMElement&, const T_cluster_instance_interface&);

  void
  operator<< (::xercesc::DOMElement&, const T_cluster_instance_port&);

  void
  operator<< (::xercesc::DOMElement&, const T_graphics_port&);

  void
  operator<< (::xercesc::DOMElement&, const T_graphics_channel&);

  void
  operator<< (::xercesc::DOMElement&, const T_channel_node&);

  void
  operator<< (::xercesc::DOMElement&, const T_message_location&);

  void
  operator<< (::xercesc::DOMElement&, const T_scenario&);

  void
  operator<< (::xercesc::DOMAttr&, const T_scenario&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_scenario&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspector_instance&);

  void
  operator<< (::xercesc::DOMElement&, const T_box_name_scenarios&);

  void
  operator<< (::xercesc::DOMElement&, const T_set_variable_response&);

  void
  operator<< (::xercesc::DOMElement&, const Response&);

  void
  operator<< (::xercesc::DOMElement&, const File&);

  void
  operator<< (::xercesc::DOMElement&, const Channel&);

  void
  operator<< (::xercesc::DOMElement&, const Aspect&);

  void
  operator<< (::xercesc::DOMElement&, const Parameter&);

  void
  operator<< (::xercesc::DOMElement&, const Node&);

  void
  operator<< (::xercesc::DOMElement&, const Instance_port&);

  void
  operator<< (::xercesc::DOMElement&, const Cluster_port&);

  void
  operator<< (::xercesc::DOMElement&, const Connection&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // ROTALUMISRESPONSE_HXX
