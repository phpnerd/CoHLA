// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef POOSLSTATEMENTS_HXX
#define POOSLSTATEMENTS_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-iso8859-1.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type Type;
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;
  typedef ::xsd::cxx::tree::type Container;

  // 8-bit
  //
  typedef signed char Byte;
  typedef unsigned char UnsignedByte;

  // 16-bit
  //
  typedef short Short;
  typedef unsigned short UnsignedShort;

  // 32-bit
  //
  typedef int Int;
  typedef unsigned int UnsignedInt;

  // 64-bit
  //
  typedef long long Long;
  typedef unsigned long long UnsignedLong;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long Integer;
  typedef long long NonPositiveInteger;
  typedef unsigned long long NonNegativeInteger;
  typedef unsigned long long PositiveInteger;
  typedef long long NegativeInteger;

  // Boolean.
  //
  typedef bool Boolean;

  // Floating-point types.
  //
  typedef float Float;
  typedef double Double;
  typedef double Decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;
  typedef ::xsd::cxx::tree::name< char, Token > Name;
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;
  typedef ::xsd::cxx::tree::language< char, Token > Language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > Buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone TimeZone;
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;

  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags Flags;
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity Severity;
  typedef ::xsd::cxx::tree::error< char > Error;
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > Exception;
  typedef ::xsd::cxx::tree::bounds< char > Bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;
  typedef ::xsd::cxx::tree::parsing< char > Parsing;
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;
  typedef ::xsd::cxx::tree::no_type_info< char > NoTypeInfo;
  typedef ::xsd::cxx::tree::not_derived< char > NotDerived;
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace poosl
{
  class T_constant_type;
  class T_binary_operator;
  class T_unary_operator;
  class T_expressions;
  class T_expression;
  class T_assignment;
  class T_data_method_call;
  class T_constant;
  class T_current_time;
  class T_variable_ref;
  class T_binary_operation;
  class T_unary_operation;
  class T_if_expression;
  class T_while_expression;
  class T_object_creation;
  class T_statements;
  class T_statement;
  class T_process_method_call;
  class T_initial_process_method_call;
  class T_message_receive;
  class T_message_send;
  class T_guard;
  class T_if_statement;
  class T_while_statement;
  class T_switch_statement;
  class T_switch_case_statement;
  class T_abort;
  class T_interrupt;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-iso8859-1.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

#include "poosltypes.hxx"

namespace poosl
{
  class T_constant_type: public ::xml_schema::String
  {
    public:
    enum Value
    {
      string,
      character,
      integer,
      real,
      boolean
    };

    T_constant_type ();

    T_constant_type (Value v);

    T_constant_type (const char* v);

    T_constant_type (const ::std::string& v);

    T_constant_type (const ::xml_schema::String& v);

    T_constant_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_constant_type (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_constant_type (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_constant_type (const T_constant_type& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual T_constant_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_constant_type&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_constant_type_convert ();
    }

    protected:
    Value
    _xsd_T_constant_type_convert () const;

    public:
    static const char* const _xsd_T_constant_type_literals_[5];
    static const Value _xsd_T_constant_type_indexes_[5];
  };

  class T_binary_operator: public ::xml_schema::String
  {
    public:
    enum Value
    {
      cxx_,
      cxx_1,
      cxx_2,
      cxx_3,
      cxx_4,
      cxx__,
      cxx__1,
      cxx___,
      cxx_5,
      cxx_6,
      cxx_7,
      cxx_8,
      cxx__2,
      cxx__3
    };

    T_binary_operator ();

    T_binary_operator (Value v);

    T_binary_operator (const char* v);

    T_binary_operator (const ::std::string& v);

    T_binary_operator (const ::xml_schema::String& v);

    T_binary_operator (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_binary_operator (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_binary_operator (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_binary_operator (const T_binary_operator& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_binary_operator*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_binary_operator&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_binary_operator_convert ();
    }

    protected:
    Value
    _xsd_T_binary_operator_convert () const;

    public:
    static const char* const _xsd_T_binary_operator_literals_[14];
    static const Value _xsd_T_binary_operator_indexes_[14];
  };

  class T_unary_operator: public ::xml_schema::String
  {
    public:
    enum Value
    {
      cxx_,
      cxx_1
    };

    T_unary_operator ();

    T_unary_operator (Value v);

    T_unary_operator (const char* v);

    T_unary_operator (const ::std::string& v);

    T_unary_operator (const ::xml_schema::String& v);

    T_unary_operator (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_unary_operator (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_unary_operator (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_unary_operator (const T_unary_operator& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual T_unary_operator*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_unary_operator&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_unary_operator_convert ();
    }

    protected:
    Value
    _xsd_T_unary_operator_convert () const;

    public:
    static const char* const _xsd_T_unary_operator_literals_[2];
    static const Value _xsd_T_unary_operator_indexes_[2];
  };

  class T_expressions: public ::xml_schema::Type
  {
    public:
    // sequence_of_expressions
    //
    typedef ::poosl::T_expressions Sequence_of_expressionsType;
    typedef ::xsd::cxx::tree::sequence< Sequence_of_expressionsType > Sequence_of_expressionsSequence;
    typedef Sequence_of_expressionsSequence::iterator Sequence_of_expressionsIterator;
    typedef Sequence_of_expressionsSequence::const_iterator Sequence_of_expressionsConstIterator;
    typedef ::xsd::cxx::tree::traits< Sequence_of_expressionsType, char > Sequence_of_expressionsTraits;

    const Sequence_of_expressionsSequence&
    getSequence_of_expressions () const;

    Sequence_of_expressionsSequence&
    getSequence_of_expressions ();

    void
    setSequence_of_expressions (const Sequence_of_expressionsSequence& s);

    // assignment
    //
    typedef ::poosl::T_assignment AssignmentType;
    typedef ::xsd::cxx::tree::sequence< AssignmentType > AssignmentSequence;
    typedef AssignmentSequence::iterator AssignmentIterator;
    typedef AssignmentSequence::const_iterator AssignmentConstIterator;
    typedef ::xsd::cxx::tree::traits< AssignmentType, char > AssignmentTraits;

    const AssignmentSequence&
    getAssignment () const;

    AssignmentSequence&
    getAssignment ();

    void
    setAssignment (const AssignmentSequence& s);

    // data_method_call
    //
    typedef ::poosl::T_data_method_call Data_method_callType;
    typedef ::xsd::cxx::tree::sequence< Data_method_callType > Data_method_callSequence;
    typedef Data_method_callSequence::iterator Data_method_callIterator;
    typedef Data_method_callSequence::const_iterator Data_method_callConstIterator;
    typedef ::xsd::cxx::tree::traits< Data_method_callType, char > Data_method_callTraits;

    const Data_method_callSequence&
    getData_method_call () const;

    Data_method_callSequence&
    getData_method_call ();

    void
    setData_method_call (const Data_method_callSequence& s);

    // constant
    //
    typedef ::poosl::T_constant ConstantType;
    typedef ::xsd::cxx::tree::sequence< ConstantType > ConstantSequence;
    typedef ConstantSequence::iterator ConstantIterator;
    typedef ConstantSequence::const_iterator ConstantConstIterator;
    typedef ::xsd::cxx::tree::traits< ConstantType, char > ConstantTraits;

    const ConstantSequence&
    getConstant () const;

    ConstantSequence&
    getConstant ();

    void
    setConstant (const ConstantSequence& s);

    // variable
    //
    typedef ::poosl::T_variable_ref VariableType;
    typedef ::xsd::cxx::tree::sequence< VariableType > VariableSequence;
    typedef VariableSequence::iterator VariableIterator;
    typedef VariableSequence::const_iterator VariableConstIterator;
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    const VariableSequence&
    getVariable () const;

    VariableSequence&
    getVariable ();

    void
    setVariable (const VariableSequence& s);

    // binary_operation
    //
    typedef ::poosl::T_binary_operation Binary_operationType;
    typedef ::xsd::cxx::tree::sequence< Binary_operationType > Binary_operationSequence;
    typedef Binary_operationSequence::iterator Binary_operationIterator;
    typedef Binary_operationSequence::const_iterator Binary_operationConstIterator;
    typedef ::xsd::cxx::tree::traits< Binary_operationType, char > Binary_operationTraits;

    const Binary_operationSequence&
    getBinary_operation () const;

    Binary_operationSequence&
    getBinary_operation ();

    void
    setBinary_operation (const Binary_operationSequence& s);

    // unary_operation
    //
    typedef ::poosl::T_unary_operation Unary_operationType;
    typedef ::xsd::cxx::tree::sequence< Unary_operationType > Unary_operationSequence;
    typedef Unary_operationSequence::iterator Unary_operationIterator;
    typedef Unary_operationSequence::const_iterator Unary_operationConstIterator;
    typedef ::xsd::cxx::tree::traits< Unary_operationType, char > Unary_operationTraits;

    const Unary_operationSequence&
    getUnary_operation () const;

    Unary_operationSequence&
    getUnary_operation ();

    void
    setUnary_operation (const Unary_operationSequence& s);

    // self
    //
    typedef ::poosl::T_empty SelfType;
    typedef ::xsd::cxx::tree::sequence< SelfType > SelfSequence;
    typedef SelfSequence::iterator SelfIterator;
    typedef SelfSequence::const_iterator SelfConstIterator;
    typedef ::xsd::cxx::tree::traits< SelfType, char > SelfTraits;

    const SelfSequence&
    getSelf () const;

    SelfSequence&
    getSelf ();

    void
    setSelf (const SelfSequence& s);

    // nil
    //
    typedef ::poosl::T_empty NilType;
    typedef ::xsd::cxx::tree::sequence< NilType > NilSequence;
    typedef NilSequence::iterator NilIterator;
    typedef NilSequence::const_iterator NilConstIterator;
    typedef ::xsd::cxx::tree::traits< NilType, char > NilTraits;

    const NilSequence&
    getNil () const;

    NilSequence&
    getNil ();

    void
    setNil (const NilSequence& s);

    // current_time
    //
    typedef ::poosl::T_current_time Current_timeType;
    typedef ::xsd::cxx::tree::sequence< Current_timeType > Current_timeSequence;
    typedef Current_timeSequence::iterator Current_timeIterator;
    typedef Current_timeSequence::const_iterator Current_timeConstIterator;
    typedef ::xsd::cxx::tree::traits< Current_timeType, char > Current_timeTraits;

    const Current_timeSequence&
    getCurrent_time () const;

    Current_timeSequence&
    getCurrent_time ();

    void
    setCurrent_time (const Current_timeSequence& s);

    // if
    //
    typedef ::poosl::T_if_expression IfType;
    typedef ::xsd::cxx::tree::sequence< IfType > IfSequence;
    typedef IfSequence::iterator IfIterator;
    typedef IfSequence::const_iterator IfConstIterator;
    typedef ::xsd::cxx::tree::traits< IfType, char > IfTraits;

    const IfSequence&
    getIf () const;

    IfSequence&
    getIf ();

    void
    setIf (const IfSequence& s);

    // while
    //
    typedef ::poosl::T_while_expression WhileType;
    typedef ::xsd::cxx::tree::sequence< WhileType > WhileSequence;
    typedef WhileSequence::iterator WhileIterator;
    typedef WhileSequence::const_iterator WhileConstIterator;
    typedef ::xsd::cxx::tree::traits< WhileType, char > WhileTraits;

    const WhileSequence&
    getWhile () const;

    WhileSequence&
    getWhile ();

    void
    setWhile (const WhileSequence& s);

    // new
    //
    typedef ::poosl::T_object_creation NewType;
    typedef ::xsd::cxx::tree::sequence< NewType > NewSequence;
    typedef NewSequence::iterator NewIterator;
    typedef NewSequence::const_iterator NewConstIterator;
    typedef ::xsd::cxx::tree::traits< NewType, char > NewTraits;

    const NewSequence&
    getNew () const;

    NewSequence&
    getNew ();

    void
    setNew (const NewSequence& s);

    // return
    //
    typedef ::poosl::T_expression ReturnType;
    typedef ::xsd::cxx::tree::sequence< ReturnType > ReturnSequence;
    typedef ReturnSequence::iterator ReturnIterator;
    typedef ReturnSequence::const_iterator ReturnConstIterator;
    typedef ::xsd::cxx::tree::traits< ReturnType, char > ReturnTraits;

    const ReturnSequence&
    getReturn () const;

    ReturnSequence&
    getReturn ();

    void
    setReturn (const ReturnSequence& s);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_expressions ();

    T_expressions (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    T_expressions (const T_expressions& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual T_expressions*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_expressions&
    operator= (const T_expressions& x);

    virtual 
    ~T_expressions ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Sequence_of_expressionsSequence sequence_of_expressions_;
    AssignmentSequence assignment_;
    Data_method_callSequence data_method_call_;
    ConstantSequence constant_;
    VariableSequence variable_;
    Binary_operationSequence binary_operation_;
    Unary_operationSequence unary_operation_;
    SelfSequence self_;
    NilSequence nil_;
    Current_timeSequence current_time_;
    IfSequence if__;
    WhileSequence while__;
    NewSequence new__;
    ReturnSequence return__;
    Stmt_handleOptional stmt_handle_;
  };

  class T_expression: public ::poosl::T_expressions
  {
    public:
    // Constructors.
    //
    T_expression ();

    T_expression (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    T_expression (const T_expression& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual T_expression*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_expression ();
  };

  class T_assignment: public ::poosl::T_expression
  {
    public:
    // variable_name
    //
    typedef ::poosl::T_variable_name Variable_nameType;
    typedef ::xsd::cxx::tree::traits< Variable_nameType, char > Variable_nameTraits;

    const Variable_nameType&
    getVariable_name () const;

    Variable_nameType&
    getVariable_name ();

    void
    setVariable_name (const Variable_nameType& x);

    void
    setVariable_name (::std::unique_ptr< Variable_nameType > p);

    // Constructors.
    //
    T_assignment ();

    T_assignment (const Variable_nameType&);

    T_assignment (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    T_assignment (const T_assignment& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual T_assignment*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_assignment&
    operator= (const T_assignment& x);

    virtual 
    ~T_assignment ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Variable_nameType > variable_name_;
  };

  class T_data_method_call: public ::xml_schema::Type
  {
    public:
    // receiver
    //
    typedef ::poosl::T_expression ReceiverType;
    typedef ::xsd::cxx::tree::traits< ReceiverType, char > ReceiverTraits;

    const ReceiverType&
    getReceiver () const;

    ReceiverType&
    getReceiver ();

    void
    setReceiver (const ReceiverType& x);

    void
    setReceiver (::std::unique_ptr< ReceiverType > p);

    // argument
    //
    typedef ::poosl::T_expression ArgumentType;
    typedef ::xsd::cxx::tree::sequence< ArgumentType > ArgumentSequence;
    typedef ArgumentSequence::iterator ArgumentIterator;
    typedef ArgumentSequence::const_iterator ArgumentConstIterator;
    typedef ::xsd::cxx::tree::traits< ArgumentType, char > ArgumentTraits;

    const ArgumentSequence&
    getArgument () const;

    ArgumentSequence&
    getArgument ();

    void
    setArgument (const ArgumentSequence& s);

    // method_name
    //
    typedef ::poosl::T_data_method_name Method_nameType;
    typedef ::xsd::cxx::tree::traits< Method_nameType, char > Method_nameTraits;

    const Method_nameType&
    getMethod_name () const;

    Method_nameType&
    getMethod_name ();

    void
    setMethod_name (const Method_nameType& x);

    void
    setMethod_name (::std::unique_ptr< Method_nameType > p);

    // super
    //
    typedef ::poosl::T_boolean SuperType;
    typedef ::xsd::cxx::tree::traits< SuperType, char > SuperTraits;

    const SuperType&
    getSuper () const;

    SuperType&
    getSuper ();

    void
    setSuper (const SuperType& x);

    void
    setSuper (::std::unique_ptr< SuperType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_data_method_call ();

    T_data_method_call (const ReceiverType&,
                        const Method_nameType&,
                        const SuperType&);

    T_data_method_call (::std::unique_ptr< ReceiverType >,
                        const Method_nameType&,
                        const SuperType&);

    T_data_method_call (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_data_method_call (const T_data_method_call& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_data_method_call*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_data_method_call&
    operator= (const T_data_method_call& x);

    virtual 
    ~T_data_method_call ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ReceiverType > receiver_;
    ArgumentSequence argument_;
    ::xsd::cxx::tree::one< Method_nameType > method_name_;
    ::xsd::cxx::tree::one< SuperType > super_;
    Stmt_handleOptional stmt_handle_;
  };

  class T_constant: public ::xml_schema::String
  {
    public:
    // type
    //
    typedef ::poosl::T_constant_type TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    getType () const;

    TypeOptional&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (const TypeOptional& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // Constructors.
    //
    T_constant ();

    T_constant (const char*);

    T_constant (const ::std::string&);

    T_constant (const ::xml_schema::String&);

    T_constant (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    T_constant (const T_constant& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual T_constant*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_constant&
    operator= (const T_constant& x);

    virtual 
    ~T_constant ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TypeOptional type_;
  };

  class T_current_time: public ::xml_schema::Type
  {
    public:
    // Constructors.
    //
    T_current_time ();

    T_current_time (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_current_time (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_current_time (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_current_time (const T_current_time& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual T_current_time*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_current_time ();
  };

  class T_variable_ref: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::poosl::T_variable_name NameType;
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameOptional&
    getName () const;

    NameOptional&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (const NameOptional& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // Constructors.
    //
    T_variable_ref ();

    T_variable_ref (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_variable_ref (const T_variable_ref& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual T_variable_ref*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_variable_ref&
    operator= (const T_variable_ref& x);

    virtual 
    ~T_variable_ref ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NameOptional name_;
  };

  class T_binary_operation: public ::xml_schema::Type
  {
    public:
    // left_operand
    //
    typedef ::poosl::T_expression Left_operandType;
    typedef ::xsd::cxx::tree::traits< Left_operandType, char > Left_operandTraits;

    const Left_operandType&
    getLeft_operand () const;

    Left_operandType&
    getLeft_operand ();

    void
    setLeft_operand (const Left_operandType& x);

    void
    setLeft_operand (::std::unique_ptr< Left_operandType > p);

    // right_operand
    //
    typedef ::poosl::T_expression Right_operandType;
    typedef ::xsd::cxx::tree::traits< Right_operandType, char > Right_operandTraits;

    const Right_operandType&
    getRight_operand () const;

    Right_operandType&
    getRight_operand ();

    void
    setRight_operand (const Right_operandType& x);

    void
    setRight_operand (::std::unique_ptr< Right_operandType > p);

    // operator
    //
    typedef ::poosl::T_binary_operator OperatorType;
    typedef ::xsd::cxx::tree::optional< OperatorType > OperatorOptional;
    typedef ::xsd::cxx::tree::traits< OperatorType, char > OperatorTraits;

    const OperatorOptional&
    getOperator () const;

    OperatorOptional&
    getOperator ();

    void
    setOperator (const OperatorType& x);

    void
    setOperator (const OperatorOptional& x);

    void
    setOperator (::std::unique_ptr< OperatorType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_binary_operation ();

    T_binary_operation (const Left_operandType&,
                        const Right_operandType&);

    T_binary_operation (::std::unique_ptr< Left_operandType >,
                        ::std::unique_ptr< Right_operandType >);

    T_binary_operation (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_binary_operation (const T_binary_operation& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_binary_operation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_binary_operation&
    operator= (const T_binary_operation& x);

    virtual 
    ~T_binary_operation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Left_operandType > left_operand_;
    ::xsd::cxx::tree::one< Right_operandType > right_operand_;
    OperatorOptional operator__;
    Stmt_handleOptional stmt_handle_;
  };

  class T_unary_operation: public ::xml_schema::Type
  {
    public:
    // operand
    //
    typedef ::poosl::T_expression OperandType;
    typedef ::xsd::cxx::tree::traits< OperandType, char > OperandTraits;

    const OperandType&
    getOperand () const;

    OperandType&
    getOperand ();

    void
    setOperand (const OperandType& x);

    void
    setOperand (::std::unique_ptr< OperandType > p);

    // operator
    //
    typedef ::poosl::T_unary_operator OperatorType;
    typedef ::xsd::cxx::tree::optional< OperatorType > OperatorOptional;
    typedef ::xsd::cxx::tree::traits< OperatorType, char > OperatorTraits;

    const OperatorOptional&
    getOperator () const;

    OperatorOptional&
    getOperator ();

    void
    setOperator (const OperatorType& x);

    void
    setOperator (const OperatorOptional& x);

    void
    setOperator (::std::unique_ptr< OperatorType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_unary_operation ();

    T_unary_operation (const OperandType&);

    T_unary_operation (::std::unique_ptr< OperandType >);

    T_unary_operation (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_unary_operation (const T_unary_operation& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_unary_operation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_unary_operation&
    operator= (const T_unary_operation& x);

    virtual 
    ~T_unary_operation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< OperandType > operand_;
    OperatorOptional operator__;
    Stmt_handleOptional stmt_handle_;
  };

  class T_if_expression: public ::xml_schema::Type
  {
    public:
    // condition
    //
    typedef ::poosl::T_expression ConditionType;
    typedef ::xsd::cxx::tree::traits< ConditionType, char > ConditionTraits;

    const ConditionType&
    getCondition () const;

    ConditionType&
    getCondition ();

    void
    setCondition (const ConditionType& x);

    void
    setCondition (::std::unique_ptr< ConditionType > p);

    // then
    //
    typedef ::poosl::T_expression ThenType;
    typedef ::xsd::cxx::tree::traits< ThenType, char > ThenTraits;

    const ThenType&
    getThen () const;

    ThenType&
    getThen ();

    void
    setThen (const ThenType& x);

    void
    setThen (::std::unique_ptr< ThenType > p);

    // else
    //
    typedef ::poosl::T_expression ElseType;
    typedef ::xsd::cxx::tree::optional< ElseType > ElseOptional;
    typedef ::xsd::cxx::tree::traits< ElseType, char > ElseTraits;

    const ElseOptional&
    getElse () const;

    ElseOptional&
    getElse ();

    void
    setElse (const ElseType& x);

    void
    setElse (const ElseOptional& x);

    void
    setElse (::std::unique_ptr< ElseType > p);

    // Constructors.
    //
    T_if_expression ();

    T_if_expression (const ConditionType&,
                     const ThenType&);

    T_if_expression (::std::unique_ptr< ConditionType >,
                     ::std::unique_ptr< ThenType >);

    T_if_expression (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_if_expression (const T_if_expression& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual T_if_expression*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_if_expression&
    operator= (const T_if_expression& x);

    virtual 
    ~T_if_expression ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ConditionType > condition_;
    ::xsd::cxx::tree::one< ThenType > then_;
    ElseOptional else__;
  };

  class T_while_expression: public ::xml_schema::Type
  {
    public:
    // condition
    //
    typedef ::poosl::T_expression ConditionType;
    typedef ::xsd::cxx::tree::traits< ConditionType, char > ConditionTraits;

    const ConditionType&
    getCondition () const;

    ConditionType&
    getCondition ();

    void
    setCondition (const ConditionType& x);

    void
    setCondition (::std::unique_ptr< ConditionType > p);

    // body
    //
    typedef ::poosl::T_expression BodyType;
    typedef ::xsd::cxx::tree::traits< BodyType, char > BodyTraits;

    const BodyType&
    getBody () const;

    BodyType&
    getBody ();

    void
    setBody (const BodyType& x);

    void
    setBody (::std::unique_ptr< BodyType > p);

    // Constructors.
    //
    T_while_expression ();

    T_while_expression (const ConditionType&,
                        const BodyType&);

    T_while_expression (::std::unique_ptr< ConditionType >,
                        ::std::unique_ptr< BodyType >);

    T_while_expression (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_while_expression (const T_while_expression& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_while_expression*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_while_expression&
    operator= (const T_while_expression& x);

    virtual 
    ~T_while_expression ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ConditionType > condition_;
    ::xsd::cxx::tree::one< BodyType > body_;
  };

  class T_object_creation: public ::xml_schema::Type
  {
    public:
    // data_class
    //
    typedef ::poosl::T_class_name Data_classType;
    typedef ::xsd::cxx::tree::optional< Data_classType > Data_classOptional;
    typedef ::xsd::cxx::tree::traits< Data_classType, char > Data_classTraits;

    const Data_classOptional&
    getData_class () const;

    Data_classOptional&
    getData_class ();

    void
    setData_class (const Data_classType& x);

    void
    setData_class (const Data_classOptional& x);

    void
    setData_class (::std::unique_ptr< Data_classType > p);

    // Constructors.
    //
    T_object_creation ();

    T_object_creation (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_object_creation (const T_object_creation& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_object_creation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_object_creation&
    operator= (const T_object_creation& x);

    virtual 
    ~T_object_creation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Data_classOptional data_class_;
  };

  class T_statements: public ::xml_schema::Type
  {
    public:
    // sequence_of_statements
    //
    typedef ::poosl::T_statements Sequence_of_statementsType;
    typedef ::xsd::cxx::tree::sequence< Sequence_of_statementsType > Sequence_of_statementsSequence;
    typedef Sequence_of_statementsSequence::iterator Sequence_of_statementsIterator;
    typedef Sequence_of_statementsSequence::const_iterator Sequence_of_statementsConstIterator;
    typedef ::xsd::cxx::tree::traits< Sequence_of_statementsType, char > Sequence_of_statementsTraits;

    const Sequence_of_statementsSequence&
    getSequence_of_statements () const;

    Sequence_of_statementsSequence&
    getSequence_of_statements ();

    void
    setSequence_of_statements (const Sequence_of_statementsSequence& s);

    // parallel_statements
    //
    typedef ::poosl::T_statements Parallel_statementsType;
    typedef ::xsd::cxx::tree::sequence< Parallel_statementsType > Parallel_statementsSequence;
    typedef Parallel_statementsSequence::iterator Parallel_statementsIterator;
    typedef Parallel_statementsSequence::const_iterator Parallel_statementsConstIterator;
    typedef ::xsd::cxx::tree::traits< Parallel_statementsType, char > Parallel_statementsTraits;

    const Parallel_statementsSequence&
    getParallel_statements () const;

    Parallel_statementsSequence&
    getParallel_statements ();

    void
    setParallel_statements (const Parallel_statementsSequence& s);

    // select_statements
    //
    typedef ::poosl::T_statements Select_statementsType;
    typedef ::xsd::cxx::tree::sequence< Select_statementsType > Select_statementsSequence;
    typedef Select_statementsSequence::iterator Select_statementsIterator;
    typedef Select_statementsSequence::const_iterator Select_statementsConstIterator;
    typedef ::xsd::cxx::tree::traits< Select_statementsType, char > Select_statementsTraits;

    const Select_statementsSequence&
    getSelect_statements () const;

    Select_statementsSequence&
    getSelect_statements ();

    void
    setSelect_statements (const Select_statementsSequence& s);

    // expression
    //
    typedef ::poosl::T_expression ExpressionType;
    typedef ::xsd::cxx::tree::sequence< ExpressionType > ExpressionSequence;
    typedef ExpressionSequence::iterator ExpressionIterator;
    typedef ExpressionSequence::const_iterator ExpressionConstIterator;
    typedef ::xsd::cxx::tree::traits< ExpressionType, char > ExpressionTraits;

    const ExpressionSequence&
    getExpression () const;

    ExpressionSequence&
    getExpression ();

    void
    setExpression (const ExpressionSequence& s);

    // process_method_call
    //
    typedef ::poosl::T_process_method_call Process_method_callType;
    typedef ::xsd::cxx::tree::sequence< Process_method_callType > Process_method_callSequence;
    typedef Process_method_callSequence::iterator Process_method_callIterator;
    typedef Process_method_callSequence::const_iterator Process_method_callConstIterator;
    typedef ::xsd::cxx::tree::traits< Process_method_callType, char > Process_method_callTraits;

    const Process_method_callSequence&
    getProcess_method_call () const;

    Process_method_callSequence&
    getProcess_method_call ();

    void
    setProcess_method_call (const Process_method_callSequence& s);

    // message_send
    //
    typedef ::poosl::T_message_send Message_sendType;
    typedef ::xsd::cxx::tree::sequence< Message_sendType > Message_sendSequence;
    typedef Message_sendSequence::iterator Message_sendIterator;
    typedef Message_sendSequence::const_iterator Message_sendConstIterator;
    typedef ::xsd::cxx::tree::traits< Message_sendType, char > Message_sendTraits;

    const Message_sendSequence&
    getMessage_send () const;

    Message_sendSequence&
    getMessage_send ();

    void
    setMessage_send (const Message_sendSequence& s);

    // message_receive
    //
    typedef ::poosl::T_message_receive Message_receiveType;
    typedef ::xsd::cxx::tree::sequence< Message_receiveType > Message_receiveSequence;
    typedef Message_receiveSequence::iterator Message_receiveIterator;
    typedef Message_receiveSequence::const_iterator Message_receiveConstIterator;
    typedef ::xsd::cxx::tree::traits< Message_receiveType, char > Message_receiveTraits;

    const Message_receiveSequence&
    getMessage_receive () const;

    Message_receiveSequence&
    getMessage_receive ();

    void
    setMessage_receive (const Message_receiveSequence& s);

    // guard
    //
    typedef ::poosl::T_guard GuardType;
    typedef ::xsd::cxx::tree::sequence< GuardType > GuardSequence;
    typedef GuardSequence::iterator GuardIterator;
    typedef GuardSequence::const_iterator GuardConstIterator;
    typedef ::xsd::cxx::tree::traits< GuardType, char > GuardTraits;

    const GuardSequence&
    getGuard () const;

    GuardSequence&
    getGuard ();

    void
    setGuard (const GuardSequence& s);

    // if
    //
    typedef ::poosl::T_if_statement IfType;
    typedef ::xsd::cxx::tree::sequence< IfType > IfSequence;
    typedef IfSequence::iterator IfIterator;
    typedef IfSequence::const_iterator IfConstIterator;
    typedef ::xsd::cxx::tree::traits< IfType, char > IfTraits;

    const IfSequence&
    getIf () const;

    IfSequence&
    getIf ();

    void
    setIf (const IfSequence& s);

    // while
    //
    typedef ::poosl::T_while_statement WhileType;
    typedef ::xsd::cxx::tree::sequence< WhileType > WhileSequence;
    typedef WhileSequence::iterator WhileIterator;
    typedef WhileSequence::const_iterator WhileConstIterator;
    typedef ::xsd::cxx::tree::traits< WhileType, char > WhileTraits;

    const WhileSequence&
    getWhile () const;

    WhileSequence&
    getWhile ();

    void
    setWhile (const WhileSequence& s);

    // switch
    //
    typedef ::poosl::T_switch_statement SwitchType;
    typedef ::xsd::cxx::tree::sequence< SwitchType > SwitchSequence;
    typedef SwitchSequence::iterator SwitchIterator;
    typedef SwitchSequence::const_iterator SwitchConstIterator;
    typedef ::xsd::cxx::tree::traits< SwitchType, char > SwitchTraits;

    const SwitchSequence&
    getSwitch () const;

    SwitchSequence&
    getSwitch ();

    void
    setSwitch (const SwitchSequence& s);

    // abort
    //
    typedef ::poosl::T_abort AbortType;
    typedef ::xsd::cxx::tree::sequence< AbortType > AbortSequence;
    typedef AbortSequence::iterator AbortIterator;
    typedef AbortSequence::const_iterator AbortConstIterator;
    typedef ::xsd::cxx::tree::traits< AbortType, char > AbortTraits;

    const AbortSequence&
    getAbort () const;

    AbortSequence&
    getAbort ();

    void
    setAbort (const AbortSequence& s);

    // interrupt
    //
    typedef ::poosl::T_interrupt InterruptType;
    typedef ::xsd::cxx::tree::sequence< InterruptType > InterruptSequence;
    typedef InterruptSequence::iterator InterruptIterator;
    typedef InterruptSequence::const_iterator InterruptConstIterator;
    typedef ::xsd::cxx::tree::traits< InterruptType, char > InterruptTraits;

    const InterruptSequence&
    getInterrupt () const;

    InterruptSequence&
    getInterrupt ();

    void
    setInterrupt (const InterruptSequence& s);

    // skip
    //
    typedef ::poosl::T_empty SkipType;
    typedef ::xsd::cxx::tree::sequence< SkipType > SkipSequence;
    typedef SkipSequence::iterator SkipIterator;
    typedef SkipSequence::const_iterator SkipConstIterator;
    typedef ::xsd::cxx::tree::traits< SkipType, char > SkipTraits;

    const SkipSequence&
    getSkip () const;

    SkipSequence&
    getSkip ();

    void
    setSkip (const SkipSequence& s);

    // delay
    //
    typedef ::poosl::T_expression DelayType;
    typedef ::xsd::cxx::tree::sequence< DelayType > DelaySequence;
    typedef DelaySequence::iterator DelayIterator;
    typedef DelaySequence::const_iterator DelayConstIterator;
    typedef ::xsd::cxx::tree::traits< DelayType, char > DelayTraits;

    const DelaySequence&
    getDelay () const;

    DelaySequence&
    getDelay ();

    void
    setDelay (const DelaySequence& s);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_statements ();

    T_statements (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    T_statements (const T_statements& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual T_statements*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_statements&
    operator= (const T_statements& x);

    virtual 
    ~T_statements ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Sequence_of_statementsSequence sequence_of_statements_;
    Parallel_statementsSequence parallel_statements_;
    Select_statementsSequence select_statements_;
    ExpressionSequence expression_;
    Process_method_callSequence process_method_call_;
    Message_sendSequence message_send_;
    Message_receiveSequence message_receive_;
    GuardSequence guard_;
    IfSequence if__;
    WhileSequence while__;
    SwitchSequence switch__;
    AbortSequence abort_;
    InterruptSequence interrupt_;
    SkipSequence skip_;
    DelaySequence delay_;
    Stmt_handleOptional stmt_handle_;
  };

  class T_statement: public ::poosl::T_statements
  {
    public:
    // Constructors.
    //
    T_statement ();

    T_statement (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    T_statement (const T_statement& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual T_statement*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_statement ();
  };

  class T_process_method_call: public ::xml_schema::Type
  {
    public:
    // argument
    //
    typedef ::poosl::T_expression ArgumentType;
    typedef ::xsd::cxx::tree::sequence< ArgumentType > ArgumentSequence;
    typedef ArgumentSequence::iterator ArgumentIterator;
    typedef ArgumentSequence::const_iterator ArgumentConstIterator;
    typedef ::xsd::cxx::tree::traits< ArgumentType, char > ArgumentTraits;

    const ArgumentSequence&
    getArgument () const;

    ArgumentSequence&
    getArgument ();

    void
    setArgument (const ArgumentSequence& s);

    // return_variable
    //
    typedef ::poosl::T_variable_name Return_variableType;
    typedef ::xsd::cxx::tree::sequence< Return_variableType > Return_variableSequence;
    typedef Return_variableSequence::iterator Return_variableIterator;
    typedef Return_variableSequence::const_iterator Return_variableConstIterator;
    typedef ::xsd::cxx::tree::traits< Return_variableType, char > Return_variableTraits;

    const Return_variableSequence&
    getReturn_variable () const;

    Return_variableSequence&
    getReturn_variable ();

    void
    setReturn_variable (const Return_variableSequence& s);

    // method_name
    //
    typedef ::poosl::T_method_name Method_nameType;
    typedef ::xsd::cxx::tree::traits< Method_nameType, char > Method_nameTraits;

    const Method_nameType&
    getMethod_name () const;

    Method_nameType&
    getMethod_name ();

    void
    setMethod_name (const Method_nameType& x);

    void
    setMethod_name (::std::unique_ptr< Method_nameType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_process_method_call ();

    T_process_method_call (const Method_nameType&);

    T_process_method_call (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_process_method_call (const T_process_method_call& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual T_process_method_call*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_process_method_call&
    operator= (const T_process_method_call& x);

    virtual 
    ~T_process_method_call ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ArgumentSequence argument_;
    Return_variableSequence return_variable_;
    ::xsd::cxx::tree::one< Method_nameType > method_name_;
    Stmt_handleOptional stmt_handle_;
  };

  class T_initial_process_method_call: public ::poosl::T_process_method_call
  {
    public:
    // Constructors.
    //
    T_initial_process_method_call ();

    T_initial_process_method_call (const ::poosl::T_process_method_call&);

    T_initial_process_method_call (const Method_nameType&);

    T_initial_process_method_call (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    T_initial_process_method_call (const T_initial_process_method_call& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    virtual T_initial_process_method_call*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_initial_process_method_call ();
  };

  class T_message_receive: public ::xml_schema::Type
  {
    public:
    // variable
    //
    typedef ::poosl::T_variable_name VariableType;
    typedef ::xsd::cxx::tree::sequence< VariableType > VariableSequence;
    typedef VariableSequence::iterator VariableIterator;
    typedef VariableSequence::const_iterator VariableConstIterator;
    typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

    const VariableSequence&
    getVariable () const;

    VariableSequence&
    getVariable ();

    void
    setVariable (const VariableSequence& s);

    // condition
    //
    typedef ::poosl::T_expression ConditionType;
    typedef ::xsd::cxx::tree::optional< ConditionType > ConditionOptional;
    typedef ::xsd::cxx::tree::traits< ConditionType, char > ConditionTraits;

    const ConditionOptional&
    getCondition () const;

    ConditionOptional&
    getCondition ();

    void
    setCondition (const ConditionType& x);

    void
    setCondition (const ConditionOptional& x);

    void
    setCondition (::std::unique_ptr< ConditionType > p);

    // atomic_expression
    //
    typedef ::poosl::T_expression Atomic_expressionType;
    typedef ::xsd::cxx::tree::optional< Atomic_expressionType > Atomic_expressionOptional;
    typedef ::xsd::cxx::tree::traits< Atomic_expressionType, char > Atomic_expressionTraits;

    const Atomic_expressionOptional&
    getAtomic_expression () const;

    Atomic_expressionOptional&
    getAtomic_expression ();

    void
    setAtomic_expression (const Atomic_expressionType& x);

    void
    setAtomic_expression (const Atomic_expressionOptional& x);

    void
    setAtomic_expression (::std::unique_ptr< Atomic_expressionType > p);

    // port
    //
    typedef ::poosl::T_port_name PortType;
    typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

    const PortType&
    getPort () const;

    PortType&
    getPort ();

    void
    setPort (const PortType& x);

    void
    setPort (::std::unique_ptr< PortType > p);

    // message_name
    //
    typedef ::poosl::T_message_name Message_nameType;
    typedef ::xsd::cxx::tree::optional< Message_nameType > Message_nameOptional;
    typedef ::xsd::cxx::tree::traits< Message_nameType, char > Message_nameTraits;

    const Message_nameOptional&
    getMessage_name () const;

    Message_nameOptional&
    getMessage_name ();

    void
    setMessage_name (const Message_nameType& x);

    void
    setMessage_name (const Message_nameOptional& x);

    void
    setMessage_name (::std::unique_ptr< Message_nameType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_message_receive ();

    T_message_receive (const PortType&);

    T_message_receive (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_message_receive (const T_message_receive& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_message_receive*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_message_receive&
    operator= (const T_message_receive& x);

    virtual 
    ~T_message_receive ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    VariableSequence variable_;
    ConditionOptional condition_;
    Atomic_expressionOptional atomic_expression_;
    ::xsd::cxx::tree::one< PortType > port_;
    Message_nameOptional message_name_;
    Stmt_handleOptional stmt_handle_;
  };

  class T_message_send: public ::xml_schema::Type
  {
    public:
    // argument
    //
    typedef ::poosl::T_expression ArgumentType;
    typedef ::xsd::cxx::tree::sequence< ArgumentType > ArgumentSequence;
    typedef ArgumentSequence::iterator ArgumentIterator;
    typedef ArgumentSequence::const_iterator ArgumentConstIterator;
    typedef ::xsd::cxx::tree::traits< ArgumentType, char > ArgumentTraits;

    const ArgumentSequence&
    getArgument () const;

    ArgumentSequence&
    getArgument ();

    void
    setArgument (const ArgumentSequence& s);

    // atomic_expression
    //
    typedef ::poosl::T_expression Atomic_expressionType;
    typedef ::xsd::cxx::tree::optional< Atomic_expressionType > Atomic_expressionOptional;
    typedef ::xsd::cxx::tree::traits< Atomic_expressionType, char > Atomic_expressionTraits;

    const Atomic_expressionOptional&
    getAtomic_expression () const;

    Atomic_expressionOptional&
    getAtomic_expression ();

    void
    setAtomic_expression (const Atomic_expressionType& x);

    void
    setAtomic_expression (const Atomic_expressionOptional& x);

    void
    setAtomic_expression (::std::unique_ptr< Atomic_expressionType > p);

    // port
    //
    typedef ::poosl::T_port_name PortType;
    typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

    const PortType&
    getPort () const;

    PortType&
    getPort ();

    void
    setPort (const PortType& x);

    void
    setPort (::std::unique_ptr< PortType > p);

    // message_name
    //
    typedef ::poosl::T_message_name Message_nameType;
    typedef ::xsd::cxx::tree::optional< Message_nameType > Message_nameOptional;
    typedef ::xsd::cxx::tree::traits< Message_nameType, char > Message_nameTraits;

    const Message_nameOptional&
    getMessage_name () const;

    Message_nameOptional&
    getMessage_name ();

    void
    setMessage_name (const Message_nameType& x);

    void
    setMessage_name (const Message_nameOptional& x);

    void
    setMessage_name (::std::unique_ptr< Message_nameType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_message_send ();

    T_message_send (const PortType&);

    T_message_send (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_message_send (const T_message_send& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual T_message_send*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_message_send&
    operator= (const T_message_send& x);

    virtual 
    ~T_message_send ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ArgumentSequence argument_;
    Atomic_expressionOptional atomic_expression_;
    ::xsd::cxx::tree::one< PortType > port_;
    Message_nameOptional message_name_;
    Stmt_handleOptional stmt_handle_;
  };

  class T_guard: public ::xml_schema::Type
  {
    public:
    // expression
    //
    typedef ::poosl::T_expression ExpressionType;
    typedef ::xsd::cxx::tree::traits< ExpressionType, char > ExpressionTraits;

    const ExpressionType&
    getExpression () const;

    ExpressionType&
    getExpression ();

    void
    setExpression (const ExpressionType& x);

    void
    setExpression (::std::unique_ptr< ExpressionType > p);

    // statement
    //
    typedef ::poosl::T_statement StatementType;
    typedef ::xsd::cxx::tree::traits< StatementType, char > StatementTraits;

    const StatementType&
    getStatement () const;

    StatementType&
    getStatement ();

    void
    setStatement (const StatementType& x);

    void
    setStatement (::std::unique_ptr< StatementType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_guard ();

    T_guard (const ExpressionType&,
             const StatementType&);

    T_guard (::std::unique_ptr< ExpressionType >,
             ::std::unique_ptr< StatementType >);

    T_guard (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    T_guard (const T_guard& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    virtual T_guard*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_guard&
    operator= (const T_guard& x);

    virtual 
    ~T_guard ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ExpressionType > expression_;
    ::xsd::cxx::tree::one< StatementType > statement_;
    Stmt_handleOptional stmt_handle_;
  };

  class T_if_statement: public ::xml_schema::Type
  {
    public:
    // condition
    //
    typedef ::poosl::T_expression ConditionType;
    typedef ::xsd::cxx::tree::traits< ConditionType, char > ConditionTraits;

    const ConditionType&
    getCondition () const;

    ConditionType&
    getCondition ();

    void
    setCondition (const ConditionType& x);

    void
    setCondition (::std::unique_ptr< ConditionType > p);

    // then
    //
    typedef ::poosl::T_statement ThenType;
    typedef ::xsd::cxx::tree::traits< ThenType, char > ThenTraits;

    const ThenType&
    getThen () const;

    ThenType&
    getThen ();

    void
    setThen (const ThenType& x);

    void
    setThen (::std::unique_ptr< ThenType > p);

    // else
    //
    typedef ::poosl::T_statement ElseType;
    typedef ::xsd::cxx::tree::optional< ElseType > ElseOptional;
    typedef ::xsd::cxx::tree::traits< ElseType, char > ElseTraits;

    const ElseOptional&
    getElse () const;

    ElseOptional&
    getElse ();

    void
    setElse (const ElseType& x);

    void
    setElse (const ElseOptional& x);

    void
    setElse (::std::unique_ptr< ElseType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_if_statement ();

    T_if_statement (const ConditionType&,
                    const ThenType&);

    T_if_statement (::std::unique_ptr< ConditionType >,
                    ::std::unique_ptr< ThenType >);

    T_if_statement (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_if_statement (const T_if_statement& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual T_if_statement*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_if_statement&
    operator= (const T_if_statement& x);

    virtual 
    ~T_if_statement ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ConditionType > condition_;
    ::xsd::cxx::tree::one< ThenType > then_;
    ElseOptional else__;
    Stmt_handleOptional stmt_handle_;
  };

  class T_while_statement: public ::xml_schema::Type
  {
    public:
    // condition
    //
    typedef ::poosl::T_expression ConditionType;
    typedef ::xsd::cxx::tree::traits< ConditionType, char > ConditionTraits;

    const ConditionType&
    getCondition () const;

    ConditionType&
    getCondition ();

    void
    setCondition (const ConditionType& x);

    void
    setCondition (::std::unique_ptr< ConditionType > p);

    // body
    //
    typedef ::poosl::T_statement BodyType;
    typedef ::xsd::cxx::tree::traits< BodyType, char > BodyTraits;

    const BodyType&
    getBody () const;

    BodyType&
    getBody ();

    void
    setBody (const BodyType& x);

    void
    setBody (::std::unique_ptr< BodyType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_while_statement ();

    T_while_statement (const ConditionType&,
                       const BodyType&);

    T_while_statement (::std::unique_ptr< ConditionType >,
                       ::std::unique_ptr< BodyType >);

    T_while_statement (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_while_statement (const T_while_statement& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_while_statement*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_while_statement&
    operator= (const T_while_statement& x);

    virtual 
    ~T_while_statement ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ConditionType > condition_;
    ::xsd::cxx::tree::one< BodyType > body_;
    Stmt_handleOptional stmt_handle_;
  };

  class T_switch_statement: public ::xml_schema::Type
  {
    public:
    // control_expression
    //
    typedef ::poosl::T_expression Control_expressionType;
    typedef ::xsd::cxx::tree::traits< Control_expressionType, char > Control_expressionTraits;

    const Control_expressionType&
    getControl_expression () const;

    Control_expressionType&
    getControl_expression ();

    void
    setControl_expression (const Control_expressionType& x);

    void
    setControl_expression (::std::unique_ptr< Control_expressionType > p);

    // case
    //
    typedef ::poosl::T_switch_case_statement CaseType;
    typedef ::xsd::cxx::tree::sequence< CaseType > CaseSequence;
    typedef CaseSequence::iterator CaseIterator;
    typedef CaseSequence::const_iterator CaseConstIterator;
    typedef ::xsd::cxx::tree::traits< CaseType, char > CaseTraits;

    const CaseSequence&
    getCase () const;

    CaseSequence&
    getCase ();

    void
    setCase (const CaseSequence& s);

    // default
    //
    typedef ::poosl::T_switch_case_statement DefaultType;
    typedef ::xsd::cxx::tree::sequence< DefaultType > DefaultSequence;
    typedef DefaultSequence::iterator DefaultIterator;
    typedef DefaultSequence::const_iterator DefaultConstIterator;
    typedef ::xsd::cxx::tree::traits< DefaultType, char > DefaultTraits;

    const DefaultSequence&
    getDefault () const;

    DefaultSequence&
    getDefault ();

    void
    setDefault (const DefaultSequence& s);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_switch_statement ();

    T_switch_statement (const Control_expressionType&);

    T_switch_statement (::std::unique_ptr< Control_expressionType >);

    T_switch_statement (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_switch_statement (const T_switch_statement& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_switch_statement*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_switch_statement&
    operator= (const T_switch_statement& x);

    virtual 
    ~T_switch_statement ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Control_expressionType > control_expression_;
    CaseSequence case__;
    DefaultSequence default__;
    Stmt_handleOptional stmt_handle_;
  };

  class T_switch_case_statement: public ::xml_schema::Type
  {
    public:
    // value_expression
    //
    typedef ::poosl::T_expression Value_expressionType;
    typedef ::xsd::cxx::tree::sequence< Value_expressionType > Value_expressionSequence;
    typedef Value_expressionSequence::iterator Value_expressionIterator;
    typedef Value_expressionSequence::const_iterator Value_expressionConstIterator;
    typedef ::xsd::cxx::tree::traits< Value_expressionType, char > Value_expressionTraits;

    const Value_expressionSequence&
    getValue_expression () const;

    Value_expressionSequence&
    getValue_expression ();

    void
    setValue_expression (const Value_expressionSequence& s);

    // body
    //
    typedef ::poosl::T_statement BodyType;
    typedef ::xsd::cxx::tree::traits< BodyType, char > BodyTraits;

    const BodyType&
    getBody () const;

    BodyType&
    getBody ();

    void
    setBody (const BodyType& x);

    void
    setBody (::std::unique_ptr< BodyType > p);

    // Constructors.
    //
    T_switch_case_statement ();

    T_switch_case_statement (const BodyType&);

    T_switch_case_statement (::std::unique_ptr< BodyType >);

    T_switch_case_statement (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    T_switch_case_statement (const T_switch_case_statement& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual T_switch_case_statement*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_switch_case_statement&
    operator= (const T_switch_case_statement& x);

    virtual 
    ~T_switch_case_statement ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Value_expressionSequence value_expression_;
    ::xsd::cxx::tree::one< BodyType > body_;
  };

  class T_abort: public ::xml_schema::Type
  {
    public:
    // normal_behavior
    //
    typedef ::poosl::T_statement Normal_behaviorType;
    typedef ::xsd::cxx::tree::traits< Normal_behaviorType, char > Normal_behaviorTraits;

    const Normal_behaviorType&
    getNormal_behavior () const;

    Normal_behaviorType&
    getNormal_behavior ();

    void
    setNormal_behavior (const Normal_behaviorType& x);

    void
    setNormal_behavior (::std::unique_ptr< Normal_behaviorType > p);

    // aborting_behavior
    //
    typedef ::poosl::T_statement Aborting_behaviorType;
    typedef ::xsd::cxx::tree::traits< Aborting_behaviorType, char > Aborting_behaviorTraits;

    const Aborting_behaviorType&
    getAborting_behavior () const;

    Aborting_behaviorType&
    getAborting_behavior ();

    void
    setAborting_behavior (const Aborting_behaviorType& x);

    void
    setAborting_behavior (::std::unique_ptr< Aborting_behaviorType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_abort ();

    T_abort (const Normal_behaviorType&,
             const Aborting_behaviorType&);

    T_abort (::std::unique_ptr< Normal_behaviorType >,
             ::std::unique_ptr< Aborting_behaviorType >);

    T_abort (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    T_abort (const T_abort& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    virtual T_abort*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_abort&
    operator= (const T_abort& x);

    virtual 
    ~T_abort ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Normal_behaviorType > normal_behavior_;
    ::xsd::cxx::tree::one< Aborting_behaviorType > aborting_behavior_;
    Stmt_handleOptional stmt_handle_;
  };

  class T_interrupt: public ::xml_schema::Type
  {
    public:
    // normal_behavior
    //
    typedef ::poosl::T_statement Normal_behaviorType;
    typedef ::xsd::cxx::tree::traits< Normal_behaviorType, char > Normal_behaviorTraits;

    const Normal_behaviorType&
    getNormal_behavior () const;

    Normal_behaviorType&
    getNormal_behavior ();

    void
    setNormal_behavior (const Normal_behaviorType& x);

    void
    setNormal_behavior (::std::unique_ptr< Normal_behaviorType > p);

    // interrupting_behavior
    //
    typedef ::poosl::T_statement Interrupting_behaviorType;
    typedef ::xsd::cxx::tree::traits< Interrupting_behaviorType, char > Interrupting_behaviorTraits;

    const Interrupting_behaviorType&
    getInterrupting_behavior () const;

    Interrupting_behaviorType&
    getInterrupting_behavior ();

    void
    setInterrupting_behavior (const Interrupting_behaviorType& x);

    void
    setInterrupting_behavior (::std::unique_ptr< Interrupting_behaviorType > p);

    // stmt_handle
    //
    typedef ::xml_schema::Int Stmt_handleType;
    typedef ::xsd::cxx::tree::optional< Stmt_handleType > Stmt_handleOptional;
    typedef ::xsd::cxx::tree::traits< Stmt_handleType, char > Stmt_handleTraits;

    const Stmt_handleOptional&
    getStmt_handle () const;

    Stmt_handleOptional&
    getStmt_handle ();

    void
    setStmt_handle (const Stmt_handleType& x);

    void
    setStmt_handle (const Stmt_handleOptional& x);

    // Constructors.
    //
    T_interrupt ();

    T_interrupt (const Normal_behaviorType&,
                 const Interrupting_behaviorType&);

    T_interrupt (::std::unique_ptr< Normal_behaviorType >,
                 ::std::unique_ptr< Interrupting_behaviorType >);

    T_interrupt (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    T_interrupt (const T_interrupt& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual T_interrupt*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_interrupt&
    operator= (const T_interrupt& x);

    virtual 
    ~T_interrupt ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Normal_behaviorType > normal_behavior_;
    ::xsd::cxx::tree::one< Interrupting_behaviorType > interrupting_behavior_;
    Stmt_handleOptional stmt_handle_;
  };
}

#include <iosfwd>

namespace poosl
{
  ::std::ostream&
  operator<< (::std::ostream&, T_constant_type::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_constant_type&);

  ::std::ostream&
  operator<< (::std::ostream&, T_binary_operator::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_binary_operator&);

  ::std::ostream&
  operator<< (::std::ostream&, T_unary_operator::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_unary_operator&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_expressions&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_expression&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_assignment&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_data_method_call&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_constant&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_current_time&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_variable_ref&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_binary_operation&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_unary_operation&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_if_expression&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_while_expression&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_object_creation&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_statements&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_statement&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_process_method_call&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_initial_process_method_call&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_message_receive&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_message_send&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_guard&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_if_statement&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_while_statement&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_switch_statement&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_switch_case_statement&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_abort&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_interrupt&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace poosl
{
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace poosl
{
  void
  operator<< (::xercesc::DOMElement&, const T_constant_type&);

  void
  operator<< (::xercesc::DOMAttr&, const T_constant_type&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_constant_type&);

  void
  operator<< (::xercesc::DOMElement&, const T_binary_operator&);

  void
  operator<< (::xercesc::DOMAttr&, const T_binary_operator&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_binary_operator&);

  void
  operator<< (::xercesc::DOMElement&, const T_unary_operator&);

  void
  operator<< (::xercesc::DOMAttr&, const T_unary_operator&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_unary_operator&);

  void
  operator<< (::xercesc::DOMElement&, const T_expressions&);

  void
  operator<< (::xercesc::DOMElement&, const T_expression&);

  void
  operator<< (::xercesc::DOMElement&, const T_assignment&);

  void
  operator<< (::xercesc::DOMElement&, const T_data_method_call&);

  void
  operator<< (::xercesc::DOMElement&, const T_constant&);

  void
  operator<< (::xercesc::DOMElement&, const T_current_time&);

  void
  operator<< (::xercesc::DOMAttr&, const T_current_time&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_current_time&);

  void
  operator<< (::xercesc::DOMElement&, const T_variable_ref&);

  void
  operator<< (::xercesc::DOMElement&, const T_binary_operation&);

  void
  operator<< (::xercesc::DOMElement&, const T_unary_operation&);

  void
  operator<< (::xercesc::DOMElement&, const T_if_expression&);

  void
  operator<< (::xercesc::DOMElement&, const T_while_expression&);

  void
  operator<< (::xercesc::DOMElement&, const T_object_creation&);

  void
  operator<< (::xercesc::DOMElement&, const T_statements&);

  void
  operator<< (::xercesc::DOMElement&, const T_statement&);

  void
  operator<< (::xercesc::DOMElement&, const T_process_method_call&);

  void
  operator<< (::xercesc::DOMElement&, const T_initial_process_method_call&);

  void
  operator<< (::xercesc::DOMElement&, const T_message_receive&);

  void
  operator<< (::xercesc::DOMElement&, const T_message_send&);

  void
  operator<< (::xercesc::DOMElement&, const T_guard&);

  void
  operator<< (::xercesc::DOMElement&, const T_if_statement&);

  void
  operator<< (::xercesc::DOMElement&, const T_while_statement&);

  void
  operator<< (::xercesc::DOMElement&, const T_switch_statement&);

  void
  operator<< (::xercesc::DOMElement&, const T_switch_case_statement&);

  void
  operator<< (::xercesc::DOMElement&, const T_abort&);

  void
  operator<< (::xercesc::DOMElement&, const T_interrupt&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // POOSLSTATEMENTS_HXX
