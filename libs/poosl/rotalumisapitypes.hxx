// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef ROTALUMISAPITYPES_HXX
#define ROTALUMISAPITYPES_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-iso8859-1.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type Type;
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;
  typedef ::xsd::cxx::tree::type Container;

  // 8-bit
  //
  typedef signed char Byte;
  typedef unsigned char UnsignedByte;

  // 16-bit
  //
  typedef short Short;
  typedef unsigned short UnsignedShort;

  // 32-bit
  //
  typedef int Int;
  typedef unsigned int UnsignedInt;

  // 64-bit
  //
  typedef long long Long;
  typedef unsigned long long UnsignedLong;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long Integer;
  typedef long long NonPositiveInteger;
  typedef unsigned long long NonNegativeInteger;
  typedef unsigned long long PositiveInteger;
  typedef long long NegativeInteger;

  // Boolean.
  //
  typedef bool Boolean;

  // Floating-point types.
  //
  typedef float Float;
  typedef double Double;
  typedef double Decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;
  typedef ::xsd::cxx::tree::name< char, Token > Name;
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;
  typedef ::xsd::cxx::tree::language< char, Token > Language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > Buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone TimeZone;
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;

  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags Flags;
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity Severity;
  typedef ::xsd::cxx::tree::error< char > Error;
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > Exception;
  typedef ::xsd::cxx::tree::bounds< char > Bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;
  typedef ::xsd::cxx::tree::parsing< char > Parsing;
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;
  typedef ::xsd::cxx::tree::no_type_info< char > NoTypeInfo;
  typedef ::xsd::cxx::tree::not_derived< char > NotDerived;
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace poosl
{
  class T_filename;
  class T_command;
  class T_command_result;
  class T_set_variable_result;
  class T_observe_aspect;
  class T_reqid;
  class T_handle;
  class T_handle_id;
  class T_handle_type;
  class T_inspect_type;
  class T_instance_name;
  class T_box;
  class T_point;
  class T_transition;
  class T_communication_transition;
  class T_sender_info;
  class T_receiver_info;
  class T_process_step_transition;
  class T_data_step_transition;
  class T_delay_transition;
  class T_transition_list;
  class T_source_position;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-iso8859-1.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

namespace poosl
{
  class T_filename: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    T_filename ();

    T_filename (const char*);

    T_filename (const ::std::string&);

    T_filename (const ::xml_schema::String&);

    T_filename (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    T_filename (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    T_filename (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    T_filename (const T_filename& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual T_filename*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_filename ();
  };

  class T_command: public ::xml_schema::String
  {
    public:
    enum Value
    {
      run,
      pause,
      stop,
      step,
      time_step,
      comm_step,
      process_step
    };

    T_command ();

    T_command (Value v);

    T_command (const char* v);

    T_command (const ::std::string& v);

    T_command (const ::xml_schema::String& v);

    T_command (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    T_command (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    T_command (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    T_command (const T_command& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual T_command*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_command&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_command_convert ();
    }

    protected:
    Value
    _xsd_T_command_convert () const;

    public:
    static const char* const _xsd_T_command_literals_[7];
    static const Value _xsd_T_command_indexes_[7];
  };

  class T_command_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      ok,
      no_design_loaded,
      error,
      unknown,
      breakpoint_hit
    };

    T_command_result ();

    T_command_result (Value v);

    T_command_result (const char* v);

    T_command_result (const ::std::string& v);

    T_command_result (const ::xml_schema::String& v);

    T_command_result (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_command_result (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_command_result (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_command_result (const T_command_result& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual T_command_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_command_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_command_result_convert ();
    }

    protected:
    Value
    _xsd_T_command_result_convert () const;

    public:
    static const char* const _xsd_T_command_result_literals_[5];
    static const Value _xsd_T_command_result_indexes_[5];
  };

  class T_set_variable_result: public ::xml_schema::String
  {
    public:
    enum Value
    {
      unknown,
      ok,
      error,
      invalid_var_handle,
      invalid_list_handle
    };

    T_set_variable_result ();

    T_set_variable_result (Value v);

    T_set_variable_result (const char* v);

    T_set_variable_result (const ::std::string& v);

    T_set_variable_result (const ::xml_schema::String& v);

    T_set_variable_result (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_set_variable_result (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_set_variable_result (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_set_variable_result (const T_set_variable_result& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual T_set_variable_result*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_set_variable_result&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_set_variable_result_convert ();
    }

    protected:
    Value
    _xsd_T_set_variable_result_convert () const;

    public:
    static const char* const _xsd_T_set_variable_result_literals_[5];
    static const Value _xsd_T_set_variable_result_indexes_[5];
  };

  class T_observe_aspect: public ::xml_schema::String
  {
    public:
    enum Value
    {
      terminated,
      state_changed
    };

    T_observe_aspect ();

    T_observe_aspect (Value v);

    T_observe_aspect (const char* v);

    T_observe_aspect (const ::std::string& v);

    T_observe_aspect (const ::xml_schema::String& v);

    T_observe_aspect (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_observe_aspect (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_observe_aspect (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_observe_aspect (const T_observe_aspect& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual T_observe_aspect*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_observe_aspect&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_observe_aspect_convert ();
    }

    protected:
    Value
    _xsd_T_observe_aspect_convert () const;

    public:
    static const char* const _xsd_T_observe_aspect_literals_[2];
    static const Value _xsd_T_observe_aspect_indexes_[2];
  };

  class T_reqid: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >
  {
    public:
    // Constructors.
    //
    T_reqid ();

    T_reqid (const ::xml_schema::Integer&);

    T_reqid (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    T_reqid (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    T_reqid (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    T_reqid (const T_reqid& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    virtual T_reqid*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_reqid ();
  };

  class T_handle: public ::xml_schema::Type
  {
    public:
    // id
    //
    typedef ::poosl::T_handle_id IdType;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdType&
    getId () const;

    IdType&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // type
    //
    typedef ::poosl::T_handle_type TypeType;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeType&
    getType () const;

    TypeType&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // Constructors.
    //
    T_handle ();

    T_handle (const IdType&,
              const TypeType&);

    T_handle (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    T_handle (const T_handle& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual T_handle*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_handle&
    operator= (const T_handle& x);

    virtual 
    ~T_handle ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > id_;
    ::xsd::cxx::tree::one< TypeType > type_;
  };

  class T_handle_id: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >
  {
    public:
    // Constructors.
    //
    T_handle_id ();

    T_handle_id (const ::xml_schema::Integer&);

    T_handle_id (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    T_handle_id (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    T_handle_id (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    T_handle_id (const T_handle_id& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual T_handle_id*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_handle_id ();
  };

  class T_handle_type: public ::xml_schema::String
  {
    public:
    enum Value
    {
      poosl_specification,
      cluster_class,
      process_class,
      data_class,
      initial_method_call,
      process_method,
      data_method,
      expression
    };

    T_handle_type ();

    T_handle_type (Value v);

    T_handle_type (const char* v);

    T_handle_type (const ::std::string& v);

    T_handle_type (const ::xml_schema::String& v);

    T_handle_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    T_handle_type (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    T_handle_type (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    T_handle_type (const T_handle_type& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual T_handle_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_handle_type&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_handle_type_convert ();
    }

    protected:
    Value
    _xsd_T_handle_type_convert () const;

    public:
    static const char* const _xsd_T_handle_type_literals_[8];
    static const Value _xsd_T_handle_type_indexes_[8];
  };

  class T_inspect_type: public ::xml_schema::String
  {
    public:
    enum Value
    {
      process,
      system,
      channel,
      port,
      variable,
      data,
      stackframe,
      variable_context
    };

    T_inspect_type ();

    T_inspect_type (Value v);

    T_inspect_type (const char* v);

    T_inspect_type (const ::std::string& v);

    T_inspect_type (const ::xml_schema::String& v);

    T_inspect_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_inspect_type (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_inspect_type (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_inspect_type (const T_inspect_type& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual T_inspect_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_inspect_type&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_inspect_type_convert ();
    }

    protected:
    Value
    _xsd_T_inspect_type_convert () const;

    public:
    static const char* const _xsd_T_inspect_type_literals_[8];
    static const Value _xsd_T_inspect_type_indexes_[8];
  };

  class T_instance_name: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    T_instance_name ();

    T_instance_name (const char*);

    T_instance_name (const ::std::string&);

    T_instance_name (const ::xml_schema::String&);

    T_instance_name (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_instance_name (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_instance_name (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_instance_name (const T_instance_name& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual T_instance_name*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_instance_name ();
  };

  class T_box: public ::xml_schema::Type
  {
    public:
    // left
    //
    typedef ::xml_schema::NonNegativeInteger LeftType;
    typedef ::xsd::cxx::tree::traits< LeftType, char > LeftTraits;

    const LeftType&
    getLeft () const;

    LeftType&
    getLeft ();

    void
    setLeft (const LeftType& x);

    // top
    //
    typedef ::xml_schema::NonNegativeInteger TopType;
    typedef ::xsd::cxx::tree::traits< TopType, char > TopTraits;

    const TopType&
    getTop () const;

    TopType&
    getTop ();

    void
    setTop (const TopType& x);

    // right
    //
    typedef ::xml_schema::NonNegativeInteger RightType;
    typedef ::xsd::cxx::tree::traits< RightType, char > RightTraits;

    const RightType&
    getRight () const;

    RightType&
    getRight ();

    void
    setRight (const RightType& x);

    // bottom
    //
    typedef ::xml_schema::NonNegativeInteger BottomType;
    typedef ::xsd::cxx::tree::traits< BottomType, char > BottomTraits;

    const BottomType&
    getBottom () const;

    BottomType&
    getBottom ();

    void
    setBottom (const BottomType& x);

    // Constructors.
    //
    T_box ();

    T_box (const LeftType&,
           const TopType&,
           const RightType&,
           const BottomType&);

    T_box (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    T_box (const T_box& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    virtual T_box*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_box&
    operator= (const T_box& x);

    virtual 
    ~T_box ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LeftType > left_;
    ::xsd::cxx::tree::one< TopType > top_;
    ::xsd::cxx::tree::one< RightType > right_;
    ::xsd::cxx::tree::one< BottomType > bottom_;
  };

  class T_point: public ::xml_schema::Type
  {
    public:
    // x
    //
    typedef ::xml_schema::NonNegativeInteger XType;
    typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

    const XType&
    getX () const;

    XType&
    getX ();

    void
    setX (const XType& x);

    // y
    //
    typedef ::xml_schema::NonNegativeInteger YType;
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    const YType&
    getY () const;

    YType&
    getY ();

    void
    setY (const YType& x);

    // Constructors.
    //
    T_point ();

    T_point (const XType&,
             const YType&);

    T_point (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    T_point (const T_point& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    virtual T_point*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_point&
    operator= (const T_point& x);

    virtual 
    ~T_point ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< XType > x_;
    ::xsd::cxx::tree::one< YType > y_;
  };

  class T_transition: public ::xml_schema::Type
  {
    public:
    // communication
    //
    typedef ::poosl::T_communication_transition CommunicationType;
    typedef ::xsd::cxx::tree::optional< CommunicationType > CommunicationOptional;
    typedef ::xsd::cxx::tree::traits< CommunicationType, char > CommunicationTraits;

    const CommunicationOptional&
    getCommunication () const;

    CommunicationOptional&
    getCommunication ();

    void
    setCommunication (const CommunicationType& x);

    void
    setCommunication (const CommunicationOptional& x);

    void
    setCommunication (::std::unique_ptr< CommunicationType > p);

    // process_step
    //
    typedef ::poosl::T_process_step_transition Process_stepType;
    typedef ::xsd::cxx::tree::optional< Process_stepType > Process_stepOptional;
    typedef ::xsd::cxx::tree::traits< Process_stepType, char > Process_stepTraits;

    const Process_stepOptional&
    getProcess_step () const;

    Process_stepOptional&
    getProcess_step ();

    void
    setProcess_step (const Process_stepType& x);

    void
    setProcess_step (const Process_stepOptional& x);

    void
    setProcess_step (::std::unique_ptr< Process_stepType > p);

    // data_step
    //
    typedef ::poosl::T_data_step_transition Data_stepType;
    typedef ::xsd::cxx::tree::optional< Data_stepType > Data_stepOptional;
    typedef ::xsd::cxx::tree::traits< Data_stepType, char > Data_stepTraits;

    const Data_stepOptional&
    getData_step () const;

    Data_stepOptional&
    getData_step ();

    void
    setData_step (const Data_stepType& x);

    void
    setData_step (const Data_stepOptional& x);

    void
    setData_step (::std::unique_ptr< Data_stepType > p);

    // delay
    //
    typedef ::poosl::T_delay_transition DelayType;
    typedef ::xsd::cxx::tree::optional< DelayType > DelayOptional;
    typedef ::xsd::cxx::tree::traits< DelayType, char > DelayTraits;

    const DelayOptional&
    getDelay () const;

    DelayOptional&
    getDelay ();

    void
    setDelay (const DelayType& x);

    void
    setDelay (const DelayOptional& x);

    void
    setDelay (::std::unique_ptr< DelayType > p);

    // Constructors.
    //
    T_transition ();

    T_transition (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    T_transition (const T_transition& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual T_transition*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_transition&
    operator= (const T_transition& x);

    virtual 
    ~T_transition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CommunicationOptional communication_;
    Process_stepOptional process_step_;
    Data_stepOptional data_step_;
    DelayOptional delay_;
  };

  class T_communication_transition: public ::xml_schema::Type
  {
    public:
    // sender
    //
    typedef ::poosl::T_sender_info SenderType;
    typedef ::xsd::cxx::tree::traits< SenderType, char > SenderTraits;

    const SenderType&
    getSender () const;

    SenderType&
    getSender ();

    void
    setSender (const SenderType& x);

    void
    setSender (::std::unique_ptr< SenderType > p);

    // receiver
    //
    typedef ::poosl::T_receiver_info ReceiverType;
    typedef ::xsd::cxx::tree::traits< ReceiverType, char > ReceiverTraits;

    const ReceiverType&
    getReceiver () const;

    ReceiverType&
    getReceiver ();

    void
    setReceiver (const ReceiverType& x);

    void
    setReceiver (::std::unique_ptr< ReceiverType > p);

    // handle
    //
    typedef ::poosl::T_handle_id HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    void
    setHandle (::std::unique_ptr< HandleType > p);

    // Constructors.
    //
    T_communication_transition ();

    T_communication_transition (const SenderType&,
                                const ReceiverType&,
                                const HandleType&);

    T_communication_transition (::std::unique_ptr< SenderType >,
                                ::std::unique_ptr< ReceiverType >,
                                const HandleType&);

    T_communication_transition (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    T_communication_transition (const T_communication_transition& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual T_communication_transition*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_communication_transition&
    operator= (const T_communication_transition& x);

    virtual 
    ~T_communication_transition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< SenderType > sender_;
    ::xsd::cxx::tree::one< ReceiverType > receiver_;
    ::xsd::cxx::tree::one< HandleType > handle_;
  };

  class T_sender_info: public ::xml_schema::Type
  {
    public:
    // process_path
    //
    typedef ::xml_schema::String Process_pathType;
    typedef ::xsd::cxx::tree::traits< Process_pathType, char > Process_pathTraits;

    const Process_pathType&
    getProcess_path () const;

    Process_pathType&
    getProcess_path ();

    void
    setProcess_path (const Process_pathType& x);

    void
    setProcess_path (::std::unique_ptr< Process_pathType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // port
    //
    typedef ::xml_schema::String PortType;
    typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

    const PortType&
    getPort () const;

    PortType&
    getPort ();

    void
    setPort (const PortType& x);

    void
    setPort (::std::unique_ptr< PortType > p);

    // message
    //
    typedef ::xml_schema::String MessageType;
    typedef ::xsd::cxx::tree::traits< MessageType, char > MessageTraits;

    const MessageType&
    getMessage () const;

    MessageType&
    getMessage ();

    void
    setMessage (const MessageType& x);

    void
    setMessage (::std::unique_ptr< MessageType > p);

    // parameter_count
    //
    typedef ::xml_schema::NonNegativeInteger Parameter_countType;
    typedef ::xsd::cxx::tree::traits< Parameter_countType, char > Parameter_countTraits;

    const Parameter_countType&
    getParameter_count () const;

    Parameter_countType&
    getParameter_count ();

    void
    setParameter_count (const Parameter_countType& x);

    // node
    //
    typedef ::xml_schema::Integer NodeType;
    typedef ::xsd::cxx::tree::traits< NodeType, char > NodeTraits;

    const NodeType&
    getNode () const;

    NodeType&
    getNode ();

    void
    setNode (const NodeType& x);

    // Constructors.
    //
    T_sender_info ();

    T_sender_info (const Process_pathType&,
                   const HandleType&,
                   const PortType&,
                   const MessageType&,
                   const Parameter_countType&,
                   const NodeType&);

    T_sender_info (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    T_sender_info (const T_sender_info& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual T_sender_info*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_sender_info&
    operator= (const T_sender_info& x);

    virtual 
    ~T_sender_info ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Process_pathType > process_path_;
    ::xsd::cxx::tree::one< HandleType > handle_;
    ::xsd::cxx::tree::one< PortType > port_;
    ::xsd::cxx::tree::one< MessageType > message_;
    ::xsd::cxx::tree::one< Parameter_countType > parameter_count_;
    ::xsd::cxx::tree::one< NodeType > node_;
  };

  class T_receiver_info: public ::xml_schema::Type
  {
    public:
    // process_path
    //
    typedef ::xml_schema::String Process_pathType;
    typedef ::xsd::cxx::tree::traits< Process_pathType, char > Process_pathTraits;

    const Process_pathType&
    getProcess_path () const;

    Process_pathType&
    getProcess_path ();

    void
    setProcess_path (const Process_pathType& x);

    void
    setProcess_path (::std::unique_ptr< Process_pathType > p);

    // handle
    //
    typedef ::xml_schema::Integer HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    // port
    //
    typedef ::xml_schema::String PortType;
    typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

    const PortType&
    getPort () const;

    PortType&
    getPort ();

    void
    setPort (const PortType& x);

    void
    setPort (::std::unique_ptr< PortType > p);

    // message
    //
    typedef ::xml_schema::String MessageType;
    typedef ::xsd::cxx::tree::traits< MessageType, char > MessageTraits;

    const MessageType&
    getMessage () const;

    MessageType&
    getMessage ();

    void
    setMessage (const MessageType& x);

    void
    setMessage (::std::unique_ptr< MessageType > p);

    // parameter_count
    //
    typedef ::xml_schema::NonNegativeInteger Parameter_countType;
    typedef ::xsd::cxx::tree::traits< Parameter_countType, char > Parameter_countTraits;

    const Parameter_countType&
    getParameter_count () const;

    Parameter_countType&
    getParameter_count ();

    void
    setParameter_count (const Parameter_countType& x);

    // node
    //
    typedef ::xml_schema::Integer NodeType;
    typedef ::xsd::cxx::tree::traits< NodeType, char > NodeTraits;

    const NodeType&
    getNode () const;

    NodeType&
    getNode ();

    void
    setNode (const NodeType& x);

    // Constructors.
    //
    T_receiver_info ();

    T_receiver_info (const Process_pathType&,
                     const HandleType&,
                     const PortType&,
                     const MessageType&,
                     const Parameter_countType&,
                     const NodeType&);

    T_receiver_info (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_receiver_info (const T_receiver_info& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual T_receiver_info*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_receiver_info&
    operator= (const T_receiver_info& x);

    virtual 
    ~T_receiver_info ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Process_pathType > process_path_;
    ::xsd::cxx::tree::one< HandleType > handle_;
    ::xsd::cxx::tree::one< PortType > port_;
    ::xsd::cxx::tree::one< MessageType > message_;
    ::xsd::cxx::tree::one< Parameter_countType > parameter_count_;
    ::xsd::cxx::tree::one< NodeType > node_;
  };

  class T_process_step_transition: public ::xml_schema::Type
  {
    public:
    // process_path
    //
    typedef ::xml_schema::String Process_pathType;
    typedef ::xsd::cxx::tree::traits< Process_pathType, char > Process_pathTraits;

    const Process_pathType&
    getProcess_path () const;

    Process_pathType&
    getProcess_path ();

    void
    setProcess_path (const Process_pathType& x);

    void
    setProcess_path (::std::unique_ptr< Process_pathType > p);

    // node
    //
    typedef ::xml_schema::Integer NodeType;
    typedef ::xsd::cxx::tree::traits< NodeType, char > NodeTraits;

    const NodeType&
    getNode () const;

    NodeType&
    getNode ();

    void
    setNode (const NodeType& x);

    // handle
    //
    typedef ::poosl::T_handle_id HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    void
    setHandle (::std::unique_ptr< HandleType > p);

    // Constructors.
    //
    T_process_step_transition ();

    T_process_step_transition (const Process_pathType&,
                               const NodeType&,
                               const HandleType&);

    T_process_step_transition (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    T_process_step_transition (const T_process_step_transition& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual T_process_step_transition*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_process_step_transition&
    operator= (const T_process_step_transition& x);

    virtual 
    ~T_process_step_transition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Process_pathType > process_path_;
    ::xsd::cxx::tree::one< NodeType > node_;
    ::xsd::cxx::tree::one< HandleType > handle_;
  };

  class T_data_step_transition: public ::xml_schema::Type
  {
    public:
    // process_path
    //
    typedef ::xml_schema::String Process_pathType;
    typedef ::xsd::cxx::tree::traits< Process_pathType, char > Process_pathTraits;

    const Process_pathType&
    getProcess_path () const;

    Process_pathType&
    getProcess_path ();

    void
    setProcess_path (const Process_pathType& x);

    void
    setProcess_path (::std::unique_ptr< Process_pathType > p);

    // node
    //
    typedef ::xml_schema::Integer NodeType;
    typedef ::xsd::cxx::tree::traits< NodeType, char > NodeTraits;

    const NodeType&
    getNode () const;

    NodeType&
    getNode ();

    void
    setNode (const NodeType& x);

    // handle
    //
    typedef ::poosl::T_handle_id HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    void
    setHandle (::std::unique_ptr< HandleType > p);

    // Constructors.
    //
    T_data_step_transition ();

    T_data_step_transition (const Process_pathType&,
                            const NodeType&,
                            const HandleType&);

    T_data_step_transition (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    T_data_step_transition (const T_data_step_transition& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual T_data_step_transition*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_data_step_transition&
    operator= (const T_data_step_transition& x);

    virtual 
    ~T_data_step_transition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Process_pathType > process_path_;
    ::xsd::cxx::tree::one< NodeType > node_;
    ::xsd::cxx::tree::one< HandleType > handle_;
  };

  class T_delay_transition: public ::xml_schema::Type
  {
    public:
    // period
    //
    typedef ::xml_schema::Double PeriodType;
    typedef ::xsd::cxx::tree::traits< PeriodType, char, ::xsd::cxx::tree::schema_type::double_ > PeriodTraits;

    const PeriodType&
    getPeriod () const;

    PeriodType&
    getPeriod ();

    void
    setPeriod (const PeriodType& x);

    // node
    //
    typedef ::xml_schema::Integer NodeType;
    typedef ::xsd::cxx::tree::traits< NodeType, char > NodeTraits;

    const NodeType&
    getNode () const;

    NodeType&
    getNode ();

    void
    setNode (const NodeType& x);

    // process_path
    //
    typedef ::xml_schema::String Process_pathType;
    typedef ::xsd::cxx::tree::traits< Process_pathType, char > Process_pathTraits;

    const Process_pathType&
    getProcess_path () const;

    Process_pathType&
    getProcess_path ();

    void
    setProcess_path (const Process_pathType& x);

    void
    setProcess_path (::std::unique_ptr< Process_pathType > p);

    // handle
    //
    typedef ::poosl::T_handle_id HandleType;
    typedef ::xsd::cxx::tree::traits< HandleType, char > HandleTraits;

    const HandleType&
    getHandle () const;

    HandleType&
    getHandle ();

    void
    setHandle (const HandleType& x);

    void
    setHandle (::std::unique_ptr< HandleType > p);

    // Constructors.
    //
    T_delay_transition ();

    T_delay_transition (const PeriodType&,
                        const NodeType&,
                        const Process_pathType&,
                        const HandleType&);

    T_delay_transition (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_delay_transition (const T_delay_transition& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_delay_transition*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_delay_transition&
    operator= (const T_delay_transition& x);

    virtual 
    ~T_delay_transition ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PeriodType > period_;
    ::xsd::cxx::tree::one< NodeType > node_;
    ::xsd::cxx::tree::one< Process_pathType > process_path_;
    ::xsd::cxx::tree::one< HandleType > handle_;
  };

  class T_transition_list: public ::xml_schema::Type
  {
    public:
    // transition
    //
    typedef ::poosl::T_transition TransitionType;
    typedef ::xsd::cxx::tree::sequence< TransitionType > TransitionSequence;
    typedef TransitionSequence::iterator TransitionIterator;
    typedef TransitionSequence::const_iterator TransitionConstIterator;
    typedef ::xsd::cxx::tree::traits< TransitionType, char > TransitionTraits;

    const TransitionSequence&
    getTransition () const;

    TransitionSequence&
    getTransition ();

    void
    setTransition (const TransitionSequence& s);

    // Constructors.
    //
    T_transition_list ();

    T_transition_list (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_transition_list (const T_transition_list& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_transition_list*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_transition_list&
    operator= (const T_transition_list& x);

    virtual 
    ~T_transition_list ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TransitionSequence transition_;
  };

  class T_source_position: public ::xml_schema::Type
  {
    public:
    // file
    //
    typedef ::xml_schema::Integer FileType;
    typedef ::xsd::cxx::tree::traits< FileType, char > FileTraits;

    const FileType&
    getFile () const;

    FileType&
    getFile ();

    void
    setFile (const FileType& x);

    // line
    //
    typedef ::xml_schema::Integer LineType;
    typedef ::xsd::cxx::tree::traits< LineType, char > LineTraits;

    const LineType&
    getLine () const;

    LineType&
    getLine ();

    void
    setLine (const LineType& x);

    // column
    //
    typedef ::xml_schema::Integer ColumnType;
    typedef ::xsd::cxx::tree::traits< ColumnType, char > ColumnTraits;

    const ColumnType&
    getColumn () const;

    ColumnType&
    getColumn ();

    void
    setColumn (const ColumnType& x);

    // offset
    //
    typedef ::xml_schema::Integer OffsetType;
    typedef ::xsd::cxx::tree::traits< OffsetType, char > OffsetTraits;

    const OffsetType&
    getOffset () const;

    OffsetType&
    getOffset ();

    void
    setOffset (const OffsetType& x);

    // Constructors.
    //
    T_source_position ();

    T_source_position (const FileType&,
                       const LineType&,
                       const ColumnType&,
                       const OffsetType&);

    T_source_position (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_source_position (const T_source_position& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_source_position*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_source_position&
    operator= (const T_source_position& x);

    virtual 
    ~T_source_position ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FileType > file_;
    ::xsd::cxx::tree::one< LineType > line_;
    ::xsd::cxx::tree::one< ColumnType > column_;
    ::xsd::cxx::tree::one< OffsetType > offset_;
  };
}

#include <iosfwd>

namespace poosl
{
  ::std::ostream&
  operator<< (::std::ostream&, const T_filename&);

  ::std::ostream&
  operator<< (::std::ostream&, T_command::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_command&);

  ::std::ostream&
  operator<< (::std::ostream&, T_command_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_command_result&);

  ::std::ostream&
  operator<< (::std::ostream&, T_set_variable_result::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_set_variable_result&);

  ::std::ostream&
  operator<< (::std::ostream&, T_observe_aspect::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_observe_aspect&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_reqid&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_handle&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_handle_id&);

  ::std::ostream&
  operator<< (::std::ostream&, T_handle_type::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_handle_type&);

  ::std::ostream&
  operator<< (::std::ostream&, T_inspect_type::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_inspect_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_instance_name&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_box&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_point&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_transition&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_communication_transition&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_sender_info&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_receiver_info&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_process_step_transition&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_data_step_transition&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_delay_transition&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_transition_list&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_source_position&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace poosl
{
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace poosl
{
  void
  operator<< (::xercesc::DOMElement&, const T_filename&);

  void
  operator<< (::xercesc::DOMAttr&, const T_filename&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_filename&);

  void
  operator<< (::xercesc::DOMElement&, const T_command&);

  void
  operator<< (::xercesc::DOMAttr&, const T_command&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_command&);

  void
  operator<< (::xercesc::DOMElement&, const T_command_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_command_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_command_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_set_variable_result&);

  void
  operator<< (::xercesc::DOMAttr&, const T_set_variable_result&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_set_variable_result&);

  void
  operator<< (::xercesc::DOMElement&, const T_observe_aspect&);

  void
  operator<< (::xercesc::DOMAttr&, const T_observe_aspect&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_observe_aspect&);

  void
  operator<< (::xercesc::DOMElement&, const T_reqid&);

  void
  operator<< (::xercesc::DOMAttr&, const T_reqid&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_reqid&);

  void
  operator<< (::xercesc::DOMElement&, const T_handle&);

  void
  operator<< (::xercesc::DOMElement&, const T_handle_id&);

  void
  operator<< (::xercesc::DOMAttr&, const T_handle_id&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_handle_id&);

  void
  operator<< (::xercesc::DOMElement&, const T_handle_type&);

  void
  operator<< (::xercesc::DOMAttr&, const T_handle_type&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_handle_type&);

  void
  operator<< (::xercesc::DOMElement&, const T_inspect_type&);

  void
  operator<< (::xercesc::DOMAttr&, const T_inspect_type&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_inspect_type&);

  void
  operator<< (::xercesc::DOMElement&, const T_instance_name&);

  void
  operator<< (::xercesc::DOMAttr&, const T_instance_name&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_instance_name&);

  void
  operator<< (::xercesc::DOMElement&, const T_box&);

  void
  operator<< (::xercesc::DOMElement&, const T_point&);

  void
  operator<< (::xercesc::DOMElement&, const T_transition&);

  void
  operator<< (::xercesc::DOMElement&, const T_communication_transition&);

  void
  operator<< (::xercesc::DOMElement&, const T_sender_info&);

  void
  operator<< (::xercesc::DOMElement&, const T_receiver_info&);

  void
  operator<< (::xercesc::DOMElement&, const T_process_step_transition&);

  void
  operator<< (::xercesc::DOMElement&, const T_data_step_transition&);

  void
  operator<< (::xercesc::DOMElement&, const T_delay_transition&);

  void
  operator<< (::xercesc::DOMElement&, const T_transition_list&);

  void
  operator<< (::xercesc::DOMElement&, const T_source_position&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // ROTALUMISAPITYPES_HXX
