// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rotalumisapitypes.hxx"

namespace poosl
{
  // T_filename
  // 


  // T_command
  // 

  T_command::
  T_command ()
  : ::xml_schema::String ()
  {
  }

  T_command::
  T_command (Value v)
  : ::xml_schema::String (_xsd_T_command_literals_[v])
  {
  }

  T_command::
  T_command (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_command::
  T_command (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_command::
  T_command (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_command::
  T_command (const T_command& v,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_command& T_command::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_command_literals_[v]);

    return *this;
  }


  // T_command_result
  // 

  T_command_result::
  T_command_result ()
  : ::xml_schema::String ()
  {
  }

  T_command_result::
  T_command_result (Value v)
  : ::xml_schema::String (_xsd_T_command_result_literals_[v])
  {
  }

  T_command_result::
  T_command_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_command_result::
  T_command_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_command_result::
  T_command_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_command_result::
  T_command_result (const T_command_result& v,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_command_result& T_command_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_command_result_literals_[v]);

    return *this;
  }


  // T_set_variable_result
  // 

  T_set_variable_result::
  T_set_variable_result ()
  : ::xml_schema::String ()
  {
  }

  T_set_variable_result::
  T_set_variable_result (Value v)
  : ::xml_schema::String (_xsd_T_set_variable_result_literals_[v])
  {
  }

  T_set_variable_result::
  T_set_variable_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_set_variable_result::
  T_set_variable_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_set_variable_result::
  T_set_variable_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_set_variable_result::
  T_set_variable_result (const T_set_variable_result& v,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_set_variable_result& T_set_variable_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_set_variable_result_literals_[v]);

    return *this;
  }


  // T_observe_aspect
  // 

  T_observe_aspect::
  T_observe_aspect ()
  : ::xml_schema::String ()
  {
  }

  T_observe_aspect::
  T_observe_aspect (Value v)
  : ::xml_schema::String (_xsd_T_observe_aspect_literals_[v])
  {
  }

  T_observe_aspect::
  T_observe_aspect (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_observe_aspect::
  T_observe_aspect (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_observe_aspect::
  T_observe_aspect (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_observe_aspect::
  T_observe_aspect (const T_observe_aspect& v,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_observe_aspect& T_observe_aspect::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_observe_aspect_literals_[v]);

    return *this;
  }


  // T_reqid
  // 


  // T_handle
  // 

  const T_handle::IdType& T_handle::
  getId () const
  {
    return this->id_.get ();
  }

  T_handle::IdType& T_handle::
  getId ()
  {
    return this->id_.get ();
  }

  void T_handle::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void T_handle::
  setId (::std::unique_ptr< IdType > x)
  {
    this->id_.set (std::move (x));
  }

  const T_handle::TypeType& T_handle::
  getType () const
  {
    return this->type_.get ();
  }

  T_handle::TypeType& T_handle::
  getType ()
  {
    return this->type_.get ();
  }

  void T_handle::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void T_handle::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }


  // T_handle_id
  // 


  // T_handle_type
  // 

  T_handle_type::
  T_handle_type ()
  : ::xml_schema::String ()
  {
  }

  T_handle_type::
  T_handle_type (Value v)
  : ::xml_schema::String (_xsd_T_handle_type_literals_[v])
  {
  }

  T_handle_type::
  T_handle_type (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_handle_type::
  T_handle_type (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_handle_type::
  T_handle_type (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_handle_type::
  T_handle_type (const T_handle_type& v,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_handle_type& T_handle_type::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_handle_type_literals_[v]);

    return *this;
  }


  // T_inspect_type
  // 

  T_inspect_type::
  T_inspect_type ()
  : ::xml_schema::String ()
  {
  }

  T_inspect_type::
  T_inspect_type (Value v)
  : ::xml_schema::String (_xsd_T_inspect_type_literals_[v])
  {
  }

  T_inspect_type::
  T_inspect_type (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_inspect_type::
  T_inspect_type (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_inspect_type::
  T_inspect_type (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_inspect_type::
  T_inspect_type (const T_inspect_type& v,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_inspect_type& T_inspect_type::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_inspect_type_literals_[v]);

    return *this;
  }


  // T_instance_name
  // 


  // T_box
  // 

  const T_box::LeftType& T_box::
  getLeft () const
  {
    return this->left_.get ();
  }

  T_box::LeftType& T_box::
  getLeft ()
  {
    return this->left_.get ();
  }

  void T_box::
  setLeft (const LeftType& x)
  {
    this->left_.set (x);
  }

  const T_box::TopType& T_box::
  getTop () const
  {
    return this->top_.get ();
  }

  T_box::TopType& T_box::
  getTop ()
  {
    return this->top_.get ();
  }

  void T_box::
  setTop (const TopType& x)
  {
    this->top_.set (x);
  }

  const T_box::RightType& T_box::
  getRight () const
  {
    return this->right_.get ();
  }

  T_box::RightType& T_box::
  getRight ()
  {
    return this->right_.get ();
  }

  void T_box::
  setRight (const RightType& x)
  {
    this->right_.set (x);
  }

  const T_box::BottomType& T_box::
  getBottom () const
  {
    return this->bottom_.get ();
  }

  T_box::BottomType& T_box::
  getBottom ()
  {
    return this->bottom_.get ();
  }

  void T_box::
  setBottom (const BottomType& x)
  {
    this->bottom_.set (x);
  }


  // T_point
  // 

  const T_point::XType& T_point::
  getX () const
  {
    return this->x_.get ();
  }

  T_point::XType& T_point::
  getX ()
  {
    return this->x_.get ();
  }

  void T_point::
  setX (const XType& x)
  {
    this->x_.set (x);
  }

  const T_point::YType& T_point::
  getY () const
  {
    return this->y_.get ();
  }

  T_point::YType& T_point::
  getY ()
  {
    return this->y_.get ();
  }

  void T_point::
  setY (const YType& x)
  {
    this->y_.set (x);
  }


  // T_transition
  // 

  const T_transition::CommunicationOptional& T_transition::
  getCommunication () const
  {
    return this->communication_;
  }

  T_transition::CommunicationOptional& T_transition::
  getCommunication ()
  {
    return this->communication_;
  }

  void T_transition::
  setCommunication (const CommunicationType& x)
  {
    this->communication_.set (x);
  }

  void T_transition::
  setCommunication (const CommunicationOptional& x)
  {
    this->communication_ = x;
  }

  void T_transition::
  setCommunication (::std::unique_ptr< CommunicationType > x)
  {
    this->communication_.set (std::move (x));
  }

  const T_transition::Process_stepOptional& T_transition::
  getProcess_step () const
  {
    return this->process_step_;
  }

  T_transition::Process_stepOptional& T_transition::
  getProcess_step ()
  {
    return this->process_step_;
  }

  void T_transition::
  setProcess_step (const Process_stepType& x)
  {
    this->process_step_.set (x);
  }

  void T_transition::
  setProcess_step (const Process_stepOptional& x)
  {
    this->process_step_ = x;
  }

  void T_transition::
  setProcess_step (::std::unique_ptr< Process_stepType > x)
  {
    this->process_step_.set (std::move (x));
  }

  const T_transition::Data_stepOptional& T_transition::
  getData_step () const
  {
    return this->data_step_;
  }

  T_transition::Data_stepOptional& T_transition::
  getData_step ()
  {
    return this->data_step_;
  }

  void T_transition::
  setData_step (const Data_stepType& x)
  {
    this->data_step_.set (x);
  }

  void T_transition::
  setData_step (const Data_stepOptional& x)
  {
    this->data_step_ = x;
  }

  void T_transition::
  setData_step (::std::unique_ptr< Data_stepType > x)
  {
    this->data_step_.set (std::move (x));
  }

  const T_transition::DelayOptional& T_transition::
  getDelay () const
  {
    return this->delay_;
  }

  T_transition::DelayOptional& T_transition::
  getDelay ()
  {
    return this->delay_;
  }

  void T_transition::
  setDelay (const DelayType& x)
  {
    this->delay_.set (x);
  }

  void T_transition::
  setDelay (const DelayOptional& x)
  {
    this->delay_ = x;
  }

  void T_transition::
  setDelay (::std::unique_ptr< DelayType > x)
  {
    this->delay_.set (std::move (x));
  }


  // T_communication_transition
  // 

  const T_communication_transition::SenderType& T_communication_transition::
  getSender () const
  {
    return this->sender_.get ();
  }

  T_communication_transition::SenderType& T_communication_transition::
  getSender ()
  {
    return this->sender_.get ();
  }

  void T_communication_transition::
  setSender (const SenderType& x)
  {
    this->sender_.set (x);
  }

  void T_communication_transition::
  setSender (::std::unique_ptr< SenderType > x)
  {
    this->sender_.set (std::move (x));
  }

  const T_communication_transition::ReceiverType& T_communication_transition::
  getReceiver () const
  {
    return this->receiver_.get ();
  }

  T_communication_transition::ReceiverType& T_communication_transition::
  getReceiver ()
  {
    return this->receiver_.get ();
  }

  void T_communication_transition::
  setReceiver (const ReceiverType& x)
  {
    this->receiver_.set (x);
  }

  void T_communication_transition::
  setReceiver (::std::unique_ptr< ReceiverType > x)
  {
    this->receiver_.set (std::move (x));
  }

  const T_communication_transition::HandleType& T_communication_transition::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_communication_transition::HandleType& T_communication_transition::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_communication_transition::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  void T_communication_transition::
  setHandle (::std::unique_ptr< HandleType > x)
  {
    this->handle_.set (std::move (x));
  }


  // T_sender_info
  // 

  const T_sender_info::Process_pathType& T_sender_info::
  getProcess_path () const
  {
    return this->process_path_.get ();
  }

  T_sender_info::Process_pathType& T_sender_info::
  getProcess_path ()
  {
    return this->process_path_.get ();
  }

  void T_sender_info::
  setProcess_path (const Process_pathType& x)
  {
    this->process_path_.set (x);
  }

  void T_sender_info::
  setProcess_path (::std::unique_ptr< Process_pathType > x)
  {
    this->process_path_.set (std::move (x));
  }

  const T_sender_info::HandleType& T_sender_info::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_sender_info::HandleType& T_sender_info::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_sender_info::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  const T_sender_info::PortType& T_sender_info::
  getPort () const
  {
    return this->port_.get ();
  }

  T_sender_info::PortType& T_sender_info::
  getPort ()
  {
    return this->port_.get ();
  }

  void T_sender_info::
  setPort (const PortType& x)
  {
    this->port_.set (x);
  }

  void T_sender_info::
  setPort (::std::unique_ptr< PortType > x)
  {
    this->port_.set (std::move (x));
  }

  const T_sender_info::MessageType& T_sender_info::
  getMessage () const
  {
    return this->message_.get ();
  }

  T_sender_info::MessageType& T_sender_info::
  getMessage ()
  {
    return this->message_.get ();
  }

  void T_sender_info::
  setMessage (const MessageType& x)
  {
    this->message_.set (x);
  }

  void T_sender_info::
  setMessage (::std::unique_ptr< MessageType > x)
  {
    this->message_.set (std::move (x));
  }

  const T_sender_info::Parameter_countType& T_sender_info::
  getParameter_count () const
  {
    return this->parameter_count_.get ();
  }

  T_sender_info::Parameter_countType& T_sender_info::
  getParameter_count ()
  {
    return this->parameter_count_.get ();
  }

  void T_sender_info::
  setParameter_count (const Parameter_countType& x)
  {
    this->parameter_count_.set (x);
  }

  const T_sender_info::NodeType& T_sender_info::
  getNode () const
  {
    return this->node_.get ();
  }

  T_sender_info::NodeType& T_sender_info::
  getNode ()
  {
    return this->node_.get ();
  }

  void T_sender_info::
  setNode (const NodeType& x)
  {
    this->node_.set (x);
  }


  // T_receiver_info
  // 

  const T_receiver_info::Process_pathType& T_receiver_info::
  getProcess_path () const
  {
    return this->process_path_.get ();
  }

  T_receiver_info::Process_pathType& T_receiver_info::
  getProcess_path ()
  {
    return this->process_path_.get ();
  }

  void T_receiver_info::
  setProcess_path (const Process_pathType& x)
  {
    this->process_path_.set (x);
  }

  void T_receiver_info::
  setProcess_path (::std::unique_ptr< Process_pathType > x)
  {
    this->process_path_.set (std::move (x));
  }

  const T_receiver_info::HandleType& T_receiver_info::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_receiver_info::HandleType& T_receiver_info::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_receiver_info::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  const T_receiver_info::PortType& T_receiver_info::
  getPort () const
  {
    return this->port_.get ();
  }

  T_receiver_info::PortType& T_receiver_info::
  getPort ()
  {
    return this->port_.get ();
  }

  void T_receiver_info::
  setPort (const PortType& x)
  {
    this->port_.set (x);
  }

  void T_receiver_info::
  setPort (::std::unique_ptr< PortType > x)
  {
    this->port_.set (std::move (x));
  }

  const T_receiver_info::MessageType& T_receiver_info::
  getMessage () const
  {
    return this->message_.get ();
  }

  T_receiver_info::MessageType& T_receiver_info::
  getMessage ()
  {
    return this->message_.get ();
  }

  void T_receiver_info::
  setMessage (const MessageType& x)
  {
    this->message_.set (x);
  }

  void T_receiver_info::
  setMessage (::std::unique_ptr< MessageType > x)
  {
    this->message_.set (std::move (x));
  }

  const T_receiver_info::Parameter_countType& T_receiver_info::
  getParameter_count () const
  {
    return this->parameter_count_.get ();
  }

  T_receiver_info::Parameter_countType& T_receiver_info::
  getParameter_count ()
  {
    return this->parameter_count_.get ();
  }

  void T_receiver_info::
  setParameter_count (const Parameter_countType& x)
  {
    this->parameter_count_.set (x);
  }

  const T_receiver_info::NodeType& T_receiver_info::
  getNode () const
  {
    return this->node_.get ();
  }

  T_receiver_info::NodeType& T_receiver_info::
  getNode ()
  {
    return this->node_.get ();
  }

  void T_receiver_info::
  setNode (const NodeType& x)
  {
    this->node_.set (x);
  }


  // T_process_step_transition
  // 

  const T_process_step_transition::Process_pathType& T_process_step_transition::
  getProcess_path () const
  {
    return this->process_path_.get ();
  }

  T_process_step_transition::Process_pathType& T_process_step_transition::
  getProcess_path ()
  {
    return this->process_path_.get ();
  }

  void T_process_step_transition::
  setProcess_path (const Process_pathType& x)
  {
    this->process_path_.set (x);
  }

  void T_process_step_transition::
  setProcess_path (::std::unique_ptr< Process_pathType > x)
  {
    this->process_path_.set (std::move (x));
  }

  const T_process_step_transition::NodeType& T_process_step_transition::
  getNode () const
  {
    return this->node_.get ();
  }

  T_process_step_transition::NodeType& T_process_step_transition::
  getNode ()
  {
    return this->node_.get ();
  }

  void T_process_step_transition::
  setNode (const NodeType& x)
  {
    this->node_.set (x);
  }

  const T_process_step_transition::HandleType& T_process_step_transition::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_process_step_transition::HandleType& T_process_step_transition::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_process_step_transition::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  void T_process_step_transition::
  setHandle (::std::unique_ptr< HandleType > x)
  {
    this->handle_.set (std::move (x));
  }


  // T_data_step_transition
  // 

  const T_data_step_transition::Process_pathType& T_data_step_transition::
  getProcess_path () const
  {
    return this->process_path_.get ();
  }

  T_data_step_transition::Process_pathType& T_data_step_transition::
  getProcess_path ()
  {
    return this->process_path_.get ();
  }

  void T_data_step_transition::
  setProcess_path (const Process_pathType& x)
  {
    this->process_path_.set (x);
  }

  void T_data_step_transition::
  setProcess_path (::std::unique_ptr< Process_pathType > x)
  {
    this->process_path_.set (std::move (x));
  }

  const T_data_step_transition::NodeType& T_data_step_transition::
  getNode () const
  {
    return this->node_.get ();
  }

  T_data_step_transition::NodeType& T_data_step_transition::
  getNode ()
  {
    return this->node_.get ();
  }

  void T_data_step_transition::
  setNode (const NodeType& x)
  {
    this->node_.set (x);
  }

  const T_data_step_transition::HandleType& T_data_step_transition::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_data_step_transition::HandleType& T_data_step_transition::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_data_step_transition::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  void T_data_step_transition::
  setHandle (::std::unique_ptr< HandleType > x)
  {
    this->handle_.set (std::move (x));
  }


  // T_delay_transition
  // 

  const T_delay_transition::PeriodType& T_delay_transition::
  getPeriod () const
  {
    return this->period_.get ();
  }

  T_delay_transition::PeriodType& T_delay_transition::
  getPeriod ()
  {
    return this->period_.get ();
  }

  void T_delay_transition::
  setPeriod (const PeriodType& x)
  {
    this->period_.set (x);
  }

  const T_delay_transition::NodeType& T_delay_transition::
  getNode () const
  {
    return this->node_.get ();
  }

  T_delay_transition::NodeType& T_delay_transition::
  getNode ()
  {
    return this->node_.get ();
  }

  void T_delay_transition::
  setNode (const NodeType& x)
  {
    this->node_.set (x);
  }

  const T_delay_transition::Process_pathType& T_delay_transition::
  getProcess_path () const
  {
    return this->process_path_.get ();
  }

  T_delay_transition::Process_pathType& T_delay_transition::
  getProcess_path ()
  {
    return this->process_path_.get ();
  }

  void T_delay_transition::
  setProcess_path (const Process_pathType& x)
  {
    this->process_path_.set (x);
  }

  void T_delay_transition::
  setProcess_path (::std::unique_ptr< Process_pathType > x)
  {
    this->process_path_.set (std::move (x));
  }

  const T_delay_transition::HandleType& T_delay_transition::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_delay_transition::HandleType& T_delay_transition::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_delay_transition::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  void T_delay_transition::
  setHandle (::std::unique_ptr< HandleType > x)
  {
    this->handle_.set (std::move (x));
  }


  // T_transition_list
  // 

  const T_transition_list::TransitionSequence& T_transition_list::
  getTransition () const
  {
    return this->transition_;
  }

  T_transition_list::TransitionSequence& T_transition_list::
  getTransition ()
  {
    return this->transition_;
  }

  void T_transition_list::
  setTransition (const TransitionSequence& s)
  {
    this->transition_ = s;
  }


  // T_source_position
  // 

  const T_source_position::FileType& T_source_position::
  getFile () const
  {
    return this->file_.get ();
  }

  T_source_position::FileType& T_source_position::
  getFile ()
  {
    return this->file_.get ();
  }

  void T_source_position::
  setFile (const FileType& x)
  {
    this->file_.set (x);
  }

  const T_source_position::LineType& T_source_position::
  getLine () const
  {
    return this->line_.get ();
  }

  T_source_position::LineType& T_source_position::
  getLine ()
  {
    return this->line_.get ();
  }

  void T_source_position::
  setLine (const LineType& x)
  {
    this->line_.set (x);
  }

  const T_source_position::ColumnType& T_source_position::
  getColumn () const
  {
    return this->column_.get ();
  }

  T_source_position::ColumnType& T_source_position::
  getColumn ()
  {
    return this->column_.get ();
  }

  void T_source_position::
  setColumn (const ColumnType& x)
  {
    this->column_.set (x);
  }

  const T_source_position::OffsetType& T_source_position::
  getOffset () const
  {
    return this->offset_.get ();
  }

  T_source_position::OffsetType& T_source_position::
  getOffset ()
  {
    return this->offset_.get ();
  }

  void T_source_position::
  setOffset (const OffsetType& x)
  {
    this->offset_.set (x);
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace poosl
{
  // T_filename
  //

  T_filename::
  T_filename ()
  : ::xml_schema::String ()
  {
  }

  T_filename::
  T_filename (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  T_filename::
  T_filename (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  T_filename::
  T_filename (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  T_filename::
  T_filename (const T_filename& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  T_filename::
  T_filename (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  T_filename::
  T_filename (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  T_filename::
  T_filename (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  T_filename* T_filename::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_filename (*this, f, c);
  }

  T_filename::
  ~T_filename ()
  {
  }

  // T_command
  //

  T_command::
  T_command (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_command_convert ();
  }

  T_command::
  T_command (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_command_convert ();
  }

  T_command::
  T_command (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_command_convert ();
  }

  T_command* T_command::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_command (*this, f, c);
  }

  T_command::Value T_command::
  _xsd_T_command_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_command_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_command_indexes_,
                      _xsd_T_command_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_T_command_indexes_ + 7 || _xsd_T_command_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_command::
  _xsd_T_command_literals_[7] =
  {
    "run",
    "pause",
    "stop",
    "step",
    "time-step",
    "comm-step",
    "process-step"
  };

  const T_command::Value T_command::
  _xsd_T_command_indexes_[7] =
  {
    ::poosl::T_command::comm_step,
    ::poosl::T_command::pause,
    ::poosl::T_command::process_step,
    ::poosl::T_command::run,
    ::poosl::T_command::step,
    ::poosl::T_command::stop,
    ::poosl::T_command::time_step
  };

  // T_command_result
  //

  T_command_result::
  T_command_result (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_command_result_convert ();
  }

  T_command_result::
  T_command_result (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_command_result_convert ();
  }

  T_command_result::
  T_command_result (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_command_result_convert ();
  }

  T_command_result* T_command_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_command_result (*this, f, c);
  }

  T_command_result::Value T_command_result::
  _xsd_T_command_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_command_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_command_result_indexes_,
                      _xsd_T_command_result_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_T_command_result_indexes_ + 5 || _xsd_T_command_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_command_result::
  _xsd_T_command_result_literals_[5] =
  {
    "ok",
    "no design loaded",
    "error",
    "unknown",
    "breakpoint hit"
  };

  const T_command_result::Value T_command_result::
  _xsd_T_command_result_indexes_[5] =
  {
    ::poosl::T_command_result::breakpoint_hit,
    ::poosl::T_command_result::error,
    ::poosl::T_command_result::no_design_loaded,
    ::poosl::T_command_result::ok,
    ::poosl::T_command_result::unknown
  };

  // T_set_variable_result
  //

  T_set_variable_result::
  T_set_variable_result (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_set_variable_result_convert ();
  }

  T_set_variable_result::
  T_set_variable_result (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_set_variable_result_convert ();
  }

  T_set_variable_result::
  T_set_variable_result (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_set_variable_result_convert ();
  }

  T_set_variable_result* T_set_variable_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_set_variable_result (*this, f, c);
  }

  T_set_variable_result::Value T_set_variable_result::
  _xsd_T_set_variable_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_set_variable_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_set_variable_result_indexes_,
                      _xsd_T_set_variable_result_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_T_set_variable_result_indexes_ + 5 || _xsd_T_set_variable_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_set_variable_result::
  _xsd_T_set_variable_result_literals_[5] =
  {
    "unknown",
    "ok",
    "error",
    "invalid_var_handle",
    "invalid_list_handle"
  };

  const T_set_variable_result::Value T_set_variable_result::
  _xsd_T_set_variable_result_indexes_[5] =
  {
    ::poosl::T_set_variable_result::error,
    ::poosl::T_set_variable_result::invalid_list_handle,
    ::poosl::T_set_variable_result::invalid_var_handle,
    ::poosl::T_set_variable_result::ok,
    ::poosl::T_set_variable_result::unknown
  };

  // T_observe_aspect
  //

  T_observe_aspect::
  T_observe_aspect (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_observe_aspect_convert ();
  }

  T_observe_aspect::
  T_observe_aspect (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_observe_aspect_convert ();
  }

  T_observe_aspect::
  T_observe_aspect (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_observe_aspect_convert ();
  }

  T_observe_aspect* T_observe_aspect::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_observe_aspect (*this, f, c);
  }

  T_observe_aspect::Value T_observe_aspect::
  _xsd_T_observe_aspect_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_observe_aspect_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_observe_aspect_indexes_,
                      _xsd_T_observe_aspect_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_T_observe_aspect_indexes_ + 2 || _xsd_T_observe_aspect_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_observe_aspect::
  _xsd_T_observe_aspect_literals_[2] =
  {
    "terminated",
    "state_changed"
  };

  const T_observe_aspect::Value T_observe_aspect::
  _xsd_T_observe_aspect_indexes_[2] =
  {
    ::poosl::T_observe_aspect::state_changed,
    ::poosl::T_observe_aspect::terminated
  };

  // T_reqid
  //

  T_reqid::
  T_reqid ()
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > ()
  {
  }

  T_reqid::
  T_reqid (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  T_reqid::
  T_reqid (const T_reqid& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  T_reqid::
  T_reqid (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  T_reqid::
  T_reqid (const ::xercesc::DOMAttr& a,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  T_reqid::
  T_reqid (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  T_reqid* T_reqid::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_reqid (*this, f, c);
  }

  T_reqid::
  ~T_reqid ()
  {
  }

  // T_handle
  //

  T_handle::
  T_handle ()
  : ::xml_schema::Type (),
    id_ (this),
    type_ (this)
  {
  }

  T_handle::
  T_handle (const IdType& id,
            const TypeType& type)
  : ::xml_schema::Type (),
    id_ (id, this),
    type_ (type, this)
  {
  }

  T_handle::
  T_handle (const T_handle& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    id_ (x.id_, f, this),
    type_ (x.type_, f, this)
  {
  }

  T_handle::
  T_handle (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    id_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_handle::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // id
      //
      if (n.name () == "id" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< IdType > r (
          IdTraits::create (i, f, this));

        if (!id_.present ())
        {
          this->id_.set (::std::move (r));
          continue;
        }
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< TypeType > r (
          TypeTraits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "id",
        "uri:poosl");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "uri:poosl");
    }
  }

  T_handle* T_handle::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_handle (*this, f, c);
  }

  T_handle& T_handle::
  operator= (const T_handle& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->id_ = x.id_;
      this->type_ = x.type_;
    }

    return *this;
  }

  T_handle::
  ~T_handle ()
  {
  }

  // T_handle_id
  //

  T_handle_id::
  T_handle_id ()
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > ()
  {
  }

  T_handle_id::
  T_handle_id (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  T_handle_id::
  T_handle_id (const T_handle_id& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  T_handle_id::
  T_handle_id (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  T_handle_id::
  T_handle_id (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  T_handle_id::
  T_handle_id (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  T_handle_id* T_handle_id::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_handle_id (*this, f, c);
  }

  T_handle_id::
  ~T_handle_id ()
  {
  }

  // T_handle_type
  //

  T_handle_type::
  T_handle_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_handle_type_convert ();
  }

  T_handle_type::
  T_handle_type (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_handle_type_convert ();
  }

  T_handle_type::
  T_handle_type (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_handle_type_convert ();
  }

  T_handle_type* T_handle_type::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_handle_type (*this, f, c);
  }

  T_handle_type::Value T_handle_type::
  _xsd_T_handle_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_handle_type_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_handle_type_indexes_,
                      _xsd_T_handle_type_indexes_ + 8,
                      *this,
                      c));

    if (i == _xsd_T_handle_type_indexes_ + 8 || _xsd_T_handle_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_handle_type::
  _xsd_T_handle_type_literals_[8] =
  {
    "poosl_specification",
    "cluster_class",
    "process_class",
    "data_class",
    "initial_method_call",
    "process_method",
    "data_method",
    "expression"
  };

  const T_handle_type::Value T_handle_type::
  _xsd_T_handle_type_indexes_[8] =
  {
    ::poosl::T_handle_type::cluster_class,
    ::poosl::T_handle_type::data_class,
    ::poosl::T_handle_type::data_method,
    ::poosl::T_handle_type::expression,
    ::poosl::T_handle_type::initial_method_call,
    ::poosl::T_handle_type::poosl_specification,
    ::poosl::T_handle_type::process_class,
    ::poosl::T_handle_type::process_method
  };

  // T_inspect_type
  //

  T_inspect_type::
  T_inspect_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_inspect_type_convert ();
  }

  T_inspect_type::
  T_inspect_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_inspect_type_convert ();
  }

  T_inspect_type::
  T_inspect_type (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_inspect_type_convert ();
  }

  T_inspect_type* T_inspect_type::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_type (*this, f, c);
  }

  T_inspect_type::Value T_inspect_type::
  _xsd_T_inspect_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_inspect_type_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_inspect_type_indexes_,
                      _xsd_T_inspect_type_indexes_ + 8,
                      *this,
                      c));

    if (i == _xsd_T_inspect_type_indexes_ + 8 || _xsd_T_inspect_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_inspect_type::
  _xsd_T_inspect_type_literals_[8] =
  {
    "process",
    "system",
    "channel",
    "port",
    "variable",
    "data",
    "stackframe",
    "variable_context"
  };

  const T_inspect_type::Value T_inspect_type::
  _xsd_T_inspect_type_indexes_[8] =
  {
    ::poosl::T_inspect_type::channel,
    ::poosl::T_inspect_type::data,
    ::poosl::T_inspect_type::port,
    ::poosl::T_inspect_type::process,
    ::poosl::T_inspect_type::stackframe,
    ::poosl::T_inspect_type::system,
    ::poosl::T_inspect_type::variable,
    ::poosl::T_inspect_type::variable_context
  };

  // T_instance_name
  //

  T_instance_name::
  T_instance_name ()
  : ::xml_schema::String ()
  {
  }

  T_instance_name::
  T_instance_name (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  T_instance_name::
  T_instance_name (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  T_instance_name::
  T_instance_name (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  T_instance_name::
  T_instance_name (const T_instance_name& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  T_instance_name::
  T_instance_name (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  T_instance_name::
  T_instance_name (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  T_instance_name::
  T_instance_name (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  T_instance_name* T_instance_name::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_instance_name (*this, f, c);
  }

  T_instance_name::
  ~T_instance_name ()
  {
  }

  // T_box
  //

  T_box::
  T_box ()
  : ::xml_schema::Type (),
    left_ (this),
    top_ (this),
    right_ (this),
    bottom_ (this)
  {
  }

  T_box::
  T_box (const LeftType& left,
         const TopType& top,
         const RightType& right,
         const BottomType& bottom)
  : ::xml_schema::Type (),
    left_ (left, this),
    top_ (top, this),
    right_ (right, this),
    bottom_ (bottom, this)
  {
  }

  T_box::
  T_box (const T_box& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    left_ (x.left_, f, this),
    top_ (x.top_, f, this),
    right_ (x.right_, f, this),
    bottom_ (x.bottom_, f, this)
  {
  }

  T_box::
  T_box (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    left_ (this),
    top_ (this),
    right_ (this),
    bottom_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void T_box::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "left" && n.namespace_ ().empty ())
      {
        this->left_.set (LeftTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "top" && n.namespace_ ().empty ())
      {
        this->top_.set (TopTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "right" && n.namespace_ ().empty ())
      {
        this->right_.set (RightTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "bottom" && n.namespace_ ().empty ())
      {
        this->bottom_.set (BottomTraits::create (i, f, this));
        continue;
      }
    }

    if (!left_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "left",
        "");
    }

    if (!top_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "top",
        "");
    }

    if (!right_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "right",
        "");
    }

    if (!bottom_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "bottom",
        "");
    }
  }

  T_box* T_box::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_box (*this, f, c);
  }

  T_box& T_box::
  operator= (const T_box& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->left_ = x.left_;
      this->top_ = x.top_;
      this->right_ = x.right_;
      this->bottom_ = x.bottom_;
    }

    return *this;
  }

  T_box::
  ~T_box ()
  {
  }

  // T_point
  //

  T_point::
  T_point ()
  : ::xml_schema::Type (),
    x_ (this),
    y_ (this)
  {
  }

  T_point::
  T_point (const XType& x,
           const YType& y)
  : ::xml_schema::Type (),
    x_ (x, this),
    y_ (y, this)
  {
  }

  T_point::
  T_point (const T_point& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  T_point::
  T_point (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (this),
    y_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void T_point::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (XTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (YTraits::create (i, f, this));
        continue;
      }
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "y",
        "");
    }
  }

  T_point* T_point::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_point (*this, f, c);
  }

  T_point& T_point::
  operator= (const T_point& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
    }

    return *this;
  }

  T_point::
  ~T_point ()
  {
  }

  // T_transition
  //

  T_transition::
  T_transition ()
  : ::xml_schema::Type (),
    communication_ (this),
    process_step_ (this),
    data_step_ (this),
    delay_ (this)
  {
  }

  T_transition::
  T_transition (const T_transition& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    communication_ (x.communication_, f, this),
    process_step_ (x.process_step_, f, this),
    data_step_ (x.data_step_, f, this),
    delay_ (x.delay_, f, this)
  {
  }

  T_transition::
  T_transition (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    communication_ (this),
    process_step_ (this),
    data_step_ (this),
    delay_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_transition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // communication
      //
      if (n.name () == "communication" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< CommunicationType > r (
          CommunicationTraits::create (i, f, this));

        if (!this->communication_)
        {
          this->communication_.set (::std::move (r));
          continue;
        }
      }

      // process_step
      //
      if (n.name () == "process_step" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_stepType > r (
          Process_stepTraits::create (i, f, this));

        if (!this->process_step_)
        {
          this->process_step_.set (::std::move (r));
          continue;
        }
      }

      // data_step
      //
      if (n.name () == "data_step" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Data_stepType > r (
          Data_stepTraits::create (i, f, this));

        if (!this->data_step_)
        {
          this->data_step_.set (::std::move (r));
          continue;
        }
      }

      // delay
      //
      if (n.name () == "delay" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< DelayType > r (
          DelayTraits::create (i, f, this));

        if (!this->delay_)
        {
          this->delay_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  T_transition* T_transition::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_transition (*this, f, c);
  }

  T_transition& T_transition::
  operator= (const T_transition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->communication_ = x.communication_;
      this->process_step_ = x.process_step_;
      this->data_step_ = x.data_step_;
      this->delay_ = x.delay_;
    }

    return *this;
  }

  T_transition::
  ~T_transition ()
  {
  }

  // T_communication_transition
  //

  T_communication_transition::
  T_communication_transition ()
  : ::xml_schema::Type (),
    sender_ (this),
    receiver_ (this),
    handle_ (this)
  {
  }

  T_communication_transition::
  T_communication_transition (const SenderType& sender,
                              const ReceiverType& receiver,
                              const HandleType& handle)
  : ::xml_schema::Type (),
    sender_ (sender, this),
    receiver_ (receiver, this),
    handle_ (handle, this)
  {
  }

  T_communication_transition::
  T_communication_transition (::std::unique_ptr< SenderType > sender,
                              ::std::unique_ptr< ReceiverType > receiver,
                              const HandleType& handle)
  : ::xml_schema::Type (),
    sender_ (std::move (sender), this),
    receiver_ (std::move (receiver), this),
    handle_ (handle, this)
  {
  }

  T_communication_transition::
  T_communication_transition (const T_communication_transition& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    sender_ (x.sender_, f, this),
    receiver_ (x.receiver_, f, this),
    handle_ (x.handle_, f, this)
  {
  }

  T_communication_transition::
  T_communication_transition (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    sender_ (this),
    receiver_ (this),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_communication_transition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sender
      //
      if (n.name () == "sender" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SenderType > r (
          SenderTraits::create (i, f, this));

        if (!sender_.present ())
        {
          this->sender_.set (::std::move (r));
          continue;
        }
      }

      // receiver
      //
      if (n.name () == "receiver" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ReceiverType > r (
          ReceiverTraits::create (i, f, this));

        if (!receiver_.present ())
        {
          this->receiver_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!sender_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "sender",
        "uri:poosl");
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "receiver",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "handle" && n.namespace_ ().empty ())
      {
        this->handle_.set (HandleTraits::create (i, f, this));
        continue;
      }
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }
  }

  T_communication_transition* T_communication_transition::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_communication_transition (*this, f, c);
  }

  T_communication_transition& T_communication_transition::
  operator= (const T_communication_transition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->sender_ = x.sender_;
      this->receiver_ = x.receiver_;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  T_communication_transition::
  ~T_communication_transition ()
  {
  }

  // T_sender_info
  //

  T_sender_info::
  T_sender_info ()
  : ::xml_schema::Type (),
    process_path_ (this),
    handle_ (this),
    port_ (this),
    message_ (this),
    parameter_count_ (this),
    node_ (this)
  {
  }

  T_sender_info::
  T_sender_info (const Process_pathType& process_path,
                 const HandleType& handle,
                 const PortType& port,
                 const MessageType& message,
                 const Parameter_countType& parameter_count,
                 const NodeType& node)
  : ::xml_schema::Type (),
    process_path_ (process_path, this),
    handle_ (handle, this),
    port_ (port, this),
    message_ (message, this),
    parameter_count_ (parameter_count, this),
    node_ (node, this)
  {
  }

  T_sender_info::
  T_sender_info (const T_sender_info& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    process_path_ (x.process_path_, f, this),
    handle_ (x.handle_, f, this),
    port_ (x.port_, f, this),
    message_ (x.message_, f, this),
    parameter_count_ (x.parameter_count_, f, this),
    node_ (x.node_, f, this)
  {
  }

  T_sender_info::
  T_sender_info (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    process_path_ (this),
    handle_ (this),
    port_ (this),
    message_ (this),
    parameter_count_ (this),
    node_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_sender_info::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // process_path
      //
      if (n.name () == "process_path" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_pathType > r (
          Process_pathTraits::create (i, f, this));

        if (!process_path_.present ())
        {
          this->process_path_.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      // port
      //
      if (n.name () == "port" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< PortType > r (
          PortTraits::create (i, f, this));

        if (!port_.present ())
        {
          this->port_.set (::std::move (r));
          continue;
        }
      }

      // message
      //
      if (n.name () == "message" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< MessageType > r (
          MessageTraits::create (i, f, this));

        if (!message_.present ())
        {
          this->message_.set (::std::move (r));
          continue;
        }
      }

      // parameter_count
      //
      if (n.name () == "parameter_count" && n.namespace_ () == "uri:poosl")
      {
        if (!parameter_count_.present ())
        {
          this->parameter_count_.set (Parameter_countTraits::create (i, f, this));
          continue;
        }
      }

      // node
      //
      if (n.name () == "node" && n.namespace_ () == "uri:poosl")
      {
        if (!node_.present ())
        {
          this->node_.set (NodeTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!process_path_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "process_path",
        "uri:poosl");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "port",
        "uri:poosl");
    }

    if (!message_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "message",
        "uri:poosl");
    }

    if (!parameter_count_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter_count",
        "uri:poosl");
    }

    if (!node_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "node",
        "uri:poosl");
    }
  }

  T_sender_info* T_sender_info::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_sender_info (*this, f, c);
  }

  T_sender_info& T_sender_info::
  operator= (const T_sender_info& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->process_path_ = x.process_path_;
      this->handle_ = x.handle_;
      this->port_ = x.port_;
      this->message_ = x.message_;
      this->parameter_count_ = x.parameter_count_;
      this->node_ = x.node_;
    }

    return *this;
  }

  T_sender_info::
  ~T_sender_info ()
  {
  }

  // T_receiver_info
  //

  T_receiver_info::
  T_receiver_info ()
  : ::xml_schema::Type (),
    process_path_ (this),
    handle_ (this),
    port_ (this),
    message_ (this),
    parameter_count_ (this),
    node_ (this)
  {
  }

  T_receiver_info::
  T_receiver_info (const Process_pathType& process_path,
                   const HandleType& handle,
                   const PortType& port,
                   const MessageType& message,
                   const Parameter_countType& parameter_count,
                   const NodeType& node)
  : ::xml_schema::Type (),
    process_path_ (process_path, this),
    handle_ (handle, this),
    port_ (port, this),
    message_ (message, this),
    parameter_count_ (parameter_count, this),
    node_ (node, this)
  {
  }

  T_receiver_info::
  T_receiver_info (const T_receiver_info& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    process_path_ (x.process_path_, f, this),
    handle_ (x.handle_, f, this),
    port_ (x.port_, f, this),
    message_ (x.message_, f, this),
    parameter_count_ (x.parameter_count_, f, this),
    node_ (x.node_, f, this)
  {
  }

  T_receiver_info::
  T_receiver_info (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    process_path_ (this),
    handle_ (this),
    port_ (this),
    message_ (this),
    parameter_count_ (this),
    node_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_receiver_info::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // process_path
      //
      if (n.name () == "process_path" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_pathType > r (
          Process_pathTraits::create (i, f, this));

        if (!process_path_.present ())
        {
          this->process_path_.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      // port
      //
      if (n.name () == "port" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< PortType > r (
          PortTraits::create (i, f, this));

        if (!port_.present ())
        {
          this->port_.set (::std::move (r));
          continue;
        }
      }

      // message
      //
      if (n.name () == "message" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< MessageType > r (
          MessageTraits::create (i, f, this));

        if (!message_.present ())
        {
          this->message_.set (::std::move (r));
          continue;
        }
      }

      // parameter_count
      //
      if (n.name () == "parameter_count" && n.namespace_ () == "uri:poosl")
      {
        if (!parameter_count_.present ())
        {
          this->parameter_count_.set (Parameter_countTraits::create (i, f, this));
          continue;
        }
      }

      // node
      //
      if (n.name () == "node" && n.namespace_ () == "uri:poosl")
      {
        if (!node_.present ())
        {
          this->node_.set (NodeTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!process_path_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "process_path",
        "uri:poosl");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "port",
        "uri:poosl");
    }

    if (!message_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "message",
        "uri:poosl");
    }

    if (!parameter_count_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameter_count",
        "uri:poosl");
    }

    if (!node_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "node",
        "uri:poosl");
    }
  }

  T_receiver_info* T_receiver_info::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_receiver_info (*this, f, c);
  }

  T_receiver_info& T_receiver_info::
  operator= (const T_receiver_info& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->process_path_ = x.process_path_;
      this->handle_ = x.handle_;
      this->port_ = x.port_;
      this->message_ = x.message_;
      this->parameter_count_ = x.parameter_count_;
      this->node_ = x.node_;
    }

    return *this;
  }

  T_receiver_info::
  ~T_receiver_info ()
  {
  }

  // T_process_step_transition
  //

  T_process_step_transition::
  T_process_step_transition ()
  : ::xml_schema::Type (),
    process_path_ (this),
    node_ (this),
    handle_ (this)
  {
  }

  T_process_step_transition::
  T_process_step_transition (const Process_pathType& process_path,
                             const NodeType& node,
                             const HandleType& handle)
  : ::xml_schema::Type (),
    process_path_ (process_path, this),
    node_ (node, this),
    handle_ (handle, this)
  {
  }

  T_process_step_transition::
  T_process_step_transition (const T_process_step_transition& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    process_path_ (x.process_path_, f, this),
    node_ (x.node_, f, this),
    handle_ (x.handle_, f, this)
  {
  }

  T_process_step_transition::
  T_process_step_transition (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    process_path_ (this),
    node_ (this),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_process_step_transition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // process_path
      //
      if (n.name () == "process_path" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_pathType > r (
          Process_pathTraits::create (i, f, this));

        if (!process_path_.present ())
        {
          this->process_path_.set (::std::move (r));
          continue;
        }
      }

      // node
      //
      if (n.name () == "node" && n.namespace_ () == "uri:poosl")
      {
        if (!node_.present ())
        {
          this->node_.set (NodeTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!process_path_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "process_path",
        "uri:poosl");
    }

    if (!node_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "node",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "handle" && n.namespace_ ().empty ())
      {
        this->handle_.set (HandleTraits::create (i, f, this));
        continue;
      }
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }
  }

  T_process_step_transition* T_process_step_transition::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_process_step_transition (*this, f, c);
  }

  T_process_step_transition& T_process_step_transition::
  operator= (const T_process_step_transition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->process_path_ = x.process_path_;
      this->node_ = x.node_;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  T_process_step_transition::
  ~T_process_step_transition ()
  {
  }

  // T_data_step_transition
  //

  T_data_step_transition::
  T_data_step_transition ()
  : ::xml_schema::Type (),
    process_path_ (this),
    node_ (this),
    handle_ (this)
  {
  }

  T_data_step_transition::
  T_data_step_transition (const Process_pathType& process_path,
                          const NodeType& node,
                          const HandleType& handle)
  : ::xml_schema::Type (),
    process_path_ (process_path, this),
    node_ (node, this),
    handle_ (handle, this)
  {
  }

  T_data_step_transition::
  T_data_step_transition (const T_data_step_transition& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    process_path_ (x.process_path_, f, this),
    node_ (x.node_, f, this),
    handle_ (x.handle_, f, this)
  {
  }

  T_data_step_transition::
  T_data_step_transition (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    process_path_ (this),
    node_ (this),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_data_step_transition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // process_path
      //
      if (n.name () == "process_path" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_pathType > r (
          Process_pathTraits::create (i, f, this));

        if (!process_path_.present ())
        {
          this->process_path_.set (::std::move (r));
          continue;
        }
      }

      // node
      //
      if (n.name () == "node" && n.namespace_ () == "uri:poosl")
      {
        if (!node_.present ())
        {
          this->node_.set (NodeTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!process_path_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "process_path",
        "uri:poosl");
    }

    if (!node_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "node",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "handle" && n.namespace_ ().empty ())
      {
        this->handle_.set (HandleTraits::create (i, f, this));
        continue;
      }
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }
  }

  T_data_step_transition* T_data_step_transition::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_data_step_transition (*this, f, c);
  }

  T_data_step_transition& T_data_step_transition::
  operator= (const T_data_step_transition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->process_path_ = x.process_path_;
      this->node_ = x.node_;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  T_data_step_transition::
  ~T_data_step_transition ()
  {
  }

  // T_delay_transition
  //

  T_delay_transition::
  T_delay_transition ()
  : ::xml_schema::Type (),
    period_ (this),
    node_ (this),
    process_path_ (this),
    handle_ (this)
  {
  }

  T_delay_transition::
  T_delay_transition (const PeriodType& period,
                      const NodeType& node,
                      const Process_pathType& process_path,
                      const HandleType& handle)
  : ::xml_schema::Type (),
    period_ (period, this),
    node_ (node, this),
    process_path_ (process_path, this),
    handle_ (handle, this)
  {
  }

  T_delay_transition::
  T_delay_transition (const T_delay_transition& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    period_ (x.period_, f, this),
    node_ (x.node_, f, this),
    process_path_ (x.process_path_, f, this),
    handle_ (x.handle_, f, this)
  {
  }

  T_delay_transition::
  T_delay_transition (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    period_ (this),
    node_ (this),
    process_path_ (this),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_delay_transition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // period
      //
      if (n.name () == "period" && n.namespace_ () == "uri:poosl")
      {
        if (!period_.present ())
        {
          this->period_.set (PeriodTraits::create (i, f, this));
          continue;
        }
      }

      // node
      //
      if (n.name () == "node" && n.namespace_ () == "uri:poosl")
      {
        if (!node_.present ())
        {
          this->node_.set (NodeTraits::create (i, f, this));
          continue;
        }
      }

      // process_path
      //
      if (n.name () == "process_path" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_pathType > r (
          Process_pathTraits::create (i, f, this));

        if (!process_path_.present ())
        {
          this->process_path_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!period_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "period",
        "uri:poosl");
    }

    if (!node_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "node",
        "uri:poosl");
    }

    if (!process_path_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "process_path",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "handle" && n.namespace_ ().empty ())
      {
        this->handle_.set (HandleTraits::create (i, f, this));
        continue;
      }
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }
  }

  T_delay_transition* T_delay_transition::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_delay_transition (*this, f, c);
  }

  T_delay_transition& T_delay_transition::
  operator= (const T_delay_transition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->period_ = x.period_;
      this->node_ = x.node_;
      this->process_path_ = x.process_path_;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  T_delay_transition::
  ~T_delay_transition ()
  {
  }

  // T_transition_list
  //

  T_transition_list::
  T_transition_list ()
  : ::xml_schema::Type (),
    transition_ (this)
  {
  }

  T_transition_list::
  T_transition_list (const T_transition_list& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    transition_ (x.transition_, f, this)
  {
  }

  T_transition_list::
  T_transition_list (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    transition_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_transition_list::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // transition
      //
      if (n.name () == "transition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< TransitionType > r (
          TransitionTraits::create (i, f, this));

        this->transition_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_transition_list* T_transition_list::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_transition_list (*this, f, c);
  }

  T_transition_list& T_transition_list::
  operator= (const T_transition_list& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->transition_ = x.transition_;
    }

    return *this;
  }

  T_transition_list::
  ~T_transition_list ()
  {
  }

  // T_source_position
  //

  T_source_position::
  T_source_position ()
  : ::xml_schema::Type (),
    file_ (this),
    line_ (this),
    column_ (this),
    offset_ (this)
  {
  }

  T_source_position::
  T_source_position (const FileType& file,
                     const LineType& line,
                     const ColumnType& column,
                     const OffsetType& offset)
  : ::xml_schema::Type (),
    file_ (file, this),
    line_ (line, this),
    column_ (column, this),
    offset_ (offset, this)
  {
  }

  T_source_position::
  T_source_position (const T_source_position& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    file_ (x.file_, f, this),
    line_ (x.line_, f, this),
    column_ (x.column_, f, this),
    offset_ (x.offset_, f, this)
  {
  }

  T_source_position::
  T_source_position (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    file_ (this),
    line_ (this),
    column_ (this),
    offset_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_source_position::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // file
      //
      if (n.name () == "file" && n.namespace_ () == "uri:poosl")
      {
        if (!file_.present ())
        {
          this->file_.set (FileTraits::create (i, f, this));
          continue;
        }
      }

      // line
      //
      if (n.name () == "line" && n.namespace_ () == "uri:poosl")
      {
        if (!line_.present ())
        {
          this->line_.set (LineTraits::create (i, f, this));
          continue;
        }
      }

      // column
      //
      if (n.name () == "column" && n.namespace_ () == "uri:poosl")
      {
        if (!column_.present ())
        {
          this->column_.set (ColumnTraits::create (i, f, this));
          continue;
        }
      }

      // offset
      //
      if (n.name () == "offset" && n.namespace_ () == "uri:poosl")
      {
        if (!offset_.present ())
        {
          this->offset_.set (OffsetTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!file_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "file",
        "uri:poosl");
    }

    if (!line_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "line",
        "uri:poosl");
    }

    if (!column_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "column",
        "uri:poosl");
    }

    if (!offset_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "offset",
        "uri:poosl");
    }
  }

  T_source_position* T_source_position::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_source_position (*this, f, c);
  }

  T_source_position& T_source_position::
  operator= (const T_source_position& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->file_ = x.file_;
      this->line_ = x.line_;
      this->column_ = x.column_;
      this->offset_ = x.offset_;
    }

    return *this;
  }

  T_source_position::
  ~T_source_position ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace poosl
{
  ::std::ostream&
  operator<< (::std::ostream& o, const T_filename& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_command::Value i)
  {
    return o << T_command::_xsd_T_command_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_command& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_command_result::Value i)
  {
    return o << T_command_result::_xsd_T_command_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_command_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_set_variable_result::Value i)
  {
    return o << T_set_variable_result::_xsd_T_set_variable_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_set_variable_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_observe_aspect::Value i)
  {
    return o << T_observe_aspect::_xsd_T_observe_aspect_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_observe_aspect& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_reqid& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_handle& i)
  {
    o << ::std::endl << "id: " << i.getId ();
    o << ::std::endl << "type: " << i.getType ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_handle_id& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_handle_type::Value i)
  {
    return o << T_handle_type::_xsd_T_handle_type_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_handle_type& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_inspect_type::Value i)
  {
    return o << T_inspect_type::_xsd_T_inspect_type_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_type& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_instance_name& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_box& i)
  {
    o << ::std::endl << "left: " << i.getLeft ();
    o << ::std::endl << "top: " << i.getTop ();
    o << ::std::endl << "right: " << i.getRight ();
    o << ::std::endl << "bottom: " << i.getBottom ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_point& i)
  {
    o << ::std::endl << "x: " << i.getX ();
    o << ::std::endl << "y: " << i.getY ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_transition& i)
  {
    if (i.getCommunication ())
    {
      o << ::std::endl << "communication: " << *i.getCommunication ();
    }

    if (i.getProcess_step ())
    {
      o << ::std::endl << "process_step: " << *i.getProcess_step ();
    }

    if (i.getData_step ())
    {
      o << ::std::endl << "data_step: " << *i.getData_step ();
    }

    if (i.getDelay ())
    {
      o << ::std::endl << "delay: " << *i.getDelay ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_communication_transition& i)
  {
    o << ::std::endl << "sender: " << i.getSender ();
    o << ::std::endl << "receiver: " << i.getReceiver ();
    o << ::std::endl << "handle: " << i.getHandle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_sender_info& i)
  {
    o << ::std::endl << "process_path: " << i.getProcess_path ();
    o << ::std::endl << "handle: " << i.getHandle ();
    o << ::std::endl << "port: " << i.getPort ();
    o << ::std::endl << "message: " << i.getMessage ();
    o << ::std::endl << "parameter_count: " << i.getParameter_count ();
    o << ::std::endl << "node: " << i.getNode ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_receiver_info& i)
  {
    o << ::std::endl << "process_path: " << i.getProcess_path ();
    o << ::std::endl << "handle: " << i.getHandle ();
    o << ::std::endl << "port: " << i.getPort ();
    o << ::std::endl << "message: " << i.getMessage ();
    o << ::std::endl << "parameter_count: " << i.getParameter_count ();
    o << ::std::endl << "node: " << i.getNode ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_process_step_transition& i)
  {
    o << ::std::endl << "process_path: " << i.getProcess_path ();
    o << ::std::endl << "node: " << i.getNode ();
    o << ::std::endl << "handle: " << i.getHandle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_data_step_transition& i)
  {
    o << ::std::endl << "process_path: " << i.getProcess_path ();
    o << ::std::endl << "node: " << i.getNode ();
    o << ::std::endl << "handle: " << i.getHandle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_delay_transition& i)
  {
    o << ::std::endl << "period: " << i.getPeriod ();
    o << ::std::endl << "node: " << i.getNode ();
    o << ::std::endl << "process_path: " << i.getProcess_path ();
    o << ::std::endl << "handle: " << i.getHandle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_transition_list& i)
  {
    for (T_transition_list::TransitionConstIterator
         b (i.getTransition ().begin ()), e (i.getTransition ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "transition: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_source_position& i)
  {
    o << ::std::endl << "file: " << i.getFile ();
    o << ::std::endl << "line: " << i.getLine ();
    o << ::std::endl << "column: " << i.getColumn ();
    o << ::std::endl << "offset: " << i.getOffset ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace poosl
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace poosl
{
  void
  operator<< (::xercesc::DOMElement& e, const T_filename& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_filename& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_filename& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_command& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_command& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_command& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_command_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_command_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_command_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_set_variable_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_set_variable_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_set_variable_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_observe_aspect& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_observe_aspect& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_observe_aspect& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_reqid& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_reqid& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_reqid& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_handle& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "id",
          "uri:poosl",
          e));

      s << i.getId ();
    }

    // type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          "uri:poosl",
          e));

      s << i.getType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_handle_id& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_handle_id& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_handle_id& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_handle_type& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_handle_type& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_handle_type& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_type& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_inspect_type& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_inspect_type& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_instance_name& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_instance_name& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_instance_name& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_box& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // left
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "left",
          e));

      a << i.getLeft ();
    }

    // top
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "top",
          e));

      a << i.getTop ();
    }

    // right
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "right",
          e));

      a << i.getRight ();
    }

    // bottom
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "bottom",
          e));

      a << i.getBottom ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_point& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << i.getX ();
    }

    // y
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << i.getY ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_transition& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // communication
    //
    if (i.getCommunication ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "communication",
          "uri:poosl",
          e));

      s << *i.getCommunication ();
    }

    // process_step
    //
    if (i.getProcess_step ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_step",
          "uri:poosl",
          e));

      s << *i.getProcess_step ();
    }

    // data_step
    //
    if (i.getData_step ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data_step",
          "uri:poosl",
          e));

      s << *i.getData_step ();
    }

    // delay
    //
    if (i.getDelay ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "delay",
          "uri:poosl",
          e));

      s << *i.getDelay ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_communication_transition& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // sender
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sender",
          "uri:poosl",
          e));

      s << i.getSender ();
    }

    // receiver
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "receiver",
          "uri:poosl",
          e));

      s << i.getReceiver ();
    }

    // handle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "handle",
          e));

      a << i.getHandle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_sender_info& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // process_path
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_path",
          "uri:poosl",
          e));

      s << i.getProcess_path ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }

    // port
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "port",
          "uri:poosl",
          e));

      s << i.getPort ();
    }

    // message
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "message",
          "uri:poosl",
          e));

      s << i.getMessage ();
    }

    // parameter_count
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter_count",
          "uri:poosl",
          e));

      s << i.getParameter_count ();
    }

    // node
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "node",
          "uri:poosl",
          e));

      s << i.getNode ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_receiver_info& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // process_path
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_path",
          "uri:poosl",
          e));

      s << i.getProcess_path ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }

    // port
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "port",
          "uri:poosl",
          e));

      s << i.getPort ();
    }

    // message
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "message",
          "uri:poosl",
          e));

      s << i.getMessage ();
    }

    // parameter_count
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter_count",
          "uri:poosl",
          e));

      s << i.getParameter_count ();
    }

    // node
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "node",
          "uri:poosl",
          e));

      s << i.getNode ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_process_step_transition& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // process_path
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_path",
          "uri:poosl",
          e));

      s << i.getProcess_path ();
    }

    // node
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "node",
          "uri:poosl",
          e));

      s << i.getNode ();
    }

    // handle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "handle",
          e));

      a << i.getHandle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_data_step_transition& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // process_path
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_path",
          "uri:poosl",
          e));

      s << i.getProcess_path ();
    }

    // node
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "node",
          "uri:poosl",
          e));

      s << i.getNode ();
    }

    // handle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "handle",
          e));

      a << i.getHandle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_delay_transition& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // period
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "period",
          "uri:poosl",
          e));

      s << ::xml_schema::AsDouble(i.getPeriod ());
    }

    // node
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "node",
          "uri:poosl",
          e));

      s << i.getNode ();
    }

    // process_path
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_path",
          "uri:poosl",
          e));

      s << i.getProcess_path ();
    }

    // handle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "handle",
          e));

      a << i.getHandle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_transition_list& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // transition
    //
    for (T_transition_list::TransitionConstIterator
         b (i.getTransition ().begin ()), n (i.getTransition ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "transition",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_source_position& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // file
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "file",
          "uri:poosl",
          e));

      s << i.getFile ();
    }

    // line
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "line",
          "uri:poosl",
          e));

      s << i.getLine ();
    }

    // column
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "column",
          "uri:poosl",
          e));

      s << i.getColumn ();
    }

    // offset
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "offset",
          "uri:poosl",
          e));

      s << i.getOffset ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

