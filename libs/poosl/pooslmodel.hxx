// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef POOSLMODEL_HXX
#define POOSLMODEL_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-iso8859-1.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type Type;
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;
  typedef ::xsd::cxx::tree::type Container;

  // 8-bit
  //
  typedef signed char Byte;
  typedef unsigned char UnsignedByte;

  // 16-bit
  //
  typedef short Short;
  typedef unsigned short UnsignedShort;

  // 32-bit
  //
  typedef int Int;
  typedef unsigned int UnsignedInt;

  // 64-bit
  //
  typedef long long Long;
  typedef unsigned long long UnsignedLong;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long Integer;
  typedef long long NonPositiveInteger;
  typedef unsigned long long NonNegativeInteger;
  typedef unsigned long long PositiveInteger;
  typedef long long NegativeInteger;

  // Boolean.
  //
  typedef bool Boolean;

  // Floating-point types.
  //
  typedef float Float;
  typedef double Double;
  typedef double Decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;
  typedef ::xsd::cxx::tree::name< char, Token > Name;
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;
  typedef ::xsd::cxx::tree::language< char, Token > Language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > Buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone TimeZone;
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;

  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags Flags;
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity Severity;
  typedef ::xsd::cxx::tree::error< char > Error;
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > Exception;
  typedef ::xsd::cxx::tree::bounds< char > Bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;
  typedef ::xsd::cxx::tree::parsing< char > Parsing;
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;
  typedef ::xsd::cxx::tree::no_type_info< char > NoTypeInfo;
  typedef ::xsd::cxx::tree::not_derived< char > NotDerived;
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace poosl
{
  class T_poosl_specification;
  class T_cluster_classes;
  class T_process_classes;
  class T_data_classes;
  class T_data_class;
  class T_data_method;
  class T_process_class;
  class T_process_method;
  class T_cluster_class;
  class T_top_level_specification;
  class T_channel_internal;
  class T_channel;
  class T_instance;
  class T_connection;
  class T_initial_method_call;
  class T_instantiation_expression;
  class T_interface;
  class T_port;
  class T_message;
  class T_cluster_interface;
  class T_instance_type;
  class T_annotation;
  class T_top_level_annotation;
  class T_data_class_annotation;
  class T_process_class_annotation;
  class T_cluster_class_annotation;
  class T_channel_annotation;
  class T_instance_annotation;
  class T_port_annotation;
  class T_connection_annotation;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-iso8859-1.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

#include "poosltypes.hxx"

#include "pooslstatements.hxx"

namespace poosl
{
  class T_poosl_specification: public ::xml_schema::Type
  {
    public:
    // name
    //
    typedef ::poosl::T_identifier NameType;
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameOptional&
    getName () const;

    NameOptional&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (const NameOptional& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // data_classes
    //
    typedef ::poosl::T_data_classes Data_classesType;
    typedef ::xsd::cxx::tree::traits< Data_classesType, char > Data_classesTraits;

    const Data_classesType&
    getData_classes () const;

    Data_classesType&
    getData_classes ();

    void
    setData_classes (const Data_classesType& x);

    void
    setData_classes (::std::unique_ptr< Data_classesType > p);

    // process_classes
    //
    typedef ::poosl::T_process_classes Process_classesType;
    typedef ::xsd::cxx::tree::optional< Process_classesType > Process_classesOptional;
    typedef ::xsd::cxx::tree::traits< Process_classesType, char > Process_classesTraits;

    const Process_classesOptional&
    getProcess_classes () const;

    Process_classesOptional&
    getProcess_classes ();

    void
    setProcess_classes (const Process_classesType& x);

    void
    setProcess_classes (const Process_classesOptional& x);

    void
    setProcess_classes (::std::unique_ptr< Process_classesType > p);

    // cluster_classes
    //
    typedef ::poosl::T_cluster_classes Cluster_classesType;
    typedef ::xsd::cxx::tree::optional< Cluster_classesType > Cluster_classesOptional;
    typedef ::xsd::cxx::tree::traits< Cluster_classesType, char > Cluster_classesTraits;

    const Cluster_classesOptional&
    getCluster_classes () const;

    Cluster_classesOptional&
    getCluster_classes ();

    void
    setCluster_classes (const Cluster_classesType& x);

    void
    setCluster_classes (const Cluster_classesOptional& x);

    void
    setCluster_classes (::std::unique_ptr< Cluster_classesType > p);

    // top_level_specification
    //
    typedef ::poosl::T_top_level_specification Top_level_specificationType;
    typedef ::xsd::cxx::tree::optional< Top_level_specificationType > Top_level_specificationOptional;
    typedef ::xsd::cxx::tree::traits< Top_level_specificationType, char > Top_level_specificationTraits;

    const Top_level_specificationOptional&
    getTop_level_specification () const;

    Top_level_specificationOptional&
    getTop_level_specification ();

    void
    setTop_level_specification (const Top_level_specificationType& x);

    void
    setTop_level_specification (const Top_level_specificationOptional& x);

    void
    setTop_level_specification (::std::unique_ptr< Top_level_specificationType > p);

    // description
    //
    typedef ::xml_schema::String DescriptionType;
    typedef ::xsd::cxx::tree::optional< DescriptionType > DescriptionOptional;
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    const DescriptionOptional&
    getDescription () const;

    DescriptionOptional&
    getDescription ();

    void
    setDescription (const DescriptionType& x);

    void
    setDescription (const DescriptionOptional& x);

    void
    setDescription (::std::unique_ptr< DescriptionType > p);

    // Constructors.
    //
    T_poosl_specification ();

    T_poosl_specification (const Data_classesType&);

    T_poosl_specification (::std::unique_ptr< Data_classesType >);

    T_poosl_specification (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_poosl_specification (const T_poosl_specification& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual T_poosl_specification*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_poosl_specification&
    operator= (const T_poosl_specification& x);

    virtual 
    ~T_poosl_specification ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NameOptional name_;
    ::xsd::cxx::tree::one< Data_classesType > data_classes_;
    Process_classesOptional process_classes_;
    Cluster_classesOptional cluster_classes_;
    Top_level_specificationOptional top_level_specification_;
    DescriptionOptional description_;
  };

  class T_cluster_classes: public ::xml_schema::Type
  {
    public:
    // cluster_class
    //
    typedef ::poosl::T_cluster_class Cluster_classType;
    typedef ::xsd::cxx::tree::sequence< Cluster_classType > Cluster_classSequence;
    typedef Cluster_classSequence::iterator Cluster_classIterator;
    typedef Cluster_classSequence::const_iterator Cluster_classConstIterator;
    typedef ::xsd::cxx::tree::traits< Cluster_classType, char > Cluster_classTraits;

    const Cluster_classSequence&
    getCluster_class () const;

    Cluster_classSequence&
    getCluster_class ();

    void
    setCluster_class (const Cluster_classSequence& s);

    // Constructors.
    //
    T_cluster_classes ();

    T_cluster_classes (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_cluster_classes (const T_cluster_classes& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_cluster_classes*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_cluster_classes&
    operator= (const T_cluster_classes& x);

    virtual 
    ~T_cluster_classes ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Cluster_classSequence cluster_class_;
  };

  class T_process_classes: public ::xml_schema::Type
  {
    public:
    // process_class
    //
    typedef ::poosl::T_process_class Process_classType;
    typedef ::xsd::cxx::tree::sequence< Process_classType > Process_classSequence;
    typedef Process_classSequence::iterator Process_classIterator;
    typedef Process_classSequence::const_iterator Process_classConstIterator;
    typedef ::xsd::cxx::tree::traits< Process_classType, char > Process_classTraits;

    const Process_classSequence&
    getProcess_class () const;

    Process_classSequence&
    getProcess_class ();

    void
    setProcess_class (const Process_classSequence& s);

    // Constructors.
    //
    T_process_classes ();

    T_process_classes (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_process_classes (const T_process_classes& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_process_classes*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_process_classes&
    operator= (const T_process_classes& x);

    virtual 
    ~T_process_classes ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Process_classSequence process_class_;
  };

  class T_data_classes: public ::xml_schema::Type
  {
    public:
    // data_class
    //
    typedef ::poosl::T_data_class Data_classType;
    typedef ::xsd::cxx::tree::sequence< Data_classType > Data_classSequence;
    typedef Data_classSequence::iterator Data_classIterator;
    typedef Data_classSequence::const_iterator Data_classConstIterator;
    typedef ::xsd::cxx::tree::traits< Data_classType, char > Data_classTraits;

    const Data_classSequence&
    getData_class () const;

    Data_classSequence&
    getData_class ();

    void
    setData_class (const Data_classSequence& s);

    // Constructors.
    //
    T_data_classes ();

    T_data_classes (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    T_data_classes (const T_data_classes& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual T_data_classes*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_data_classes&
    operator= (const T_data_classes& x);

    virtual 
    ~T_data_classes ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Data_classSequence data_class_;
  };

  class T_data_class: public ::xml_schema::Type
  {
    public:
    // super_class
    //
    typedef ::poosl::T_poosl_type Super_classType;
    typedef ::xsd::cxx::tree::optional< Super_classType > Super_classOptional;
    typedef ::xsd::cxx::tree::traits< Super_classType, char > Super_classTraits;

    const Super_classOptional&
    getSuper_class () const;

    Super_classOptional&
    getSuper_class ();

    void
    setSuper_class (const Super_classType& x);

    void
    setSuper_class (const Super_classOptional& x);

    void
    setSuper_class (::std::unique_ptr< Super_classType > p);

    // instance_variable
    //
    typedef ::poosl::T_typed_variable Instance_variableType;
    typedef ::xsd::cxx::tree::sequence< Instance_variableType > Instance_variableSequence;
    typedef Instance_variableSequence::iterator Instance_variableIterator;
    typedef Instance_variableSequence::const_iterator Instance_variableConstIterator;
    typedef ::xsd::cxx::tree::traits< Instance_variableType, char > Instance_variableTraits;

    const Instance_variableSequence&
    getInstance_variable () const;

    Instance_variableSequence&
    getInstance_variable ();

    void
    setInstance_variable (const Instance_variableSequence& s);

    // data_method
    //
    typedef ::poosl::T_data_method Data_methodType;
    typedef ::xsd::cxx::tree::sequence< Data_methodType > Data_methodSequence;
    typedef Data_methodSequence::iterator Data_methodIterator;
    typedef Data_methodSequence::const_iterator Data_methodConstIterator;
    typedef ::xsd::cxx::tree::traits< Data_methodType, char > Data_methodTraits;

    const Data_methodSequence&
    getData_method () const;

    Data_methodSequence&
    getData_method ();

    void
    setData_method (const Data_methodSequence& s);

    // annotation
    //
    typedef ::poosl::T_data_class_annotation AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // name
    //
    typedef ::poosl::T_poosl_type NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // native
    //
    typedef ::poosl::T_boolean NativeType;
    typedef ::xsd::cxx::tree::optional< NativeType > NativeOptional;
    typedef ::xsd::cxx::tree::traits< NativeType, char > NativeTraits;

    const NativeOptional&
    getNative () const;

    NativeOptional&
    getNative ();

    void
    setNative (const NativeType& x);

    void
    setNative (const NativeOptional& x);

    void
    setNative (::std::unique_ptr< NativeType > p);

    // Constructors.
    //
    T_data_class ();

    T_data_class (const NameType&);

    T_data_class (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    T_data_class (const T_data_class& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual T_data_class*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_data_class&
    operator= (const T_data_class& x);

    virtual 
    ~T_data_class ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Super_classOptional super_class_;
    Instance_variableSequence instance_variable_;
    Data_methodSequence data_method_;
    AnnotationOptional annotation_;
    ::xsd::cxx::tree::one< NameType > name_;
    NativeOptional native_;
  };

  class T_data_method: public ::xml_schema::Type
  {
    public:
    // return_type
    //
    typedef ::poosl::T_poosl_type Return_typeType;
    typedef ::xsd::cxx::tree::traits< Return_typeType, char > Return_typeTraits;

    const Return_typeType&
    getReturn_type () const;

    Return_typeType&
    getReturn_type ();

    void
    setReturn_type (const Return_typeType& x);

    void
    setReturn_type (::std::unique_ptr< Return_typeType > p);

    // argument
    //
    typedef ::poosl::T_typed_variable ArgumentType;
    typedef ::xsd::cxx::tree::sequence< ArgumentType > ArgumentSequence;
    typedef ArgumentSequence::iterator ArgumentIterator;
    typedef ArgumentSequence::const_iterator ArgumentConstIterator;
    typedef ::xsd::cxx::tree::traits< ArgumentType, char > ArgumentTraits;

    const ArgumentSequence&
    getArgument () const;

    ArgumentSequence&
    getArgument ();

    void
    setArgument (const ArgumentSequence& s);

    // local_variable
    //
    typedef ::poosl::T_typed_variable Local_variableType;
    typedef ::xsd::cxx::tree::sequence< Local_variableType > Local_variableSequence;
    typedef Local_variableSequence::iterator Local_variableIterator;
    typedef Local_variableSequence::const_iterator Local_variableConstIterator;
    typedef ::xsd::cxx::tree::traits< Local_variableType, char > Local_variableTraits;

    const Local_variableSequence&
    getLocal_variable () const;

    Local_variableSequence&
    getLocal_variable ();

    void
    setLocal_variable (const Local_variableSequence& s);

    // body_text
    //
    typedef ::xml_schema::String Body_textType;
    typedef ::xsd::cxx::tree::optional< Body_textType > Body_textOptional;
    typedef ::xsd::cxx::tree::traits< Body_textType, char > Body_textTraits;

    const Body_textOptional&
    getBody_text () const;

    Body_textOptional&
    getBody_text ();

    void
    setBody_text (const Body_textType& x);

    void
    setBody_text (const Body_textOptional& x);

    void
    setBody_text (::std::unique_ptr< Body_textType > p);

    // body_expression
    //
    typedef ::poosl::T_expression Body_expressionType;
    typedef ::xsd::cxx::tree::optional< Body_expressionType > Body_expressionOptional;
    typedef ::xsd::cxx::tree::traits< Body_expressionType, char > Body_expressionTraits;

    const Body_expressionOptional&
    getBody_expression () const;

    Body_expressionOptional&
    getBody_expression ();

    void
    setBody_expression (const Body_expressionType& x);

    void
    setBody_expression (const Body_expressionOptional& x);

    void
    setBody_expression (::std::unique_ptr< Body_expressionType > p);

    // name
    //
    typedef ::poosl::T_data_method_name NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // native
    //
    typedef ::poosl::T_boolean NativeType;
    typedef ::xsd::cxx::tree::optional< NativeType > NativeOptional;
    typedef ::xsd::cxx::tree::traits< NativeType, char > NativeTraits;

    const NativeOptional&
    getNative () const;

    NativeOptional&
    getNative ();

    void
    setNative (const NativeType& x);

    void
    setNative (const NativeOptional& x);

    void
    setNative (::std::unique_ptr< NativeType > p);

    // Constructors.
    //
    T_data_method ();

    T_data_method (const Return_typeType&,
                   const NameType&);

    T_data_method (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    T_data_method (const T_data_method& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual T_data_method*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_data_method&
    operator= (const T_data_method& x);

    virtual 
    ~T_data_method ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Return_typeType > return_type_;
    ArgumentSequence argument_;
    Local_variableSequence local_variable_;
    Body_textOptional body_text_;
    Body_expressionOptional body_expression_;
    ::xsd::cxx::tree::one< NameType > name_;
    NativeOptional native_;
  };

  class T_process_class: public ::xml_schema::Type
  {
    public:
    // interface
    //
    typedef ::poosl::T_interface InterfaceType;
    typedef ::xsd::cxx::tree::traits< InterfaceType, char > InterfaceTraits;

    const InterfaceType&
    getInterface () const;

    InterfaceType&
    getInterface ();

    void
    setInterface (const InterfaceType& x);

    void
    setInterface (::std::unique_ptr< InterfaceType > p);

    // super_class
    //
    typedef ::poosl::T_poosl_type Super_classType;
    typedef ::xsd::cxx::tree::optional< Super_classType > Super_classOptional;
    typedef ::xsd::cxx::tree::traits< Super_classType, char > Super_classTraits;

    const Super_classOptional&
    getSuper_class () const;

    Super_classOptional&
    getSuper_class ();

    void
    setSuper_class (const Super_classType& x);

    void
    setSuper_class (const Super_classOptional& x);

    void
    setSuper_class (::std::unique_ptr< Super_classType > p);

    // instantiation_parameter
    //
    typedef ::poosl::T_typed_variable Instantiation_parameterType;
    typedef ::xsd::cxx::tree::sequence< Instantiation_parameterType > Instantiation_parameterSequence;
    typedef Instantiation_parameterSequence::iterator Instantiation_parameterIterator;
    typedef Instantiation_parameterSequence::const_iterator Instantiation_parameterConstIterator;
    typedef ::xsd::cxx::tree::traits< Instantiation_parameterType, char > Instantiation_parameterTraits;

    const Instantiation_parameterSequence&
    getInstantiation_parameter () const;

    Instantiation_parameterSequence&
    getInstantiation_parameter ();

    void
    setInstantiation_parameter (const Instantiation_parameterSequence& s);

    // instance_variable
    //
    typedef ::poosl::T_typed_variable Instance_variableType;
    typedef ::xsd::cxx::tree::sequence< Instance_variableType > Instance_variableSequence;
    typedef Instance_variableSequence::iterator Instance_variableIterator;
    typedef Instance_variableSequence::const_iterator Instance_variableConstIterator;
    typedef ::xsd::cxx::tree::traits< Instance_variableType, char > Instance_variableTraits;

    const Instance_variableSequence&
    getInstance_variable () const;

    Instance_variableSequence&
    getInstance_variable ();

    void
    setInstance_variable (const Instance_variableSequence& s);

    // initial_method_call
    //
    typedef ::poosl::T_initial_method_call Initial_method_callType;
    typedef ::xsd::cxx::tree::traits< Initial_method_callType, char > Initial_method_callTraits;

    const Initial_method_callType&
    getInitial_method_call () const;

    Initial_method_callType&
    getInitial_method_call ();

    void
    setInitial_method_call (const Initial_method_callType& x);

    void
    setInitial_method_call (::std::unique_ptr< Initial_method_callType > p);

    // process_method
    //
    typedef ::poosl::T_process_method Process_methodType;
    typedef ::xsd::cxx::tree::sequence< Process_methodType > Process_methodSequence;
    typedef Process_methodSequence::iterator Process_methodIterator;
    typedef Process_methodSequence::const_iterator Process_methodConstIterator;
    typedef ::xsd::cxx::tree::traits< Process_methodType, char > Process_methodTraits;

    const Process_methodSequence&
    getProcess_method () const;

    Process_methodSequence&
    getProcess_method ();

    void
    setProcess_method (const Process_methodSequence& s);

    // annotation
    //
    typedef ::poosl::T_process_class_annotation AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // name
    //
    typedef ::poosl::T_poosl_type NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // Constructors.
    //
    T_process_class ();

    T_process_class (const InterfaceType&,
                     const Initial_method_callType&,
                     const NameType&);

    T_process_class (::std::unique_ptr< InterfaceType >,
                     ::std::unique_ptr< Initial_method_callType >,
                     const NameType&);

    T_process_class (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_process_class (const T_process_class& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual T_process_class*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_process_class&
    operator= (const T_process_class& x);

    virtual 
    ~T_process_class ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InterfaceType > interface_;
    Super_classOptional super_class_;
    Instantiation_parameterSequence instantiation_parameter_;
    Instance_variableSequence instance_variable_;
    ::xsd::cxx::tree::one< Initial_method_callType > initial_method_call_;
    Process_methodSequence process_method_;
    AnnotationOptional annotation_;
    ::xsd::cxx::tree::one< NameType > name_;
  };

  class T_process_method: public ::xml_schema::Type
  {
    public:
    // argument
    //
    typedef ::poosl::T_typed_variable ArgumentType;
    typedef ::xsd::cxx::tree::sequence< ArgumentType > ArgumentSequence;
    typedef ArgumentSequence::iterator ArgumentIterator;
    typedef ArgumentSequence::const_iterator ArgumentConstIterator;
    typedef ::xsd::cxx::tree::traits< ArgumentType, char > ArgumentTraits;

    const ArgumentSequence&
    getArgument () const;

    ArgumentSequence&
    getArgument ();

    void
    setArgument (const ArgumentSequence& s);

    // output_parameter
    //
    typedef ::poosl::T_typed_variable Output_parameterType;
    typedef ::xsd::cxx::tree::sequence< Output_parameterType > Output_parameterSequence;
    typedef Output_parameterSequence::iterator Output_parameterIterator;
    typedef Output_parameterSequence::const_iterator Output_parameterConstIterator;
    typedef ::xsd::cxx::tree::traits< Output_parameterType, char > Output_parameterTraits;

    const Output_parameterSequence&
    getOutput_parameter () const;

    Output_parameterSequence&
    getOutput_parameter ();

    void
    setOutput_parameter (const Output_parameterSequence& s);

    // local_variable
    //
    typedef ::poosl::T_typed_variable Local_variableType;
    typedef ::xsd::cxx::tree::sequence< Local_variableType > Local_variableSequence;
    typedef Local_variableSequence::iterator Local_variableIterator;
    typedef Local_variableSequence::const_iterator Local_variableConstIterator;
    typedef ::xsd::cxx::tree::traits< Local_variableType, char > Local_variableTraits;

    const Local_variableSequence&
    getLocal_variable () const;

    Local_variableSequence&
    getLocal_variable ();

    void
    setLocal_variable (const Local_variableSequence& s);

    // body_text
    //
    typedef ::xml_schema::String Body_textType;
    typedef ::xsd::cxx::tree::optional< Body_textType > Body_textOptional;
    typedef ::xsd::cxx::tree::traits< Body_textType, char > Body_textTraits;

    const Body_textOptional&
    getBody_text () const;

    Body_textOptional&
    getBody_text ();

    void
    setBody_text (const Body_textType& x);

    void
    setBody_text (const Body_textOptional& x);

    void
    setBody_text (::std::unique_ptr< Body_textType > p);

    // body_statement
    //
    typedef ::poosl::T_statement Body_statementType;
    typedef ::xsd::cxx::tree::traits< Body_statementType, char > Body_statementTraits;

    const Body_statementType&
    getBody_statement () const;

    Body_statementType&
    getBody_statement ();

    void
    setBody_statement (const Body_statementType& x);

    void
    setBody_statement (::std::unique_ptr< Body_statementType > p);

    // name
    //
    typedef ::poosl::T_identifier NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // Constructors.
    //
    T_process_method ();

    T_process_method (const Body_statementType&,
                      const NameType&);

    T_process_method (::std::unique_ptr< Body_statementType >,
                      const NameType&);

    T_process_method (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    T_process_method (const T_process_method& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual T_process_method*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_process_method&
    operator= (const T_process_method& x);

    virtual 
    ~T_process_method ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ArgumentSequence argument_;
    Output_parameterSequence output_parameter_;
    Local_variableSequence local_variable_;
    Body_textOptional body_text_;
    ::xsd::cxx::tree::one< Body_statementType > body_statement_;
    ::xsd::cxx::tree::one< NameType > name_;
  };

  class T_cluster_class: public ::xml_schema::Type
  {
    public:
    // interface
    //
    typedef ::poosl::T_cluster_interface InterfaceType;
    typedef ::xsd::cxx::tree::traits< InterfaceType, char > InterfaceTraits;

    const InterfaceType&
    getInterface () const;

    InterfaceType&
    getInterface ();

    void
    setInterface (const InterfaceType& x);

    void
    setInterface (::std::unique_ptr< InterfaceType > p);

    // instantiation_parameter
    //
    typedef ::poosl::T_typed_variable Instantiation_parameterType;
    typedef ::xsd::cxx::tree::sequence< Instantiation_parameterType > Instantiation_parameterSequence;
    typedef Instantiation_parameterSequence::iterator Instantiation_parameterIterator;
    typedef Instantiation_parameterSequence::const_iterator Instantiation_parameterConstIterator;
    typedef ::xsd::cxx::tree::traits< Instantiation_parameterType, char > Instantiation_parameterTraits;

    const Instantiation_parameterSequence&
    getInstantiation_parameter () const;

    Instantiation_parameterSequence&
    getInstantiation_parameter ();

    void
    setInstantiation_parameter (const Instantiation_parameterSequence& s);

    // channel
    //
    typedef ::poosl::T_channel ChannelType;
    typedef ::xsd::cxx::tree::sequence< ChannelType > ChannelSequence;
    typedef ChannelSequence::iterator ChannelIterator;
    typedef ChannelSequence::const_iterator ChannelConstIterator;
    typedef ::xsd::cxx::tree::traits< ChannelType, char > ChannelTraits;

    const ChannelSequence&
    getChannel () const;

    ChannelSequence&
    getChannel ();

    void
    setChannel (const ChannelSequence& s);

    // instance
    //
    typedef ::poosl::T_instance InstanceType;
    typedef ::xsd::cxx::tree::sequence< InstanceType > InstanceSequence;
    typedef InstanceSequence::iterator InstanceIterator;
    typedef InstanceSequence::const_iterator InstanceConstIterator;
    typedef ::xsd::cxx::tree::traits< InstanceType, char > InstanceTraits;

    const InstanceSequence&
    getInstance () const;

    InstanceSequence&
    getInstance ();

    void
    setInstance (const InstanceSequence& s);

    // annotation
    //
    typedef ::poosl::T_cluster_class_annotation AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // name
    //
    typedef ::poosl::T_poosl_type NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // Constructors.
    //
    T_cluster_class ();

    T_cluster_class (const InterfaceType&,
                     const NameType&);

    T_cluster_class (::std::unique_ptr< InterfaceType >,
                     const NameType&);

    T_cluster_class (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_cluster_class (const T_cluster_class& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual T_cluster_class*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_cluster_class&
    operator= (const T_cluster_class& x);

    virtual 
    ~T_cluster_class ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InterfaceType > interface_;
    Instantiation_parameterSequence instantiation_parameter_;
    ChannelSequence channel_;
    InstanceSequence instance_;
    AnnotationOptional annotation_;
    ::xsd::cxx::tree::one< NameType > name_;
  };

  class T_top_level_specification: public ::xml_schema::Type
  {
    public:
    // instance
    //
    typedef ::poosl::T_instance InstanceType;
    typedef ::xsd::cxx::tree::sequence< InstanceType > InstanceSequence;
    typedef InstanceSequence::iterator InstanceIterator;
    typedef InstanceSequence::const_iterator InstanceConstIterator;
    typedef ::xsd::cxx::tree::traits< InstanceType, char > InstanceTraits;

    const InstanceSequence&
    getInstance () const;

    InstanceSequence&
    getInstance ();

    void
    setInstance (const InstanceSequence& s);

    // channel
    //
    typedef ::poosl::T_channel_internal ChannelType;
    typedef ::xsd::cxx::tree::sequence< ChannelType > ChannelSequence;
    typedef ChannelSequence::iterator ChannelIterator;
    typedef ChannelSequence::const_iterator ChannelConstIterator;
    typedef ::xsd::cxx::tree::traits< ChannelType, char > ChannelTraits;

    const ChannelSequence&
    getChannel () const;

    ChannelSequence&
    getChannel ();

    void
    setChannel (const ChannelSequence& s);

    // annotation
    //
    typedef ::poosl::T_top_level_annotation AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // Constructors.
    //
    T_top_level_specification ();

    T_top_level_specification (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    T_top_level_specification (const T_top_level_specification& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual T_top_level_specification*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_top_level_specification&
    operator= (const T_top_level_specification& x);

    virtual 
    ~T_top_level_specification ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    InstanceSequence instance_;
    ChannelSequence channel_;
    AnnotationOptional annotation_;
  };

  class T_channel_internal: public ::xml_schema::Type
  {
    public:
    // annotation
    //
    typedef ::poosl::T_channel_annotation AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // name
    //
    typedef ::poosl::T_identifier NameType;
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameOptional&
    getName () const;

    NameOptional&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (const NameOptional& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // Constructors.
    //
    T_channel_internal ();

    T_channel_internal (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    T_channel_internal (const T_channel_internal& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual T_channel_internal*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_channel_internal&
    operator= (const T_channel_internal& x);

    virtual 
    ~T_channel_internal ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AnnotationOptional annotation_;
    NameOptional name_;
  };

  class T_channel: public ::poosl::T_channel_internal
  {
    public:
    // output_port
    //
    typedef ::poosl::T_identifier Output_portType;
    typedef ::xsd::cxx::tree::optional< Output_portType > Output_portOptional;
    typedef ::xsd::cxx::tree::traits< Output_portType, char > Output_portTraits;

    const Output_portOptional&
    getOutput_port () const;

    Output_portOptional&
    getOutput_port ();

    void
    setOutput_port (const Output_portType& x);

    void
    setOutput_port (const Output_portOptional& x);

    void
    setOutput_port (::std::unique_ptr< Output_portType > p);

    // Constructors.
    //
    T_channel ();

    T_channel (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    T_channel (const T_channel& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual T_channel*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_channel&
    operator= (const T_channel& x);

    virtual 
    ~T_channel ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Output_portOptional output_port_;
  };

  class T_instance: public ::xml_schema::Type
  {
    public:
    // instantiation_expression
    //
    typedef ::poosl::T_instantiation_expression Instantiation_expressionType;
    typedef ::xsd::cxx::tree::sequence< Instantiation_expressionType > Instantiation_expressionSequence;
    typedef Instantiation_expressionSequence::iterator Instantiation_expressionIterator;
    typedef Instantiation_expressionSequence::const_iterator Instantiation_expressionConstIterator;
    typedef ::xsd::cxx::tree::traits< Instantiation_expressionType, char > Instantiation_expressionTraits;

    const Instantiation_expressionSequence&
    getInstantiation_expression () const;

    Instantiation_expressionSequence&
    getInstantiation_expression ();

    void
    setInstantiation_expression (const Instantiation_expressionSequence& s);

    // connection
    //
    typedef ::poosl::T_connection ConnectionType;
    typedef ::xsd::cxx::tree::sequence< ConnectionType > ConnectionSequence;
    typedef ConnectionSequence::iterator ConnectionIterator;
    typedef ConnectionSequence::const_iterator ConnectionConstIterator;
    typedef ::xsd::cxx::tree::traits< ConnectionType, char > ConnectionTraits;

    const ConnectionSequence&
    getConnection () const;

    ConnectionSequence&
    getConnection ();

    void
    setConnection (const ConnectionSequence& s);

    // annotation
    //
    typedef ::poosl::T_instance_annotation AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // type
    //
    typedef ::poosl::T_instance_type TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    getType () const;

    TypeOptional&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (const TypeOptional& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // class
    //
    typedef ::poosl::T_identifier ClassType;
    typedef ::xsd::cxx::tree::optional< ClassType > ClassOptional;
    typedef ::xsd::cxx::tree::traits< ClassType, char > ClassTraits;

    const ClassOptional&
    getClass () const;

    ClassOptional&
    getClass ();

    void
    setClass (const ClassType& x);

    void
    setClass (const ClassOptional& x);

    void
    setClass (::std::unique_ptr< ClassType > p);

    // name
    //
    typedef ::poosl::T_identifier NameType;
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameOptional&
    getName () const;

    NameOptional&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (const NameOptional& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // Constructors.
    //
    T_instance ();

    T_instance (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    T_instance (const T_instance& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual T_instance*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_instance&
    operator= (const T_instance& x);

    virtual 
    ~T_instance ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Instantiation_expressionSequence instantiation_expression_;
    ConnectionSequence connection_;
    AnnotationOptional annotation_;
    TypeOptional type_;
    ClassOptional class__;
    NameOptional name_;
  };

  class T_connection: public ::xml_schema::Type
  {
    public:
    // annotation
    //
    typedef ::poosl::T_connection_annotation AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // port
    //
    typedef ::poosl::T_identifier PortType;
    typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

    const PortType&
    getPort () const;

    PortType&
    getPort ();

    void
    setPort (const PortType& x);

    void
    setPort (::std::unique_ptr< PortType > p);

    // channel
    //
    typedef ::poosl::T_identifier ChannelType;
    typedef ::xsd::cxx::tree::traits< ChannelType, char > ChannelTraits;

    const ChannelType&
    getChannel () const;

    ChannelType&
    getChannel ();

    void
    setChannel (const ChannelType& x);

    void
    setChannel (::std::unique_ptr< ChannelType > p);

    // Constructors.
    //
    T_connection ();

    T_connection (const PortType&,
                  const ChannelType&);

    T_connection (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    T_connection (const T_connection& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual T_connection*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_connection&
    operator= (const T_connection& x);

    virtual 
    ~T_connection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AnnotationOptional annotation_;
    ::xsd::cxx::tree::one< PortType > port_;
    ::xsd::cxx::tree::one< ChannelType > channel_;
  };

  class T_initial_method_call: public ::xml_schema::Type
  {
    public:
    // method_call_text
    //
    typedef ::xml_schema::String Method_call_textType;
    typedef ::xsd::cxx::tree::optional< Method_call_textType > Method_call_textOptional;
    typedef ::xsd::cxx::tree::traits< Method_call_textType, char > Method_call_textTraits;

    const Method_call_textOptional&
    getMethod_call_text () const;

    Method_call_textOptional&
    getMethod_call_text ();

    void
    setMethod_call_text (const Method_call_textType& x);

    void
    setMethod_call_text (const Method_call_textOptional& x);

    void
    setMethod_call_text (::std::unique_ptr< Method_call_textType > p);

    // process_method_call
    //
    typedef ::poosl::T_initial_process_method_call Process_method_callType;
    typedef ::xsd::cxx::tree::traits< Process_method_callType, char > Process_method_callTraits;

    const Process_method_callType&
    getProcess_method_call () const;

    Process_method_callType&
    getProcess_method_call ();

    void
    setProcess_method_call (const Process_method_callType& x);

    void
    setProcess_method_call (::std::unique_ptr< Process_method_callType > p);

    // Constructors.
    //
    T_initial_method_call ();

    T_initial_method_call (const Process_method_callType&);

    T_initial_method_call (::std::unique_ptr< Process_method_callType >);

    T_initial_method_call (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_initial_method_call (const T_initial_method_call& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual T_initial_method_call*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_initial_method_call&
    operator= (const T_initial_method_call& x);

    virtual 
    ~T_initial_method_call ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Method_call_textOptional method_call_text_;
    ::xsd::cxx::tree::one< Process_method_callType > process_method_call_;
  };

  class T_instantiation_expression: public ::xml_schema::Type
  {
    public:
    // body_text
    //
    typedef ::xml_schema::String Body_textType;
    typedef ::xsd::cxx::tree::optional< Body_textType > Body_textOptional;
    typedef ::xsd::cxx::tree::traits< Body_textType, char > Body_textTraits;

    const Body_textOptional&
    getBody_text () const;

    Body_textOptional&
    getBody_text ();

    void
    setBody_text (const Body_textType& x);

    void
    setBody_text (const Body_textOptional& x);

    void
    setBody_text (::std::unique_ptr< Body_textType > p);

    // body_expression
    //
    typedef ::poosl::T_expression Body_expressionType;
    typedef ::xsd::cxx::tree::traits< Body_expressionType, char > Body_expressionTraits;

    const Body_expressionType&
    getBody_expression () const;

    Body_expressionType&
    getBody_expression ();

    void
    setBody_expression (const Body_expressionType& x);

    void
    setBody_expression (::std::unique_ptr< Body_expressionType > p);

    // parameter_name
    //
    typedef ::poosl::T_variable_name Parameter_nameType;
    typedef ::xsd::cxx::tree::traits< Parameter_nameType, char > Parameter_nameTraits;

    const Parameter_nameType&
    getParameter_name () const;

    Parameter_nameType&
    getParameter_name ();

    void
    setParameter_name (const Parameter_nameType& x);

    void
    setParameter_name (::std::unique_ptr< Parameter_nameType > p);

    // Constructors.
    //
    T_instantiation_expression ();

    T_instantiation_expression (const Body_expressionType&,
                                const Parameter_nameType&);

    T_instantiation_expression (::std::unique_ptr< Body_expressionType >,
                                const Parameter_nameType&);

    T_instantiation_expression (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    T_instantiation_expression (const T_instantiation_expression& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual T_instantiation_expression*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_instantiation_expression&
    operator= (const T_instantiation_expression& x);

    virtual 
    ~T_instantiation_expression ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    Body_textOptional body_text_;
    ::xsd::cxx::tree::one< Body_expressionType > body_expression_;
    ::xsd::cxx::tree::one< Parameter_nameType > parameter_name_;
  };

  class T_interface: public ::xml_schema::Type
  {
    public:
    // port
    //
    typedef ::poosl::T_port PortType;
    typedef ::xsd::cxx::tree::sequence< PortType > PortSequence;
    typedef PortSequence::iterator PortIterator;
    typedef PortSequence::const_iterator PortConstIterator;
    typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

    const PortSequence&
    getPort () const;

    PortSequence&
    getPort ();

    void
    setPort (const PortSequence& s);

    // Constructors.
    //
    T_interface ();

    T_interface (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    T_interface (const T_interface& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual T_interface*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_interface&
    operator= (const T_interface& x);

    virtual 
    ~T_interface ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PortSequence port_;
  };

  class T_port: public ::xml_schema::Type
  {
    public:
    // message
    //
    typedef ::poosl::T_message MessageType;
    typedef ::xsd::cxx::tree::sequence< MessageType > MessageSequence;
    typedef MessageSequence::iterator MessageIterator;
    typedef MessageSequence::const_iterator MessageConstIterator;
    typedef ::xsd::cxx::tree::traits< MessageType, char > MessageTraits;

    const MessageSequence&
    getMessage () const;

    MessageSequence&
    getMessage ();

    void
    setMessage (const MessageSequence& s);

    // annotation
    //
    typedef ::poosl::T_port_annotation AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // name
    //
    typedef ::poosl::T_identifier NameType;
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameOptional&
    getName () const;

    NameOptional&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (const NameOptional& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // Constructors.
    //
    T_port ();

    T_port (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    T_port (const T_port& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    virtual T_port*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_port&
    operator= (const T_port& x);

    virtual 
    ~T_port ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MessageSequence message_;
    AnnotationOptional annotation_;
    NameOptional name_;
  };

  class T_message: public ::xml_schema::Type
  {
    public:
    // argument
    //
    typedef ::poosl::T_poosl_type_attribute ArgumentType;
    typedef ::xsd::cxx::tree::sequence< ArgumentType > ArgumentSequence;
    typedef ArgumentSequence::iterator ArgumentIterator;
    typedef ArgumentSequence::const_iterator ArgumentConstIterator;
    typedef ::xsd::cxx::tree::traits< ArgumentType, char > ArgumentTraits;

    const ArgumentSequence&
    getArgument () const;

    ArgumentSequence&
    getArgument ();

    void
    setArgument (const ArgumentSequence& s);

    // type
    //
    typedef ::poosl::T_message_type TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    getType () const;

    TypeOptional&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (const TypeOptional& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // name
    //
    typedef ::poosl::T_identifier NameType;
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameOptional&
    getName () const;

    NameOptional&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (const NameOptional& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // Constructors.
    //
    T_message ();

    T_message (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    T_message (const T_message& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual T_message*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_message&
    operator= (const T_message& x);

    virtual 
    ~T_message ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ArgumentSequence argument_;
    TypeOptional type_;
    NameOptional name_;
  };

  class T_cluster_interface: public ::xml_schema::Type
  {
    public:
    // port
    //
    typedef ::poosl::T_port PortType;
    typedef ::xsd::cxx::tree::sequence< PortType > PortSequence;
    typedef PortSequence::iterator PortIterator;
    typedef PortSequence::const_iterator PortConstIterator;
    typedef ::xsd::cxx::tree::traits< PortType, char > PortTraits;

    const PortSequence&
    getPort () const;

    PortSequence&
    getPort ();

    void
    setPort (const PortSequence& s);

    // Constructors.
    //
    T_cluster_interface ();

    T_cluster_interface (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    T_cluster_interface (const T_cluster_interface& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual T_cluster_interface*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_cluster_interface&
    operator= (const T_cluster_interface& x);

    virtual 
    ~T_cluster_interface ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PortSequence port_;
  };

  class T_instance_type: public ::xml_schema::String
  {
    public:
    enum Value
    {
      process,
      cluster
    };

    T_instance_type ();

    T_instance_type (Value v);

    T_instance_type (const char* v);

    T_instance_type (const ::std::string& v);

    T_instance_type (const ::xml_schema::String& v);

    T_instance_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_instance_type (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_instance_type (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    T_instance_type (const T_instance_type& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual T_instance_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_instance_type&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_T_instance_type_convert ();
    }

    protected:
    Value
    _xsd_T_instance_type_convert () const;

    public:
    static const char* const _xsd_T_instance_type_literals_[2];
    static const Value _xsd_T_instance_type_indexes_[2];
  };

  class T_annotation: public ::xml_schema::Type
  {
    public:
    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    T_annotation ();

    T_annotation (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    T_annotation (const T_annotation& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual T_annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    T_annotation&
    operator= (const T_annotation& x);

    virtual 
    ~T_annotation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    AnySequence any_;
  };

  class T_top_level_annotation: public ::poosl::T_annotation
  {
    public:
    // Constructors.
    //
    T_top_level_annotation ();

    T_top_level_annotation (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    T_top_level_annotation (const T_top_level_annotation& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual T_top_level_annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_top_level_annotation ();
  };

  class T_data_class_annotation: public ::poosl::T_annotation
  {
    public:
    // Constructors.
    //
    T_data_class_annotation ();

    T_data_class_annotation (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    T_data_class_annotation (const T_data_class_annotation& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual T_data_class_annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_data_class_annotation ();
  };

  class T_process_class_annotation: public ::poosl::T_annotation
  {
    public:
    // Constructors.
    //
    T_process_class_annotation ();

    T_process_class_annotation (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    T_process_class_annotation (const T_process_class_annotation& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual T_process_class_annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_process_class_annotation ();
  };

  class T_cluster_class_annotation: public ::poosl::T_annotation
  {
    public:
    // Constructors.
    //
    T_cluster_class_annotation ();

    T_cluster_class_annotation (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    T_cluster_class_annotation (const T_cluster_class_annotation& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual T_cluster_class_annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_cluster_class_annotation ();
  };

  class T_channel_annotation: public ::poosl::T_annotation
  {
    public:
    // Constructors.
    //
    T_channel_annotation ();

    T_channel_annotation (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    T_channel_annotation (const T_channel_annotation& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual T_channel_annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_channel_annotation ();
  };

  class T_instance_annotation: public ::poosl::T_annotation
  {
    public:
    // Constructors.
    //
    T_instance_annotation ();

    T_instance_annotation (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    T_instance_annotation (const T_instance_annotation& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual T_instance_annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_instance_annotation ();
  };

  class T_port_annotation: public ::poosl::T_annotation
  {
    public:
    // Constructors.
    //
    T_port_annotation ();

    T_port_annotation (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    T_port_annotation (const T_port_annotation& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual T_port_annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_port_annotation ();
  };

  class T_connection_annotation: public ::poosl::T_annotation
  {
    public:
    // Constructors.
    //
    T_connection_annotation ();

    T_connection_annotation (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    T_connection_annotation (const T_connection_annotation& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual T_connection_annotation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~T_connection_annotation ();
  };
}

#include <iosfwd>

namespace poosl
{
  ::std::ostream&
  operator<< (::std::ostream&, const T_poosl_specification&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_cluster_classes&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_process_classes&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_data_classes&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_data_class&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_data_method&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_process_class&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_process_method&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_cluster_class&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_top_level_specification&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_channel_internal&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_channel&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_instance&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_connection&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_initial_method_call&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_instantiation_expression&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_interface&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_port&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_message&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_cluster_interface&);

  ::std::ostream&
  operator<< (::std::ostream&, T_instance_type::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const T_instance_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_annotation&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_top_level_annotation&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_data_class_annotation&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_process_class_annotation&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_cluster_class_annotation&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_channel_annotation&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_instance_annotation&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_port_annotation&);

  ::std::ostream&
  operator<< (::std::ostream&, const T_connection_annotation&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace poosl
{
  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (const ::std::string& uri,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (const ::std::string& uri,
                            ::xml_schema::ErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (const ::std::string& uri,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            ::xml_schema::ErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            const ::std::string& id,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            const ::std::string& id,
                            ::xml_schema::ErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            const ::std::string& id,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::xercesc::InputSource& is,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::xercesc::InputSource& is,
                            ::xml_schema::ErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::xercesc::InputSource& is,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (const ::xercesc::DOMDocument& d,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace poosl
{
  // Serialize to std::ostream.
  //

  void
  serializePoosl_specification (::std::ostream& os,
                                const ::poosl::T_poosl_specification& x, 
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  void
  serializePoosl_specification (::std::ostream& os,
                                const ::poosl::T_poosl_specification& x, 
                                ::xml_schema::ErrorHandler& eh,
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  void
  serializePoosl_specification (::std::ostream& os,
                                const ::poosl::T_poosl_specification& x, 
                                ::xercesc::DOMErrorHandler& eh,
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  serializePoosl_specification (::xercesc::XMLFormatTarget& ft,
                                const ::poosl::T_poosl_specification& x, 
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  void
  serializePoosl_specification (::xercesc::XMLFormatTarget& ft,
                                const ::poosl::T_poosl_specification& x, 
                                ::xml_schema::ErrorHandler& eh,
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  void
  serializePoosl_specification (::xercesc::XMLFormatTarget& ft,
                                const ::poosl::T_poosl_specification& x, 
                                ::xercesc::DOMErrorHandler& eh,
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  serializePoosl_specification (::xercesc::DOMDocument& d,
                                const ::poosl::T_poosl_specification& x,
                                ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializePoosl_specification (const ::poosl::T_poosl_specification& x, 
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                ::xml_schema::Flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const T_poosl_specification&);

  void
  operator<< (::xercesc::DOMElement&, const T_cluster_classes&);

  void
  operator<< (::xercesc::DOMElement&, const T_process_classes&);

  void
  operator<< (::xercesc::DOMElement&, const T_data_classes&);

  void
  operator<< (::xercesc::DOMElement&, const T_data_class&);

  void
  operator<< (::xercesc::DOMElement&, const T_data_method&);

  void
  operator<< (::xercesc::DOMElement&, const T_process_class&);

  void
  operator<< (::xercesc::DOMElement&, const T_process_method&);

  void
  operator<< (::xercesc::DOMElement&, const T_cluster_class&);

  void
  operator<< (::xercesc::DOMElement&, const T_top_level_specification&);

  void
  operator<< (::xercesc::DOMElement&, const T_channel_internal&);

  void
  operator<< (::xercesc::DOMElement&, const T_channel&);

  void
  operator<< (::xercesc::DOMElement&, const T_instance&);

  void
  operator<< (::xercesc::DOMElement&, const T_connection&);

  void
  operator<< (::xercesc::DOMElement&, const T_initial_method_call&);

  void
  operator<< (::xercesc::DOMElement&, const T_instantiation_expression&);

  void
  operator<< (::xercesc::DOMElement&, const T_interface&);

  void
  operator<< (::xercesc::DOMElement&, const T_port&);

  void
  operator<< (::xercesc::DOMElement&, const T_message&);

  void
  operator<< (::xercesc::DOMElement&, const T_cluster_interface&);

  void
  operator<< (::xercesc::DOMElement&, const T_instance_type&);

  void
  operator<< (::xercesc::DOMAttr&, const T_instance_type&);

  void
  operator<< (::xml_schema::ListStream&,
              const T_instance_type&);

  void
  operator<< (::xercesc::DOMElement&, const T_annotation&);

  void
  operator<< (::xercesc::DOMElement&, const T_top_level_annotation&);

  void
  operator<< (::xercesc::DOMElement&, const T_data_class_annotation&);

  void
  operator<< (::xercesc::DOMElement&, const T_process_class_annotation&);

  void
  operator<< (::xercesc::DOMElement&, const T_cluster_class_annotation&);

  void
  operator<< (::xercesc::DOMElement&, const T_channel_annotation&);

  void
  operator<< (::xercesc::DOMElement&, const T_instance_annotation&);

  void
  operator<< (::xercesc::DOMElement&, const T_port_annotation&);

  void
  operator<< (::xercesc::DOMElement&, const T_connection_annotation&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // POOSLMODEL_HXX
