// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "pooslmodel.hxx"

namespace poosl
{
  // T_poosl_specification
  // 

  const T_poosl_specification::NameOptional& T_poosl_specification::
  getName () const
  {
    return this->name_;
  }

  T_poosl_specification::NameOptional& T_poosl_specification::
  getName ()
  {
    return this->name_;
  }

  void T_poosl_specification::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_poosl_specification::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void T_poosl_specification::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_poosl_specification::Data_classesType& T_poosl_specification::
  getData_classes () const
  {
    return this->data_classes_.get ();
  }

  T_poosl_specification::Data_classesType& T_poosl_specification::
  getData_classes ()
  {
    return this->data_classes_.get ();
  }

  void T_poosl_specification::
  setData_classes (const Data_classesType& x)
  {
    this->data_classes_.set (x);
  }

  void T_poosl_specification::
  setData_classes (::std::unique_ptr< Data_classesType > x)
  {
    this->data_classes_.set (std::move (x));
  }

  const T_poosl_specification::Process_classesOptional& T_poosl_specification::
  getProcess_classes () const
  {
    return this->process_classes_;
  }

  T_poosl_specification::Process_classesOptional& T_poosl_specification::
  getProcess_classes ()
  {
    return this->process_classes_;
  }

  void T_poosl_specification::
  setProcess_classes (const Process_classesType& x)
  {
    this->process_classes_.set (x);
  }

  void T_poosl_specification::
  setProcess_classes (const Process_classesOptional& x)
  {
    this->process_classes_ = x;
  }

  void T_poosl_specification::
  setProcess_classes (::std::unique_ptr< Process_classesType > x)
  {
    this->process_classes_.set (std::move (x));
  }

  const T_poosl_specification::Cluster_classesOptional& T_poosl_specification::
  getCluster_classes () const
  {
    return this->cluster_classes_;
  }

  T_poosl_specification::Cluster_classesOptional& T_poosl_specification::
  getCluster_classes ()
  {
    return this->cluster_classes_;
  }

  void T_poosl_specification::
  setCluster_classes (const Cluster_classesType& x)
  {
    this->cluster_classes_.set (x);
  }

  void T_poosl_specification::
  setCluster_classes (const Cluster_classesOptional& x)
  {
    this->cluster_classes_ = x;
  }

  void T_poosl_specification::
  setCluster_classes (::std::unique_ptr< Cluster_classesType > x)
  {
    this->cluster_classes_.set (std::move (x));
  }

  const T_poosl_specification::Top_level_specificationOptional& T_poosl_specification::
  getTop_level_specification () const
  {
    return this->top_level_specification_;
  }

  T_poosl_specification::Top_level_specificationOptional& T_poosl_specification::
  getTop_level_specification ()
  {
    return this->top_level_specification_;
  }

  void T_poosl_specification::
  setTop_level_specification (const Top_level_specificationType& x)
  {
    this->top_level_specification_.set (x);
  }

  void T_poosl_specification::
  setTop_level_specification (const Top_level_specificationOptional& x)
  {
    this->top_level_specification_ = x;
  }

  void T_poosl_specification::
  setTop_level_specification (::std::unique_ptr< Top_level_specificationType > x)
  {
    this->top_level_specification_.set (std::move (x));
  }

  const T_poosl_specification::DescriptionOptional& T_poosl_specification::
  getDescription () const
  {
    return this->description_;
  }

  T_poosl_specification::DescriptionOptional& T_poosl_specification::
  getDescription ()
  {
    return this->description_;
  }

  void T_poosl_specification::
  setDescription (const DescriptionType& x)
  {
    this->description_.set (x);
  }

  void T_poosl_specification::
  setDescription (const DescriptionOptional& x)
  {
    this->description_ = x;
  }

  void T_poosl_specification::
  setDescription (::std::unique_ptr< DescriptionType > x)
  {
    this->description_.set (std::move (x));
  }


  // T_cluster_classes
  // 

  const T_cluster_classes::Cluster_classSequence& T_cluster_classes::
  getCluster_class () const
  {
    return this->cluster_class_;
  }

  T_cluster_classes::Cluster_classSequence& T_cluster_classes::
  getCluster_class ()
  {
    return this->cluster_class_;
  }

  void T_cluster_classes::
  setCluster_class (const Cluster_classSequence& s)
  {
    this->cluster_class_ = s;
  }


  // T_process_classes
  // 

  const T_process_classes::Process_classSequence& T_process_classes::
  getProcess_class () const
  {
    return this->process_class_;
  }

  T_process_classes::Process_classSequence& T_process_classes::
  getProcess_class ()
  {
    return this->process_class_;
  }

  void T_process_classes::
  setProcess_class (const Process_classSequence& s)
  {
    this->process_class_ = s;
  }


  // T_data_classes
  // 

  const T_data_classes::Data_classSequence& T_data_classes::
  getData_class () const
  {
    return this->data_class_;
  }

  T_data_classes::Data_classSequence& T_data_classes::
  getData_class ()
  {
    return this->data_class_;
  }

  void T_data_classes::
  setData_class (const Data_classSequence& s)
  {
    this->data_class_ = s;
  }


  // T_data_class
  // 

  const T_data_class::Super_classOptional& T_data_class::
  getSuper_class () const
  {
    return this->super_class_;
  }

  T_data_class::Super_classOptional& T_data_class::
  getSuper_class ()
  {
    return this->super_class_;
  }

  void T_data_class::
  setSuper_class (const Super_classType& x)
  {
    this->super_class_.set (x);
  }

  void T_data_class::
  setSuper_class (const Super_classOptional& x)
  {
    this->super_class_ = x;
  }

  void T_data_class::
  setSuper_class (::std::unique_ptr< Super_classType > x)
  {
    this->super_class_.set (std::move (x));
  }

  const T_data_class::Instance_variableSequence& T_data_class::
  getInstance_variable () const
  {
    return this->instance_variable_;
  }

  T_data_class::Instance_variableSequence& T_data_class::
  getInstance_variable ()
  {
    return this->instance_variable_;
  }

  void T_data_class::
  setInstance_variable (const Instance_variableSequence& s)
  {
    this->instance_variable_ = s;
  }

  const T_data_class::Data_methodSequence& T_data_class::
  getData_method () const
  {
    return this->data_method_;
  }

  T_data_class::Data_methodSequence& T_data_class::
  getData_method ()
  {
    return this->data_method_;
  }

  void T_data_class::
  setData_method (const Data_methodSequence& s)
  {
    this->data_method_ = s;
  }

  const T_data_class::AnnotationOptional& T_data_class::
  getAnnotation () const
  {
    return this->annotation_;
  }

  T_data_class::AnnotationOptional& T_data_class::
  getAnnotation ()
  {
    return this->annotation_;
  }

  void T_data_class::
  setAnnotation (const AnnotationType& x)
  {
    this->annotation_.set (x);
  }

  void T_data_class::
  setAnnotation (const AnnotationOptional& x)
  {
    this->annotation_ = x;
  }

  void T_data_class::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->annotation_.set (std::move (x));
  }

  const T_data_class::NameType& T_data_class::
  getName () const
  {
    return this->name_.get ();
  }

  T_data_class::NameType& T_data_class::
  getName ()
  {
    return this->name_.get ();
  }

  void T_data_class::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_data_class::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_data_class::NativeOptional& T_data_class::
  getNative () const
  {
    return this->native_;
  }

  T_data_class::NativeOptional& T_data_class::
  getNative ()
  {
    return this->native_;
  }

  void T_data_class::
  setNative (const NativeType& x)
  {
    this->native_.set (x);
  }

  void T_data_class::
  setNative (const NativeOptional& x)
  {
    this->native_ = x;
  }

  void T_data_class::
  setNative (::std::unique_ptr< NativeType > x)
  {
    this->native_.set (std::move (x));
  }


  // T_data_method
  // 

  const T_data_method::Return_typeType& T_data_method::
  getReturn_type () const
  {
    return this->return_type_.get ();
  }

  T_data_method::Return_typeType& T_data_method::
  getReturn_type ()
  {
    return this->return_type_.get ();
  }

  void T_data_method::
  setReturn_type (const Return_typeType& x)
  {
    this->return_type_.set (x);
  }

  void T_data_method::
  setReturn_type (::std::unique_ptr< Return_typeType > x)
  {
    this->return_type_.set (std::move (x));
  }

  const T_data_method::ArgumentSequence& T_data_method::
  getArgument () const
  {
    return this->argument_;
  }

  T_data_method::ArgumentSequence& T_data_method::
  getArgument ()
  {
    return this->argument_;
  }

  void T_data_method::
  setArgument (const ArgumentSequence& s)
  {
    this->argument_ = s;
  }

  const T_data_method::Local_variableSequence& T_data_method::
  getLocal_variable () const
  {
    return this->local_variable_;
  }

  T_data_method::Local_variableSequence& T_data_method::
  getLocal_variable ()
  {
    return this->local_variable_;
  }

  void T_data_method::
  setLocal_variable (const Local_variableSequence& s)
  {
    this->local_variable_ = s;
  }

  const T_data_method::Body_textOptional& T_data_method::
  getBody_text () const
  {
    return this->body_text_;
  }

  T_data_method::Body_textOptional& T_data_method::
  getBody_text ()
  {
    return this->body_text_;
  }

  void T_data_method::
  setBody_text (const Body_textType& x)
  {
    this->body_text_.set (x);
  }

  void T_data_method::
  setBody_text (const Body_textOptional& x)
  {
    this->body_text_ = x;
  }

  void T_data_method::
  setBody_text (::std::unique_ptr< Body_textType > x)
  {
    this->body_text_.set (std::move (x));
  }

  const T_data_method::Body_expressionOptional& T_data_method::
  getBody_expression () const
  {
    return this->body_expression_;
  }

  T_data_method::Body_expressionOptional& T_data_method::
  getBody_expression ()
  {
    return this->body_expression_;
  }

  void T_data_method::
  setBody_expression (const Body_expressionType& x)
  {
    this->body_expression_.set (x);
  }

  void T_data_method::
  setBody_expression (const Body_expressionOptional& x)
  {
    this->body_expression_ = x;
  }

  void T_data_method::
  setBody_expression (::std::unique_ptr< Body_expressionType > x)
  {
    this->body_expression_.set (std::move (x));
  }

  const T_data_method::NameType& T_data_method::
  getName () const
  {
    return this->name_.get ();
  }

  T_data_method::NameType& T_data_method::
  getName ()
  {
    return this->name_.get ();
  }

  void T_data_method::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_data_method::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_data_method::NativeOptional& T_data_method::
  getNative () const
  {
    return this->native_;
  }

  T_data_method::NativeOptional& T_data_method::
  getNative ()
  {
    return this->native_;
  }

  void T_data_method::
  setNative (const NativeType& x)
  {
    this->native_.set (x);
  }

  void T_data_method::
  setNative (const NativeOptional& x)
  {
    this->native_ = x;
  }

  void T_data_method::
  setNative (::std::unique_ptr< NativeType > x)
  {
    this->native_.set (std::move (x));
  }


  // T_process_class
  // 

  const T_process_class::InterfaceType& T_process_class::
  getInterface () const
  {
    return this->interface_.get ();
  }

  T_process_class::InterfaceType& T_process_class::
  getInterface ()
  {
    return this->interface_.get ();
  }

  void T_process_class::
  setInterface (const InterfaceType& x)
  {
    this->interface_.set (x);
  }

  void T_process_class::
  setInterface (::std::unique_ptr< InterfaceType > x)
  {
    this->interface_.set (std::move (x));
  }

  const T_process_class::Super_classOptional& T_process_class::
  getSuper_class () const
  {
    return this->super_class_;
  }

  T_process_class::Super_classOptional& T_process_class::
  getSuper_class ()
  {
    return this->super_class_;
  }

  void T_process_class::
  setSuper_class (const Super_classType& x)
  {
    this->super_class_.set (x);
  }

  void T_process_class::
  setSuper_class (const Super_classOptional& x)
  {
    this->super_class_ = x;
  }

  void T_process_class::
  setSuper_class (::std::unique_ptr< Super_classType > x)
  {
    this->super_class_.set (std::move (x));
  }

  const T_process_class::Instantiation_parameterSequence& T_process_class::
  getInstantiation_parameter () const
  {
    return this->instantiation_parameter_;
  }

  T_process_class::Instantiation_parameterSequence& T_process_class::
  getInstantiation_parameter ()
  {
    return this->instantiation_parameter_;
  }

  void T_process_class::
  setInstantiation_parameter (const Instantiation_parameterSequence& s)
  {
    this->instantiation_parameter_ = s;
  }

  const T_process_class::Instance_variableSequence& T_process_class::
  getInstance_variable () const
  {
    return this->instance_variable_;
  }

  T_process_class::Instance_variableSequence& T_process_class::
  getInstance_variable ()
  {
    return this->instance_variable_;
  }

  void T_process_class::
  setInstance_variable (const Instance_variableSequence& s)
  {
    this->instance_variable_ = s;
  }

  const T_process_class::Initial_method_callType& T_process_class::
  getInitial_method_call () const
  {
    return this->initial_method_call_.get ();
  }

  T_process_class::Initial_method_callType& T_process_class::
  getInitial_method_call ()
  {
    return this->initial_method_call_.get ();
  }

  void T_process_class::
  setInitial_method_call (const Initial_method_callType& x)
  {
    this->initial_method_call_.set (x);
  }

  void T_process_class::
  setInitial_method_call (::std::unique_ptr< Initial_method_callType > x)
  {
    this->initial_method_call_.set (std::move (x));
  }

  const T_process_class::Process_methodSequence& T_process_class::
  getProcess_method () const
  {
    return this->process_method_;
  }

  T_process_class::Process_methodSequence& T_process_class::
  getProcess_method ()
  {
    return this->process_method_;
  }

  void T_process_class::
  setProcess_method (const Process_methodSequence& s)
  {
    this->process_method_ = s;
  }

  const T_process_class::AnnotationOptional& T_process_class::
  getAnnotation () const
  {
    return this->annotation_;
  }

  T_process_class::AnnotationOptional& T_process_class::
  getAnnotation ()
  {
    return this->annotation_;
  }

  void T_process_class::
  setAnnotation (const AnnotationType& x)
  {
    this->annotation_.set (x);
  }

  void T_process_class::
  setAnnotation (const AnnotationOptional& x)
  {
    this->annotation_ = x;
  }

  void T_process_class::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->annotation_.set (std::move (x));
  }

  const T_process_class::NameType& T_process_class::
  getName () const
  {
    return this->name_.get ();
  }

  T_process_class::NameType& T_process_class::
  getName ()
  {
    return this->name_.get ();
  }

  void T_process_class::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_process_class::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // T_process_method
  // 

  const T_process_method::ArgumentSequence& T_process_method::
  getArgument () const
  {
    return this->argument_;
  }

  T_process_method::ArgumentSequence& T_process_method::
  getArgument ()
  {
    return this->argument_;
  }

  void T_process_method::
  setArgument (const ArgumentSequence& s)
  {
    this->argument_ = s;
  }

  const T_process_method::Output_parameterSequence& T_process_method::
  getOutput_parameter () const
  {
    return this->output_parameter_;
  }

  T_process_method::Output_parameterSequence& T_process_method::
  getOutput_parameter ()
  {
    return this->output_parameter_;
  }

  void T_process_method::
  setOutput_parameter (const Output_parameterSequence& s)
  {
    this->output_parameter_ = s;
  }

  const T_process_method::Local_variableSequence& T_process_method::
  getLocal_variable () const
  {
    return this->local_variable_;
  }

  T_process_method::Local_variableSequence& T_process_method::
  getLocal_variable ()
  {
    return this->local_variable_;
  }

  void T_process_method::
  setLocal_variable (const Local_variableSequence& s)
  {
    this->local_variable_ = s;
  }

  const T_process_method::Body_textOptional& T_process_method::
  getBody_text () const
  {
    return this->body_text_;
  }

  T_process_method::Body_textOptional& T_process_method::
  getBody_text ()
  {
    return this->body_text_;
  }

  void T_process_method::
  setBody_text (const Body_textType& x)
  {
    this->body_text_.set (x);
  }

  void T_process_method::
  setBody_text (const Body_textOptional& x)
  {
    this->body_text_ = x;
  }

  void T_process_method::
  setBody_text (::std::unique_ptr< Body_textType > x)
  {
    this->body_text_.set (std::move (x));
  }

  const T_process_method::Body_statementType& T_process_method::
  getBody_statement () const
  {
    return this->body_statement_.get ();
  }

  T_process_method::Body_statementType& T_process_method::
  getBody_statement ()
  {
    return this->body_statement_.get ();
  }

  void T_process_method::
  setBody_statement (const Body_statementType& x)
  {
    this->body_statement_.set (x);
  }

  void T_process_method::
  setBody_statement (::std::unique_ptr< Body_statementType > x)
  {
    this->body_statement_.set (std::move (x));
  }

  const T_process_method::NameType& T_process_method::
  getName () const
  {
    return this->name_.get ();
  }

  T_process_method::NameType& T_process_method::
  getName ()
  {
    return this->name_.get ();
  }

  void T_process_method::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_process_method::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // T_cluster_class
  // 

  const T_cluster_class::InterfaceType& T_cluster_class::
  getInterface () const
  {
    return this->interface_.get ();
  }

  T_cluster_class::InterfaceType& T_cluster_class::
  getInterface ()
  {
    return this->interface_.get ();
  }

  void T_cluster_class::
  setInterface (const InterfaceType& x)
  {
    this->interface_.set (x);
  }

  void T_cluster_class::
  setInterface (::std::unique_ptr< InterfaceType > x)
  {
    this->interface_.set (std::move (x));
  }

  const T_cluster_class::Instantiation_parameterSequence& T_cluster_class::
  getInstantiation_parameter () const
  {
    return this->instantiation_parameter_;
  }

  T_cluster_class::Instantiation_parameterSequence& T_cluster_class::
  getInstantiation_parameter ()
  {
    return this->instantiation_parameter_;
  }

  void T_cluster_class::
  setInstantiation_parameter (const Instantiation_parameterSequence& s)
  {
    this->instantiation_parameter_ = s;
  }

  const T_cluster_class::ChannelSequence& T_cluster_class::
  getChannel () const
  {
    return this->channel_;
  }

  T_cluster_class::ChannelSequence& T_cluster_class::
  getChannel ()
  {
    return this->channel_;
  }

  void T_cluster_class::
  setChannel (const ChannelSequence& s)
  {
    this->channel_ = s;
  }

  const T_cluster_class::InstanceSequence& T_cluster_class::
  getInstance () const
  {
    return this->instance_;
  }

  T_cluster_class::InstanceSequence& T_cluster_class::
  getInstance ()
  {
    return this->instance_;
  }

  void T_cluster_class::
  setInstance (const InstanceSequence& s)
  {
    this->instance_ = s;
  }

  const T_cluster_class::AnnotationOptional& T_cluster_class::
  getAnnotation () const
  {
    return this->annotation_;
  }

  T_cluster_class::AnnotationOptional& T_cluster_class::
  getAnnotation ()
  {
    return this->annotation_;
  }

  void T_cluster_class::
  setAnnotation (const AnnotationType& x)
  {
    this->annotation_.set (x);
  }

  void T_cluster_class::
  setAnnotation (const AnnotationOptional& x)
  {
    this->annotation_ = x;
  }

  void T_cluster_class::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->annotation_.set (std::move (x));
  }

  const T_cluster_class::NameType& T_cluster_class::
  getName () const
  {
    return this->name_.get ();
  }

  T_cluster_class::NameType& T_cluster_class::
  getName ()
  {
    return this->name_.get ();
  }

  void T_cluster_class::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_cluster_class::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // T_top_level_specification
  // 

  const T_top_level_specification::InstanceSequence& T_top_level_specification::
  getInstance () const
  {
    return this->instance_;
  }

  T_top_level_specification::InstanceSequence& T_top_level_specification::
  getInstance ()
  {
    return this->instance_;
  }

  void T_top_level_specification::
  setInstance (const InstanceSequence& s)
  {
    this->instance_ = s;
  }

  const T_top_level_specification::ChannelSequence& T_top_level_specification::
  getChannel () const
  {
    return this->channel_;
  }

  T_top_level_specification::ChannelSequence& T_top_level_specification::
  getChannel ()
  {
    return this->channel_;
  }

  void T_top_level_specification::
  setChannel (const ChannelSequence& s)
  {
    this->channel_ = s;
  }

  const T_top_level_specification::AnnotationOptional& T_top_level_specification::
  getAnnotation () const
  {
    return this->annotation_;
  }

  T_top_level_specification::AnnotationOptional& T_top_level_specification::
  getAnnotation ()
  {
    return this->annotation_;
  }

  void T_top_level_specification::
  setAnnotation (const AnnotationType& x)
  {
    this->annotation_.set (x);
  }

  void T_top_level_specification::
  setAnnotation (const AnnotationOptional& x)
  {
    this->annotation_ = x;
  }

  void T_top_level_specification::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->annotation_.set (std::move (x));
  }


  // T_channel_internal
  // 

  const T_channel_internal::AnnotationOptional& T_channel_internal::
  getAnnotation () const
  {
    return this->annotation_;
  }

  T_channel_internal::AnnotationOptional& T_channel_internal::
  getAnnotation ()
  {
    return this->annotation_;
  }

  void T_channel_internal::
  setAnnotation (const AnnotationType& x)
  {
    this->annotation_.set (x);
  }

  void T_channel_internal::
  setAnnotation (const AnnotationOptional& x)
  {
    this->annotation_ = x;
  }

  void T_channel_internal::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->annotation_.set (std::move (x));
  }

  const T_channel_internal::NameOptional& T_channel_internal::
  getName () const
  {
    return this->name_;
  }

  T_channel_internal::NameOptional& T_channel_internal::
  getName ()
  {
    return this->name_;
  }

  void T_channel_internal::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_channel_internal::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void T_channel_internal::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // T_channel
  // 

  const T_channel::Output_portOptional& T_channel::
  getOutput_port () const
  {
    return this->output_port_;
  }

  T_channel::Output_portOptional& T_channel::
  getOutput_port ()
  {
    return this->output_port_;
  }

  void T_channel::
  setOutput_port (const Output_portType& x)
  {
    this->output_port_.set (x);
  }

  void T_channel::
  setOutput_port (const Output_portOptional& x)
  {
    this->output_port_ = x;
  }

  void T_channel::
  setOutput_port (::std::unique_ptr< Output_portType > x)
  {
    this->output_port_.set (std::move (x));
  }


  // T_instance
  // 

  const T_instance::Instantiation_expressionSequence& T_instance::
  getInstantiation_expression () const
  {
    return this->instantiation_expression_;
  }

  T_instance::Instantiation_expressionSequence& T_instance::
  getInstantiation_expression ()
  {
    return this->instantiation_expression_;
  }

  void T_instance::
  setInstantiation_expression (const Instantiation_expressionSequence& s)
  {
    this->instantiation_expression_ = s;
  }

  const T_instance::ConnectionSequence& T_instance::
  getConnection () const
  {
    return this->connection_;
  }

  T_instance::ConnectionSequence& T_instance::
  getConnection ()
  {
    return this->connection_;
  }

  void T_instance::
  setConnection (const ConnectionSequence& s)
  {
    this->connection_ = s;
  }

  const T_instance::AnnotationOptional& T_instance::
  getAnnotation () const
  {
    return this->annotation_;
  }

  T_instance::AnnotationOptional& T_instance::
  getAnnotation ()
  {
    return this->annotation_;
  }

  void T_instance::
  setAnnotation (const AnnotationType& x)
  {
    this->annotation_.set (x);
  }

  void T_instance::
  setAnnotation (const AnnotationOptional& x)
  {
    this->annotation_ = x;
  }

  void T_instance::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->annotation_.set (std::move (x));
  }

  const T_instance::TypeOptional& T_instance::
  getType () const
  {
    return this->type_;
  }

  T_instance::TypeOptional& T_instance::
  getType ()
  {
    return this->type_;
  }

  void T_instance::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void T_instance::
  setType (const TypeOptional& x)
  {
    this->type_ = x;
  }

  void T_instance::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }

  const T_instance::ClassOptional& T_instance::
  getClass () const
  {
    return this->class__;
  }

  T_instance::ClassOptional& T_instance::
  getClass ()
  {
    return this->class__;
  }

  void T_instance::
  setClass (const ClassType& x)
  {
    this->class__.set (x);
  }

  void T_instance::
  setClass (const ClassOptional& x)
  {
    this->class__ = x;
  }

  void T_instance::
  setClass (::std::unique_ptr< ClassType > x)
  {
    this->class__.set (std::move (x));
  }

  const T_instance::NameOptional& T_instance::
  getName () const
  {
    return this->name_;
  }

  T_instance::NameOptional& T_instance::
  getName ()
  {
    return this->name_;
  }

  void T_instance::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_instance::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void T_instance::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // T_connection
  // 

  const T_connection::AnnotationOptional& T_connection::
  getAnnotation () const
  {
    return this->annotation_;
  }

  T_connection::AnnotationOptional& T_connection::
  getAnnotation ()
  {
    return this->annotation_;
  }

  void T_connection::
  setAnnotation (const AnnotationType& x)
  {
    this->annotation_.set (x);
  }

  void T_connection::
  setAnnotation (const AnnotationOptional& x)
  {
    this->annotation_ = x;
  }

  void T_connection::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->annotation_.set (std::move (x));
  }

  const T_connection::PortType& T_connection::
  getPort () const
  {
    return this->port_.get ();
  }

  T_connection::PortType& T_connection::
  getPort ()
  {
    return this->port_.get ();
  }

  void T_connection::
  setPort (const PortType& x)
  {
    this->port_.set (x);
  }

  void T_connection::
  setPort (::std::unique_ptr< PortType > x)
  {
    this->port_.set (std::move (x));
  }

  const T_connection::ChannelType& T_connection::
  getChannel () const
  {
    return this->channel_.get ();
  }

  T_connection::ChannelType& T_connection::
  getChannel ()
  {
    return this->channel_.get ();
  }

  void T_connection::
  setChannel (const ChannelType& x)
  {
    this->channel_.set (x);
  }

  void T_connection::
  setChannel (::std::unique_ptr< ChannelType > x)
  {
    this->channel_.set (std::move (x));
  }


  // T_initial_method_call
  // 

  const T_initial_method_call::Method_call_textOptional& T_initial_method_call::
  getMethod_call_text () const
  {
    return this->method_call_text_;
  }

  T_initial_method_call::Method_call_textOptional& T_initial_method_call::
  getMethod_call_text ()
  {
    return this->method_call_text_;
  }

  void T_initial_method_call::
  setMethod_call_text (const Method_call_textType& x)
  {
    this->method_call_text_.set (x);
  }

  void T_initial_method_call::
  setMethod_call_text (const Method_call_textOptional& x)
  {
    this->method_call_text_ = x;
  }

  void T_initial_method_call::
  setMethod_call_text (::std::unique_ptr< Method_call_textType > x)
  {
    this->method_call_text_.set (std::move (x));
  }

  const T_initial_method_call::Process_method_callType& T_initial_method_call::
  getProcess_method_call () const
  {
    return this->process_method_call_.get ();
  }

  T_initial_method_call::Process_method_callType& T_initial_method_call::
  getProcess_method_call ()
  {
    return this->process_method_call_.get ();
  }

  void T_initial_method_call::
  setProcess_method_call (const Process_method_callType& x)
  {
    this->process_method_call_.set (x);
  }

  void T_initial_method_call::
  setProcess_method_call (::std::unique_ptr< Process_method_callType > x)
  {
    this->process_method_call_.set (std::move (x));
  }


  // T_instantiation_expression
  // 

  const T_instantiation_expression::Body_textOptional& T_instantiation_expression::
  getBody_text () const
  {
    return this->body_text_;
  }

  T_instantiation_expression::Body_textOptional& T_instantiation_expression::
  getBody_text ()
  {
    return this->body_text_;
  }

  void T_instantiation_expression::
  setBody_text (const Body_textType& x)
  {
    this->body_text_.set (x);
  }

  void T_instantiation_expression::
  setBody_text (const Body_textOptional& x)
  {
    this->body_text_ = x;
  }

  void T_instantiation_expression::
  setBody_text (::std::unique_ptr< Body_textType > x)
  {
    this->body_text_.set (std::move (x));
  }

  const T_instantiation_expression::Body_expressionType& T_instantiation_expression::
  getBody_expression () const
  {
    return this->body_expression_.get ();
  }

  T_instantiation_expression::Body_expressionType& T_instantiation_expression::
  getBody_expression ()
  {
    return this->body_expression_.get ();
  }

  void T_instantiation_expression::
  setBody_expression (const Body_expressionType& x)
  {
    this->body_expression_.set (x);
  }

  void T_instantiation_expression::
  setBody_expression (::std::unique_ptr< Body_expressionType > x)
  {
    this->body_expression_.set (std::move (x));
  }

  const T_instantiation_expression::Parameter_nameType& T_instantiation_expression::
  getParameter_name () const
  {
    return this->parameter_name_.get ();
  }

  T_instantiation_expression::Parameter_nameType& T_instantiation_expression::
  getParameter_name ()
  {
    return this->parameter_name_.get ();
  }

  void T_instantiation_expression::
  setParameter_name (const Parameter_nameType& x)
  {
    this->parameter_name_.set (x);
  }

  void T_instantiation_expression::
  setParameter_name (::std::unique_ptr< Parameter_nameType > x)
  {
    this->parameter_name_.set (std::move (x));
  }


  // T_interface
  // 

  const T_interface::PortSequence& T_interface::
  getPort () const
  {
    return this->port_;
  }

  T_interface::PortSequence& T_interface::
  getPort ()
  {
    return this->port_;
  }

  void T_interface::
  setPort (const PortSequence& s)
  {
    this->port_ = s;
  }


  // T_port
  // 

  const T_port::MessageSequence& T_port::
  getMessage () const
  {
    return this->message_;
  }

  T_port::MessageSequence& T_port::
  getMessage ()
  {
    return this->message_;
  }

  void T_port::
  setMessage (const MessageSequence& s)
  {
    this->message_ = s;
  }

  const T_port::AnnotationOptional& T_port::
  getAnnotation () const
  {
    return this->annotation_;
  }

  T_port::AnnotationOptional& T_port::
  getAnnotation ()
  {
    return this->annotation_;
  }

  void T_port::
  setAnnotation (const AnnotationType& x)
  {
    this->annotation_.set (x);
  }

  void T_port::
  setAnnotation (const AnnotationOptional& x)
  {
    this->annotation_ = x;
  }

  void T_port::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->annotation_.set (std::move (x));
  }

  const T_port::NameOptional& T_port::
  getName () const
  {
    return this->name_;
  }

  T_port::NameOptional& T_port::
  getName ()
  {
    return this->name_;
  }

  void T_port::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_port::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void T_port::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // T_message
  // 

  const T_message::ArgumentSequence& T_message::
  getArgument () const
  {
    return this->argument_;
  }

  T_message::ArgumentSequence& T_message::
  getArgument ()
  {
    return this->argument_;
  }

  void T_message::
  setArgument (const ArgumentSequence& s)
  {
    this->argument_ = s;
  }

  const T_message::TypeOptional& T_message::
  getType () const
  {
    return this->type_;
  }

  T_message::TypeOptional& T_message::
  getType ()
  {
    return this->type_;
  }

  void T_message::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void T_message::
  setType (const TypeOptional& x)
  {
    this->type_ = x;
  }

  void T_message::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }

  const T_message::NameOptional& T_message::
  getName () const
  {
    return this->name_;
  }

  T_message::NameOptional& T_message::
  getName ()
  {
    return this->name_;
  }

  void T_message::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_message::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void T_message::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // T_cluster_interface
  // 

  const T_cluster_interface::PortSequence& T_cluster_interface::
  getPort () const
  {
    return this->port_;
  }

  T_cluster_interface::PortSequence& T_cluster_interface::
  getPort ()
  {
    return this->port_;
  }

  void T_cluster_interface::
  setPort (const PortSequence& s)
  {
    this->port_ = s;
  }


  // T_instance_type
  // 

  T_instance_type::
  T_instance_type ()
  : ::xml_schema::String ()
  {
  }

  T_instance_type::
  T_instance_type (Value v)
  : ::xml_schema::String (_xsd_T_instance_type_literals_[v])
  {
  }

  T_instance_type::
  T_instance_type (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_instance_type::
  T_instance_type (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_instance_type::
  T_instance_type (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_instance_type::
  T_instance_type (const T_instance_type& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_instance_type& T_instance_type::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_instance_type_literals_[v]);

    return *this;
  }


  // T_annotation
  // 

  const T_annotation::AnySequence& T_annotation::
  getAny () const
  {
    return this->any_;
  }

  T_annotation::AnySequence& T_annotation::
  getAny ()
  {
    return this->any_;
  }

  void T_annotation::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const ::xercesc::DOMDocument& T_annotation::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& T_annotation::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // T_top_level_annotation
  // 


  // T_data_class_annotation
  // 


  // T_process_class_annotation
  // 


  // T_cluster_class_annotation
  // 


  // T_channel_annotation
  // 


  // T_instance_annotation
  // 


  // T_port_annotation
  // 


  // T_connection_annotation
  // 
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace poosl
{
  // T_poosl_specification
  //

  T_poosl_specification::
  T_poosl_specification ()
  : ::xml_schema::Type (),
    name_ (this),
    data_classes_ (this),
    process_classes_ (this),
    cluster_classes_ (this),
    top_level_specification_ (this),
    description_ (this)
  {
  }

  T_poosl_specification::
  T_poosl_specification (const Data_classesType& data_classes)
  : ::xml_schema::Type (),
    name_ (this),
    data_classes_ (data_classes, this),
    process_classes_ (this),
    cluster_classes_ (this),
    top_level_specification_ (this),
    description_ (this)
  {
  }

  T_poosl_specification::
  T_poosl_specification (::std::unique_ptr< Data_classesType > data_classes)
  : ::xml_schema::Type (),
    name_ (this),
    data_classes_ (std::move (data_classes), this),
    process_classes_ (this),
    cluster_classes_ (this),
    top_level_specification_ (this),
    description_ (this)
  {
  }

  T_poosl_specification::
  T_poosl_specification (const T_poosl_specification& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    data_classes_ (x.data_classes_, f, this),
    process_classes_ (x.process_classes_, f, this),
    cluster_classes_ (x.cluster_classes_, f, this),
    top_level_specification_ (x.top_level_specification_, f, this),
    description_ (x.description_, f, this)
  {
  }

  T_poosl_specification::
  T_poosl_specification (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    data_classes_ (this),
    process_classes_ (this),
    cluster_classes_ (this),
    top_level_specification_ (this),
    description_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_poosl_specification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // data_classes
      //
      if (n.name () == "data_classes" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Data_classesType > r (
          Data_classesTraits::create (i, f, this));

        if (!data_classes_.present ())
        {
          this->data_classes_.set (::std::move (r));
          continue;
        }
      }

      // process_classes
      //
      if (n.name () == "process_classes" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_classesType > r (
          Process_classesTraits::create (i, f, this));

        if (!this->process_classes_)
        {
          this->process_classes_.set (::std::move (r));
          continue;
        }
      }

      // cluster_classes
      //
      if (n.name () == "cluster_classes" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Cluster_classesType > r (
          Cluster_classesTraits::create (i, f, this));

        if (!this->cluster_classes_)
        {
          this->cluster_classes_.set (::std::move (r));
          continue;
        }
      }

      // top_level_specification
      //
      if (n.name () == "top_level_specification" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Top_level_specificationType > r (
          Top_level_specificationTraits::create (i, f, this));

        if (!this->top_level_specification_)
        {
          this->top_level_specification_.set (::std::move (r));
          continue;
        }
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< DescriptionType > r (
          DescriptionTraits::create (i, f, this));

        if (!this->description_)
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!data_classes_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "data_classes",
        "uri:poosl");
    }
  }

  T_poosl_specification* T_poosl_specification::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_poosl_specification (*this, f, c);
  }

  T_poosl_specification& T_poosl_specification::
  operator= (const T_poosl_specification& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->data_classes_ = x.data_classes_;
      this->process_classes_ = x.process_classes_;
      this->cluster_classes_ = x.cluster_classes_;
      this->top_level_specification_ = x.top_level_specification_;
      this->description_ = x.description_;
    }

    return *this;
  }

  T_poosl_specification::
  ~T_poosl_specification ()
  {
  }

  // T_cluster_classes
  //

  T_cluster_classes::
  T_cluster_classes ()
  : ::xml_schema::Type (),
    cluster_class_ (this)
  {
  }

  T_cluster_classes::
  T_cluster_classes (const T_cluster_classes& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    cluster_class_ (x.cluster_class_, f, this)
  {
  }

  T_cluster_classes::
  T_cluster_classes (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    cluster_class_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_cluster_classes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cluster_class
      //
      if (n.name () == "cluster_class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Cluster_classType > r (
          Cluster_classTraits::create (i, f, this));

        this->cluster_class_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_cluster_classes* T_cluster_classes::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_cluster_classes (*this, f, c);
  }

  T_cluster_classes& T_cluster_classes::
  operator= (const T_cluster_classes& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->cluster_class_ = x.cluster_class_;
    }

    return *this;
  }

  T_cluster_classes::
  ~T_cluster_classes ()
  {
  }

  // T_process_classes
  //

  T_process_classes::
  T_process_classes ()
  : ::xml_schema::Type (),
    process_class_ (this)
  {
  }

  T_process_classes::
  T_process_classes (const T_process_classes& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    process_class_ (x.process_class_, f, this)
  {
  }

  T_process_classes::
  T_process_classes (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    process_class_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_process_classes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // process_class
      //
      if (n.name () == "process_class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_classType > r (
          Process_classTraits::create (i, f, this));

        this->process_class_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_process_classes* T_process_classes::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_process_classes (*this, f, c);
  }

  T_process_classes& T_process_classes::
  operator= (const T_process_classes& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->process_class_ = x.process_class_;
    }

    return *this;
  }

  T_process_classes::
  ~T_process_classes ()
  {
  }

  // T_data_classes
  //

  T_data_classes::
  T_data_classes ()
  : ::xml_schema::Type (),
    data_class_ (this)
  {
  }

  T_data_classes::
  T_data_classes (const T_data_classes& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    data_class_ (x.data_class_, f, this)
  {
  }

  T_data_classes::
  T_data_classes (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    data_class_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_data_classes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // data_class
      //
      if (n.name () == "data_class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Data_classType > r (
          Data_classTraits::create (i, f, this));

        this->data_class_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_data_classes* T_data_classes::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_data_classes (*this, f, c);
  }

  T_data_classes& T_data_classes::
  operator= (const T_data_classes& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->data_class_ = x.data_class_;
    }

    return *this;
  }

  T_data_classes::
  ~T_data_classes ()
  {
  }

  // T_data_class
  //

  T_data_class::
  T_data_class ()
  : ::xml_schema::Type (),
    super_class_ (this),
    instance_variable_ (this),
    data_method_ (this),
    annotation_ (this),
    name_ (this),
    native_ (this)
  {
  }

  T_data_class::
  T_data_class (const NameType& name)
  : ::xml_schema::Type (),
    super_class_ (this),
    instance_variable_ (this),
    data_method_ (this),
    annotation_ (this),
    name_ (name, this),
    native_ (this)
  {
  }

  T_data_class::
  T_data_class (const T_data_class& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    super_class_ (x.super_class_, f, this),
    instance_variable_ (x.instance_variable_, f, this),
    data_method_ (x.data_method_, f, this),
    annotation_ (x.annotation_, f, this),
    name_ (x.name_, f, this),
    native_ (x.native_, f, this)
  {
  }

  T_data_class::
  T_data_class (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    super_class_ (this),
    instance_variable_ (this),
    data_method_ (this),
    annotation_ (this),
    name_ (this),
    native_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_data_class::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // super_class
      //
      if (n.name () == "super_class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Super_classType > r (
          Super_classTraits::create (i, f, this));

        if (!this->super_class_)
        {
          this->super_class_.set (::std::move (r));
          continue;
        }
      }

      // instance_variable
      //
      if (n.name () == "instance_variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Instance_variableType > r (
          Instance_variableTraits::create (i, f, this));

        this->instance_variable_.push_back (::std::move (r));
        continue;
      }

      // data_method
      //
      if (n.name () == "data_method" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Data_methodType > r (
          Data_methodTraits::create (i, f, this));

        this->data_method_.push_back (::std::move (r));
        continue;
      }

      // annotation
      //
      if (n.name () == "annotation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->annotation_)
        {
          this->annotation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "native" && n.namespace_ ().empty ())
      {
        this->native_.set (NativeTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  T_data_class* T_data_class::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_data_class (*this, f, c);
  }

  T_data_class& T_data_class::
  operator= (const T_data_class& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->super_class_ = x.super_class_;
      this->instance_variable_ = x.instance_variable_;
      this->data_method_ = x.data_method_;
      this->annotation_ = x.annotation_;
      this->name_ = x.name_;
      this->native_ = x.native_;
    }

    return *this;
  }

  T_data_class::
  ~T_data_class ()
  {
  }

  // T_data_method
  //

  T_data_method::
  T_data_method ()
  : ::xml_schema::Type (),
    return_type_ (this),
    argument_ (this),
    local_variable_ (this),
    body_text_ (this),
    body_expression_ (this),
    name_ (this),
    native_ (this)
  {
  }

  T_data_method::
  T_data_method (const Return_typeType& return_type,
                 const NameType& name)
  : ::xml_schema::Type (),
    return_type_ (return_type, this),
    argument_ (this),
    local_variable_ (this),
    body_text_ (this),
    body_expression_ (this),
    name_ (name, this),
    native_ (this)
  {
  }

  T_data_method::
  T_data_method (const T_data_method& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    return_type_ (x.return_type_, f, this),
    argument_ (x.argument_, f, this),
    local_variable_ (x.local_variable_, f, this),
    body_text_ (x.body_text_, f, this),
    body_expression_ (x.body_expression_, f, this),
    name_ (x.name_, f, this),
    native_ (x.native_, f, this)
  {
  }

  T_data_method::
  T_data_method (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    return_type_ (this),
    argument_ (this),
    local_variable_ (this),
    body_text_ (this),
    body_expression_ (this),
    name_ (this),
    native_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_data_method::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // return_type
      //
      if (n.name () == "return_type" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Return_typeType > r (
          Return_typeTraits::create (i, f, this));

        if (!return_type_.present ())
        {
          this->return_type_.set (::std::move (r));
          continue;
        }
      }

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ArgumentType > r (
          ArgumentTraits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      // local_variable
      //
      if (n.name () == "local_variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Local_variableType > r (
          Local_variableTraits::create (i, f, this));

        this->local_variable_.push_back (::std::move (r));
        continue;
      }

      // body_text
      //
      if (n.name () == "body_text" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Body_textType > r (
          Body_textTraits::create (i, f, this));

        if (!this->body_text_)
        {
          this->body_text_.set (::std::move (r));
          continue;
        }
      }

      // body_expression
      //
      if (n.name () == "body_expression" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Body_expressionType > r (
          Body_expressionTraits::create (i, f, this));

        if (!this->body_expression_)
        {
          this->body_expression_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!return_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "return_type",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "native" && n.namespace_ ().empty ())
      {
        this->native_.set (NativeTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  T_data_method* T_data_method::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_data_method (*this, f, c);
  }

  T_data_method& T_data_method::
  operator= (const T_data_method& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->return_type_ = x.return_type_;
      this->argument_ = x.argument_;
      this->local_variable_ = x.local_variable_;
      this->body_text_ = x.body_text_;
      this->body_expression_ = x.body_expression_;
      this->name_ = x.name_;
      this->native_ = x.native_;
    }

    return *this;
  }

  T_data_method::
  ~T_data_method ()
  {
  }

  // T_process_class
  //

  T_process_class::
  T_process_class ()
  : ::xml_schema::Type (),
    interface_ (this),
    super_class_ (this),
    instantiation_parameter_ (this),
    instance_variable_ (this),
    initial_method_call_ (this),
    process_method_ (this),
    annotation_ (this),
    name_ (this)
  {
  }

  T_process_class::
  T_process_class (const InterfaceType& interface,
                   const Initial_method_callType& initial_method_call,
                   const NameType& name)
  : ::xml_schema::Type (),
    interface_ (interface, this),
    super_class_ (this),
    instantiation_parameter_ (this),
    instance_variable_ (this),
    initial_method_call_ (initial_method_call, this),
    process_method_ (this),
    annotation_ (this),
    name_ (name, this)
  {
  }

  T_process_class::
  T_process_class (::std::unique_ptr< InterfaceType > interface,
                   ::std::unique_ptr< Initial_method_callType > initial_method_call,
                   const NameType& name)
  : ::xml_schema::Type (),
    interface_ (std::move (interface), this),
    super_class_ (this),
    instantiation_parameter_ (this),
    instance_variable_ (this),
    initial_method_call_ (std::move (initial_method_call), this),
    process_method_ (this),
    annotation_ (this),
    name_ (name, this)
  {
  }

  T_process_class::
  T_process_class (const T_process_class& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    interface_ (x.interface_, f, this),
    super_class_ (x.super_class_, f, this),
    instantiation_parameter_ (x.instantiation_parameter_, f, this),
    instance_variable_ (x.instance_variable_, f, this),
    initial_method_call_ (x.initial_method_call_, f, this),
    process_method_ (x.process_method_, f, this),
    annotation_ (x.annotation_, f, this),
    name_ (x.name_, f, this)
  {
  }

  T_process_class::
  T_process_class (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    interface_ (this),
    super_class_ (this),
    instantiation_parameter_ (this),
    instance_variable_ (this),
    initial_method_call_ (this),
    process_method_ (this),
    annotation_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_process_class::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // interface
      //
      if (n.name () == "interface" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InterfaceType > r (
          InterfaceTraits::create (i, f, this));

        if (!interface_.present ())
        {
          this->interface_.set (::std::move (r));
          continue;
        }
      }

      // super_class
      //
      if (n.name () == "super_class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Super_classType > r (
          Super_classTraits::create (i, f, this));

        if (!this->super_class_)
        {
          this->super_class_.set (::std::move (r));
          continue;
        }
      }

      // instantiation_parameter
      //
      if (n.name () == "instantiation_parameter" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Instantiation_parameterType > r (
          Instantiation_parameterTraits::create (i, f, this));

        this->instantiation_parameter_.push_back (::std::move (r));
        continue;
      }

      // instance_variable
      //
      if (n.name () == "instance_variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Instance_variableType > r (
          Instance_variableTraits::create (i, f, this));

        this->instance_variable_.push_back (::std::move (r));
        continue;
      }

      // initial_method_call
      //
      if (n.name () == "initial_method_call" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Initial_method_callType > r (
          Initial_method_callTraits::create (i, f, this));

        if (!initial_method_call_.present ())
        {
          this->initial_method_call_.set (::std::move (r));
          continue;
        }
      }

      // process_method
      //
      if (n.name () == "process_method" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_methodType > r (
          Process_methodTraits::create (i, f, this));

        this->process_method_.push_back (::std::move (r));
        continue;
      }

      // annotation
      //
      if (n.name () == "annotation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->annotation_)
        {
          this->annotation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!interface_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "interface",
        "uri:poosl");
    }

    if (!initial_method_call_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "initial_method_call",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  T_process_class* T_process_class::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_process_class (*this, f, c);
  }

  T_process_class& T_process_class::
  operator= (const T_process_class& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->interface_ = x.interface_;
      this->super_class_ = x.super_class_;
      this->instantiation_parameter_ = x.instantiation_parameter_;
      this->instance_variable_ = x.instance_variable_;
      this->initial_method_call_ = x.initial_method_call_;
      this->process_method_ = x.process_method_;
      this->annotation_ = x.annotation_;
      this->name_ = x.name_;
    }

    return *this;
  }

  T_process_class::
  ~T_process_class ()
  {
  }

  // T_process_method
  //

  T_process_method::
  T_process_method ()
  : ::xml_schema::Type (),
    argument_ (this),
    output_parameter_ (this),
    local_variable_ (this),
    body_text_ (this),
    body_statement_ (this),
    name_ (this)
  {
  }

  T_process_method::
  T_process_method (const Body_statementType& body_statement,
                    const NameType& name)
  : ::xml_schema::Type (),
    argument_ (this),
    output_parameter_ (this),
    local_variable_ (this),
    body_text_ (this),
    body_statement_ (body_statement, this),
    name_ (name, this)
  {
  }

  T_process_method::
  T_process_method (::std::unique_ptr< Body_statementType > body_statement,
                    const NameType& name)
  : ::xml_schema::Type (),
    argument_ (this),
    output_parameter_ (this),
    local_variable_ (this),
    body_text_ (this),
    body_statement_ (std::move (body_statement), this),
    name_ (name, this)
  {
  }

  T_process_method::
  T_process_method (const T_process_method& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    argument_ (x.argument_, f, this),
    output_parameter_ (x.output_parameter_, f, this),
    local_variable_ (x.local_variable_, f, this),
    body_text_ (x.body_text_, f, this),
    body_statement_ (x.body_statement_, f, this),
    name_ (x.name_, f, this)
  {
  }

  T_process_method::
  T_process_method (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    argument_ (this),
    output_parameter_ (this),
    local_variable_ (this),
    body_text_ (this),
    body_statement_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_process_method::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ArgumentType > r (
          ArgumentTraits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      // output_parameter
      //
      if (n.name () == "output_parameter" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Output_parameterType > r (
          Output_parameterTraits::create (i, f, this));

        this->output_parameter_.push_back (::std::move (r));
        continue;
      }

      // local_variable
      //
      if (n.name () == "local_variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Local_variableType > r (
          Local_variableTraits::create (i, f, this));

        this->local_variable_.push_back (::std::move (r));
        continue;
      }

      // body_text
      //
      if (n.name () == "body_text" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Body_textType > r (
          Body_textTraits::create (i, f, this));

        if (!this->body_text_)
        {
          this->body_text_.set (::std::move (r));
          continue;
        }
      }

      // body_statement
      //
      if (n.name () == "body_statement" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Body_statementType > r (
          Body_statementTraits::create (i, f, this));

        if (!body_statement_.present ())
        {
          this->body_statement_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!body_statement_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "body_statement",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  T_process_method* T_process_method::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_process_method (*this, f, c);
  }

  T_process_method& T_process_method::
  operator= (const T_process_method& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->argument_ = x.argument_;
      this->output_parameter_ = x.output_parameter_;
      this->local_variable_ = x.local_variable_;
      this->body_text_ = x.body_text_;
      this->body_statement_ = x.body_statement_;
      this->name_ = x.name_;
    }

    return *this;
  }

  T_process_method::
  ~T_process_method ()
  {
  }

  // T_cluster_class
  //

  T_cluster_class::
  T_cluster_class ()
  : ::xml_schema::Type (),
    interface_ (this),
    instantiation_parameter_ (this),
    channel_ (this),
    instance_ (this),
    annotation_ (this),
    name_ (this)
  {
  }

  T_cluster_class::
  T_cluster_class (const InterfaceType& interface,
                   const NameType& name)
  : ::xml_schema::Type (),
    interface_ (interface, this),
    instantiation_parameter_ (this),
    channel_ (this),
    instance_ (this),
    annotation_ (this),
    name_ (name, this)
  {
  }

  T_cluster_class::
  T_cluster_class (::std::unique_ptr< InterfaceType > interface,
                   const NameType& name)
  : ::xml_schema::Type (),
    interface_ (std::move (interface), this),
    instantiation_parameter_ (this),
    channel_ (this),
    instance_ (this),
    annotation_ (this),
    name_ (name, this)
  {
  }

  T_cluster_class::
  T_cluster_class (const T_cluster_class& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    interface_ (x.interface_, f, this),
    instantiation_parameter_ (x.instantiation_parameter_, f, this),
    channel_ (x.channel_, f, this),
    instance_ (x.instance_, f, this),
    annotation_ (x.annotation_, f, this),
    name_ (x.name_, f, this)
  {
  }

  T_cluster_class::
  T_cluster_class (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    interface_ (this),
    instantiation_parameter_ (this),
    channel_ (this),
    instance_ (this),
    annotation_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_cluster_class::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // interface
      //
      if (n.name () == "interface" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InterfaceType > r (
          InterfaceTraits::create (i, f, this));

        if (!interface_.present ())
        {
          this->interface_.set (::std::move (r));
          continue;
        }
      }

      // instantiation_parameter
      //
      if (n.name () == "instantiation_parameter" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Instantiation_parameterType > r (
          Instantiation_parameterTraits::create (i, f, this));

        this->instantiation_parameter_.push_back (::std::move (r));
        continue;
      }

      // channel
      //
      if (n.name () == "channel" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ChannelType > r (
          ChannelTraits::create (i, f, this));

        this->channel_.push_back (::std::move (r));
        continue;
      }

      // instance
      //
      if (n.name () == "instance" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InstanceType > r (
          InstanceTraits::create (i, f, this));

        this->instance_.push_back (::std::move (r));
        continue;
      }

      // annotation
      //
      if (n.name () == "annotation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->annotation_)
        {
          this->annotation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!interface_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "interface",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  T_cluster_class* T_cluster_class::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_cluster_class (*this, f, c);
  }

  T_cluster_class& T_cluster_class::
  operator= (const T_cluster_class& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->interface_ = x.interface_;
      this->instantiation_parameter_ = x.instantiation_parameter_;
      this->channel_ = x.channel_;
      this->instance_ = x.instance_;
      this->annotation_ = x.annotation_;
      this->name_ = x.name_;
    }

    return *this;
  }

  T_cluster_class::
  ~T_cluster_class ()
  {
  }

  // T_top_level_specification
  //

  T_top_level_specification::
  T_top_level_specification ()
  : ::xml_schema::Type (),
    instance_ (this),
    channel_ (this),
    annotation_ (this)
  {
  }

  T_top_level_specification::
  T_top_level_specification (const T_top_level_specification& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    instance_ (x.instance_, f, this),
    channel_ (x.channel_, f, this),
    annotation_ (x.annotation_, f, this)
  {
  }

  T_top_level_specification::
  T_top_level_specification (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    instance_ (this),
    channel_ (this),
    annotation_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_top_level_specification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // instance
      //
      if (n.name () == "instance" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InstanceType > r (
          InstanceTraits::create (i, f, this));

        this->instance_.push_back (::std::move (r));
        continue;
      }

      // channel
      //
      if (n.name () == "channel" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ChannelType > r (
          ChannelTraits::create (i, f, this));

        this->channel_.push_back (::std::move (r));
        continue;
      }

      // annotation
      //
      if (n.name () == "annotation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->annotation_)
        {
          this->annotation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  T_top_level_specification* T_top_level_specification::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_top_level_specification (*this, f, c);
  }

  T_top_level_specification& T_top_level_specification::
  operator= (const T_top_level_specification& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->instance_ = x.instance_;
      this->channel_ = x.channel_;
      this->annotation_ = x.annotation_;
    }

    return *this;
  }

  T_top_level_specification::
  ~T_top_level_specification ()
  {
  }

  // T_channel_internal
  //

  T_channel_internal::
  T_channel_internal ()
  : ::xml_schema::Type (),
    annotation_ (this),
    name_ (this)
  {
  }

  T_channel_internal::
  T_channel_internal (const T_channel_internal& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    annotation_ (x.annotation_, f, this),
    name_ (x.name_, f, this)
  {
  }

  T_channel_internal::
  T_channel_internal (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    annotation_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_channel_internal::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // annotation
      //
      if (n.name () == "annotation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->annotation_)
        {
          this->annotation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_channel_internal* T_channel_internal::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_channel_internal (*this, f, c);
  }

  T_channel_internal& T_channel_internal::
  operator= (const T_channel_internal& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->annotation_ = x.annotation_;
      this->name_ = x.name_;
    }

    return *this;
  }

  T_channel_internal::
  ~T_channel_internal ()
  {
  }

  // T_channel
  //

  T_channel::
  T_channel ()
  : ::poosl::T_channel_internal (),
    output_port_ (this)
  {
  }

  T_channel::
  T_channel (const T_channel& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::poosl::T_channel_internal (x, f, c),
    output_port_ (x.output_port_, f, this)
  {
  }

  T_channel::
  T_channel (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::poosl::T_channel_internal (e, f | ::xml_schema::Flags::base, c),
    output_port_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_channel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::poosl::T_channel_internal::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "output_port" && n.namespace_ ().empty ())
      {
        this->output_port_.set (Output_portTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_channel* T_channel::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_channel (*this, f, c);
  }

  T_channel& T_channel::
  operator= (const T_channel& x)
  {
    if (this != &x)
    {
      static_cast< ::poosl::T_channel_internal& > (*this) = x;
      this->output_port_ = x.output_port_;
    }

    return *this;
  }

  T_channel::
  ~T_channel ()
  {
  }

  // T_instance
  //

  T_instance::
  T_instance ()
  : ::xml_schema::Type (),
    instantiation_expression_ (this),
    connection_ (this),
    annotation_ (this),
    type_ (this),
    class__ (this),
    name_ (this)
  {
  }

  T_instance::
  T_instance (const T_instance& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    instantiation_expression_ (x.instantiation_expression_, f, this),
    connection_ (x.connection_, f, this),
    annotation_ (x.annotation_, f, this),
    type_ (x.type_, f, this),
    class__ (x.class__, f, this),
    name_ (x.name_, f, this)
  {
  }

  T_instance::
  T_instance (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    instantiation_expression_ (this),
    connection_ (this),
    annotation_ (this),
    type_ (this),
    class__ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_instance::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // instantiation_expression
      //
      if (n.name () == "instantiation_expression" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Instantiation_expressionType > r (
          Instantiation_expressionTraits::create (i, f, this));

        this->instantiation_expression_.push_back (::std::move (r));
        continue;
      }

      // connection
      //
      if (n.name () == "connection" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ConnectionType > r (
          ConnectionTraits::create (i, f, this));

        this->connection_.push_back (::std::move (r));
        continue;
      }

      // annotation
      //
      if (n.name () == "annotation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->annotation_)
        {
          this->annotation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "class" && n.namespace_ ().empty ())
      {
        this->class__.set (ClassTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_instance* T_instance::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_instance (*this, f, c);
  }

  T_instance& T_instance::
  operator= (const T_instance& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->instantiation_expression_ = x.instantiation_expression_;
      this->connection_ = x.connection_;
      this->annotation_ = x.annotation_;
      this->type_ = x.type_;
      this->class__ = x.class__;
      this->name_ = x.name_;
    }

    return *this;
  }

  T_instance::
  ~T_instance ()
  {
  }

  // T_connection
  //

  T_connection::
  T_connection ()
  : ::xml_schema::Type (),
    annotation_ (this),
    port_ (this),
    channel_ (this)
  {
  }

  T_connection::
  T_connection (const PortType& port,
                const ChannelType& channel)
  : ::xml_schema::Type (),
    annotation_ (this),
    port_ (port, this),
    channel_ (channel, this)
  {
  }

  T_connection::
  T_connection (const T_connection& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    annotation_ (x.annotation_, f, this),
    port_ (x.port_, f, this),
    channel_ (x.channel_, f, this)
  {
  }

  T_connection::
  T_connection (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    annotation_ (this),
    port_ (this),
    channel_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_connection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // annotation
      //
      if (n.name () == "annotation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->annotation_)
        {
          this->annotation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (PortTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "channel" && n.namespace_ ().empty ())
      {
        this->channel_.set (ChannelTraits::create (i, f, this));
        continue;
      }
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }

    if (!channel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "channel",
        "");
    }
  }

  T_connection* T_connection::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_connection (*this, f, c);
  }

  T_connection& T_connection::
  operator= (const T_connection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->annotation_ = x.annotation_;
      this->port_ = x.port_;
      this->channel_ = x.channel_;
    }

    return *this;
  }

  T_connection::
  ~T_connection ()
  {
  }

  // T_initial_method_call
  //

  T_initial_method_call::
  T_initial_method_call ()
  : ::xml_schema::Type (),
    method_call_text_ (this),
    process_method_call_ (this)
  {
  }

  T_initial_method_call::
  T_initial_method_call (const Process_method_callType& process_method_call)
  : ::xml_schema::Type (),
    method_call_text_ (this),
    process_method_call_ (process_method_call, this)
  {
  }

  T_initial_method_call::
  T_initial_method_call (::std::unique_ptr< Process_method_callType > process_method_call)
  : ::xml_schema::Type (),
    method_call_text_ (this),
    process_method_call_ (std::move (process_method_call), this)
  {
  }

  T_initial_method_call::
  T_initial_method_call (const T_initial_method_call& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    method_call_text_ (x.method_call_text_, f, this),
    process_method_call_ (x.process_method_call_, f, this)
  {
  }

  T_initial_method_call::
  T_initial_method_call (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    method_call_text_ (this),
    process_method_call_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_initial_method_call::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // method_call_text
      //
      if (n.name () == "method_call_text" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Method_call_textType > r (
          Method_call_textTraits::create (i, f, this));

        if (!this->method_call_text_)
        {
          this->method_call_text_.set (::std::move (r));
          continue;
        }
      }

      // process_method_call
      //
      if (n.name () == "process_method_call" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_method_callType > r (
          Process_method_callTraits::create (i, f, this));

        if (!process_method_call_.present ())
        {
          this->process_method_call_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!process_method_call_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "process_method_call",
        "uri:poosl");
    }
  }

  T_initial_method_call* T_initial_method_call::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_initial_method_call (*this, f, c);
  }

  T_initial_method_call& T_initial_method_call::
  operator= (const T_initial_method_call& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->method_call_text_ = x.method_call_text_;
      this->process_method_call_ = x.process_method_call_;
    }

    return *this;
  }

  T_initial_method_call::
  ~T_initial_method_call ()
  {
  }

  // T_instantiation_expression
  //

  T_instantiation_expression::
  T_instantiation_expression ()
  : ::xml_schema::Type (),
    body_text_ (this),
    body_expression_ (this),
    parameter_name_ (this)
  {
  }

  T_instantiation_expression::
  T_instantiation_expression (const Body_expressionType& body_expression,
                              const Parameter_nameType& parameter_name)
  : ::xml_schema::Type (),
    body_text_ (this),
    body_expression_ (body_expression, this),
    parameter_name_ (parameter_name, this)
  {
  }

  T_instantiation_expression::
  T_instantiation_expression (::std::unique_ptr< Body_expressionType > body_expression,
                              const Parameter_nameType& parameter_name)
  : ::xml_schema::Type (),
    body_text_ (this),
    body_expression_ (std::move (body_expression), this),
    parameter_name_ (parameter_name, this)
  {
  }

  T_instantiation_expression::
  T_instantiation_expression (const T_instantiation_expression& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    body_text_ (x.body_text_, f, this),
    body_expression_ (x.body_expression_, f, this),
    parameter_name_ (x.parameter_name_, f, this)
  {
  }

  T_instantiation_expression::
  T_instantiation_expression (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    body_text_ (this),
    body_expression_ (this),
    parameter_name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_instantiation_expression::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // body_text
      //
      if (n.name () == "body_text" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Body_textType > r (
          Body_textTraits::create (i, f, this));

        if (!this->body_text_)
        {
          this->body_text_.set (::std::move (r));
          continue;
        }
      }

      // body_expression
      //
      if (n.name () == "body_expression" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Body_expressionType > r (
          Body_expressionTraits::create (i, f, this));

        if (!body_expression_.present ())
        {
          this->body_expression_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!body_expression_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "body_expression",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "parameter_name" && n.namespace_ ().empty ())
      {
        this->parameter_name_.set (Parameter_nameTraits::create (i, f, this));
        continue;
      }
    }

    if (!parameter_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "parameter_name",
        "");
    }
  }

  T_instantiation_expression* T_instantiation_expression::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_instantiation_expression (*this, f, c);
  }

  T_instantiation_expression& T_instantiation_expression::
  operator= (const T_instantiation_expression& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->body_text_ = x.body_text_;
      this->body_expression_ = x.body_expression_;
      this->parameter_name_ = x.parameter_name_;
    }

    return *this;
  }

  T_instantiation_expression::
  ~T_instantiation_expression ()
  {
  }

  // T_interface
  //

  T_interface::
  T_interface ()
  : ::xml_schema::Type (),
    port_ (this)
  {
  }

  T_interface::
  T_interface (const T_interface& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    port_ (x.port_, f, this)
  {
  }

  T_interface::
  T_interface (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    port_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_interface::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // port
      //
      if (n.name () == "port" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< PortType > r (
          PortTraits::create (i, f, this));

        this->port_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_interface* T_interface::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_interface (*this, f, c);
  }

  T_interface& T_interface::
  operator= (const T_interface& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->port_ = x.port_;
    }

    return *this;
  }

  T_interface::
  ~T_interface ()
  {
  }

  // T_port
  //

  T_port::
  T_port ()
  : ::xml_schema::Type (),
    message_ (this),
    annotation_ (this),
    name_ (this)
  {
  }

  T_port::
  T_port (const T_port& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    message_ (x.message_, f, this),
    annotation_ (x.annotation_, f, this),
    name_ (x.name_, f, this)
  {
  }

  T_port::
  T_port (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    message_ (this),
    annotation_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_port::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // message
      //
      if (n.name () == "message" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< MessageType > r (
          MessageTraits::create (i, f, this));

        this->message_.push_back (::std::move (r));
        continue;
      }

      // annotation
      //
      if (n.name () == "annotation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->annotation_)
        {
          this->annotation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_port* T_port::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_port (*this, f, c);
  }

  T_port& T_port::
  operator= (const T_port& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->message_ = x.message_;
      this->annotation_ = x.annotation_;
      this->name_ = x.name_;
    }

    return *this;
  }

  T_port::
  ~T_port ()
  {
  }

  // T_message
  //

  T_message::
  T_message ()
  : ::xml_schema::Type (),
    argument_ (this),
    type_ (this),
    name_ (this)
  {
  }

  T_message::
  T_message (const T_message& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    argument_ (x.argument_, f, this),
    type_ (x.type_, f, this),
    name_ (x.name_, f, this)
  {
  }

  T_message::
  T_message (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    argument_ (this),
    type_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_message::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ArgumentType > r (
          ArgumentTraits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_message* T_message::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_message (*this, f, c);
  }

  T_message& T_message::
  operator= (const T_message& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->argument_ = x.argument_;
      this->type_ = x.type_;
      this->name_ = x.name_;
    }

    return *this;
  }

  T_message::
  ~T_message ()
  {
  }

  // T_cluster_interface
  //

  T_cluster_interface::
  T_cluster_interface ()
  : ::xml_schema::Type (),
    port_ (this)
  {
  }

  T_cluster_interface::
  T_cluster_interface (const T_cluster_interface& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    port_ (x.port_, f, this)
  {
  }

  T_cluster_interface::
  T_cluster_interface (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    port_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_cluster_interface::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // port
      //
      if (n.name () == "port" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< PortType > r (
          PortTraits::create (i, f, this));

        this->port_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_cluster_interface* T_cluster_interface::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_cluster_interface (*this, f, c);
  }

  T_cluster_interface& T_cluster_interface::
  operator= (const T_cluster_interface& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->port_ = x.port_;
    }

    return *this;
  }

  T_cluster_interface::
  ~T_cluster_interface ()
  {
  }

  // T_instance_type
  //

  T_instance_type::
  T_instance_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_instance_type_convert ();
  }

  T_instance_type::
  T_instance_type (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_instance_type_convert ();
  }

  T_instance_type::
  T_instance_type (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_instance_type_convert ();
  }

  T_instance_type* T_instance_type::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_instance_type (*this, f, c);
  }

  T_instance_type::Value T_instance_type::
  _xsd_T_instance_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_instance_type_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_instance_type_indexes_,
                      _xsd_T_instance_type_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_T_instance_type_indexes_ + 2 || _xsd_T_instance_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_instance_type::
  _xsd_T_instance_type_literals_[2] =
  {
    "process",
    "cluster"
  };

  const T_instance_type::Value T_instance_type::
  _xsd_T_instance_type_indexes_[2] =
  {
    ::poosl::T_instance_type::cluster,
    ::poosl::T_instance_type::process
  };

  // T_annotation
  //

  T_annotation::
  T_annotation ()
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ())
  {
  }

  T_annotation::
  T_annotation (const T_annotation& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (x.any_, this->getDomDocument ())
  {
  }

  T_annotation::
  T_annotation (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ())
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_annotation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any
      //
      if (true)
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }
  }

  T_annotation* T_annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_annotation (*this, f, c);
  }

  T_annotation& T_annotation::
  operator= (const T_annotation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->any_ = x.any_;
    }

    return *this;
  }

  T_annotation::
  ~T_annotation ()
  {
  }

  // T_top_level_annotation
  //

  T_top_level_annotation::
  T_top_level_annotation ()
  : ::poosl::T_annotation ()
  {
  }

  T_top_level_annotation::
  T_top_level_annotation (const T_top_level_annotation& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::poosl::T_annotation (x, f, c)
  {
  }

  T_top_level_annotation::
  T_top_level_annotation (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::poosl::T_annotation (e, f, c)
  {
  }

  T_top_level_annotation* T_top_level_annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_top_level_annotation (*this, f, c);
  }

  T_top_level_annotation::
  ~T_top_level_annotation ()
  {
  }

  // T_data_class_annotation
  //

  T_data_class_annotation::
  T_data_class_annotation ()
  : ::poosl::T_annotation ()
  {
  }

  T_data_class_annotation::
  T_data_class_annotation (const T_data_class_annotation& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::poosl::T_annotation (x, f, c)
  {
  }

  T_data_class_annotation::
  T_data_class_annotation (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::poosl::T_annotation (e, f, c)
  {
  }

  T_data_class_annotation* T_data_class_annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_data_class_annotation (*this, f, c);
  }

  T_data_class_annotation::
  ~T_data_class_annotation ()
  {
  }

  // T_process_class_annotation
  //

  T_process_class_annotation::
  T_process_class_annotation ()
  : ::poosl::T_annotation ()
  {
  }

  T_process_class_annotation::
  T_process_class_annotation (const T_process_class_annotation& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::poosl::T_annotation (x, f, c)
  {
  }

  T_process_class_annotation::
  T_process_class_annotation (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::poosl::T_annotation (e, f, c)
  {
  }

  T_process_class_annotation* T_process_class_annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_process_class_annotation (*this, f, c);
  }

  T_process_class_annotation::
  ~T_process_class_annotation ()
  {
  }

  // T_cluster_class_annotation
  //

  T_cluster_class_annotation::
  T_cluster_class_annotation ()
  : ::poosl::T_annotation ()
  {
  }

  T_cluster_class_annotation::
  T_cluster_class_annotation (const T_cluster_class_annotation& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::poosl::T_annotation (x, f, c)
  {
  }

  T_cluster_class_annotation::
  T_cluster_class_annotation (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::poosl::T_annotation (e, f, c)
  {
  }

  T_cluster_class_annotation* T_cluster_class_annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_cluster_class_annotation (*this, f, c);
  }

  T_cluster_class_annotation::
  ~T_cluster_class_annotation ()
  {
  }

  // T_channel_annotation
  //

  T_channel_annotation::
  T_channel_annotation ()
  : ::poosl::T_annotation ()
  {
  }

  T_channel_annotation::
  T_channel_annotation (const T_channel_annotation& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::poosl::T_annotation (x, f, c)
  {
  }

  T_channel_annotation::
  T_channel_annotation (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::poosl::T_annotation (e, f, c)
  {
  }

  T_channel_annotation* T_channel_annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_channel_annotation (*this, f, c);
  }

  T_channel_annotation::
  ~T_channel_annotation ()
  {
  }

  // T_instance_annotation
  //

  T_instance_annotation::
  T_instance_annotation ()
  : ::poosl::T_annotation ()
  {
  }

  T_instance_annotation::
  T_instance_annotation (const T_instance_annotation& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::poosl::T_annotation (x, f, c)
  {
  }

  T_instance_annotation::
  T_instance_annotation (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::poosl::T_annotation (e, f, c)
  {
  }

  T_instance_annotation* T_instance_annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_instance_annotation (*this, f, c);
  }

  T_instance_annotation::
  ~T_instance_annotation ()
  {
  }

  // T_port_annotation
  //

  T_port_annotation::
  T_port_annotation ()
  : ::poosl::T_annotation ()
  {
  }

  T_port_annotation::
  T_port_annotation (const T_port_annotation& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::poosl::T_annotation (x, f, c)
  {
  }

  T_port_annotation::
  T_port_annotation (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::poosl::T_annotation (e, f, c)
  {
  }

  T_port_annotation* T_port_annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_port_annotation (*this, f, c);
  }

  T_port_annotation::
  ~T_port_annotation ()
  {
  }

  // T_connection_annotation
  //

  T_connection_annotation::
  T_connection_annotation ()
  : ::poosl::T_annotation ()
  {
  }

  T_connection_annotation::
  T_connection_annotation (const T_connection_annotation& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::poosl::T_annotation (x, f, c)
  {
  }

  T_connection_annotation::
  T_connection_annotation (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::poosl::T_annotation (e, f, c)
  {
  }

  T_connection_annotation* T_connection_annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_connection_annotation (*this, f, c);
  }

  T_connection_annotation::
  ~T_connection_annotation ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace poosl
{
  ::std::ostream&
  operator<< (::std::ostream& o, const T_poosl_specification& i)
  {
    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    o << ::std::endl << "data_classes: " << i.getData_classes ();
    if (i.getProcess_classes ())
    {
      o << ::std::endl << "process_classes: " << *i.getProcess_classes ();
    }

    if (i.getCluster_classes ())
    {
      o << ::std::endl << "cluster_classes: " << *i.getCluster_classes ();
    }

    if (i.getTop_level_specification ())
    {
      o << ::std::endl << "top_level_specification: " << *i.getTop_level_specification ();
    }

    if (i.getDescription ())
    {
      o << ::std::endl << "description: " << *i.getDescription ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_cluster_classes& i)
  {
    for (T_cluster_classes::Cluster_classConstIterator
         b (i.getCluster_class ().begin ()), e (i.getCluster_class ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "cluster_class: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_process_classes& i)
  {
    for (T_process_classes::Process_classConstIterator
         b (i.getProcess_class ().begin ()), e (i.getProcess_class ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "process_class: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_data_classes& i)
  {
    for (T_data_classes::Data_classConstIterator
         b (i.getData_class ().begin ()), e (i.getData_class ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "data_class: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_data_class& i)
  {
    if (i.getSuper_class ())
    {
      o << ::std::endl << "super_class: " << *i.getSuper_class ();
    }

    for (T_data_class::Instance_variableConstIterator
         b (i.getInstance_variable ().begin ()), e (i.getInstance_variable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instance_variable: " << *b;
    }

    for (T_data_class::Data_methodConstIterator
         b (i.getData_method ().begin ()), e (i.getData_method ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "data_method: " << *b;
    }

    if (i.getAnnotation ())
    {
      o << ::std::endl << "annotation: " << *i.getAnnotation ();
    }

    o << ::std::endl << "name: " << i.getName ();
    if (i.getNative ())
    {
      o << ::std::endl << "native: " << *i.getNative ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_data_method& i)
  {
    o << ::std::endl << "return_type: " << i.getReturn_type ();
    for (T_data_method::ArgumentConstIterator
         b (i.getArgument ().begin ()), e (i.getArgument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    for (T_data_method::Local_variableConstIterator
         b (i.getLocal_variable ().begin ()), e (i.getLocal_variable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "local_variable: " << *b;
    }

    if (i.getBody_text ())
    {
      o << ::std::endl << "body_text: " << *i.getBody_text ();
    }

    if (i.getBody_expression ())
    {
      o << ::std::endl << "body_expression: " << *i.getBody_expression ();
    }

    o << ::std::endl << "name: " << i.getName ();
    if (i.getNative ())
    {
      o << ::std::endl << "native: " << *i.getNative ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_process_class& i)
  {
    o << ::std::endl << "interface: " << i.getInterface ();
    if (i.getSuper_class ())
    {
      o << ::std::endl << "super_class: " << *i.getSuper_class ();
    }

    for (T_process_class::Instantiation_parameterConstIterator
         b (i.getInstantiation_parameter ().begin ()), e (i.getInstantiation_parameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instantiation_parameter: " << *b;
    }

    for (T_process_class::Instance_variableConstIterator
         b (i.getInstance_variable ().begin ()), e (i.getInstance_variable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instance_variable: " << *b;
    }

    o << ::std::endl << "initial_method_call: " << i.getInitial_method_call ();
    for (T_process_class::Process_methodConstIterator
         b (i.getProcess_method ().begin ()), e (i.getProcess_method ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "process_method: " << *b;
    }

    if (i.getAnnotation ())
    {
      o << ::std::endl << "annotation: " << *i.getAnnotation ();
    }

    o << ::std::endl << "name: " << i.getName ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_process_method& i)
  {
    for (T_process_method::ArgumentConstIterator
         b (i.getArgument ().begin ()), e (i.getArgument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    for (T_process_method::Output_parameterConstIterator
         b (i.getOutput_parameter ().begin ()), e (i.getOutput_parameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "output_parameter: " << *b;
    }

    for (T_process_method::Local_variableConstIterator
         b (i.getLocal_variable ().begin ()), e (i.getLocal_variable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "local_variable: " << *b;
    }

    if (i.getBody_text ())
    {
      o << ::std::endl << "body_text: " << *i.getBody_text ();
    }

    o << ::std::endl << "body_statement: " << i.getBody_statement ();
    o << ::std::endl << "name: " << i.getName ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_cluster_class& i)
  {
    o << ::std::endl << "interface: " << i.getInterface ();
    for (T_cluster_class::Instantiation_parameterConstIterator
         b (i.getInstantiation_parameter ().begin ()), e (i.getInstantiation_parameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instantiation_parameter: " << *b;
    }

    for (T_cluster_class::ChannelConstIterator
         b (i.getChannel ().begin ()), e (i.getChannel ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channel: " << *b;
    }

    for (T_cluster_class::InstanceConstIterator
         b (i.getInstance ().begin ()), e (i.getInstance ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instance: " << *b;
    }

    if (i.getAnnotation ())
    {
      o << ::std::endl << "annotation: " << *i.getAnnotation ();
    }

    o << ::std::endl << "name: " << i.getName ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_top_level_specification& i)
  {
    for (T_top_level_specification::InstanceConstIterator
         b (i.getInstance ().begin ()), e (i.getInstance ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instance: " << *b;
    }

    for (T_top_level_specification::ChannelConstIterator
         b (i.getChannel ().begin ()), e (i.getChannel ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channel: " << *b;
    }

    if (i.getAnnotation ())
    {
      o << ::std::endl << "annotation: " << *i.getAnnotation ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_channel_internal& i)
  {
    if (i.getAnnotation ())
    {
      o << ::std::endl << "annotation: " << *i.getAnnotation ();
    }

    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_channel& i)
  {
    o << static_cast< const ::poosl::T_channel_internal& > (i);

    if (i.getOutput_port ())
    {
      o << ::std::endl << "output_port: " << *i.getOutput_port ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_instance& i)
  {
    for (T_instance::Instantiation_expressionConstIterator
         b (i.getInstantiation_expression ().begin ()), e (i.getInstantiation_expression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instantiation_expression: " << *b;
    }

    for (T_instance::ConnectionConstIterator
         b (i.getConnection ().begin ()), e (i.getConnection ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "connection: " << *b;
    }

    if (i.getAnnotation ())
    {
      o << ::std::endl << "annotation: " << *i.getAnnotation ();
    }

    if (i.getType ())
    {
      o << ::std::endl << "type: " << *i.getType ();
    }

    if (i.getClass ())
    {
      o << ::std::endl << "class: " << *i.getClass ();
    }

    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_connection& i)
  {
    if (i.getAnnotation ())
    {
      o << ::std::endl << "annotation: " << *i.getAnnotation ();
    }

    o << ::std::endl << "port: " << i.getPort ();
    o << ::std::endl << "channel: " << i.getChannel ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_initial_method_call& i)
  {
    if (i.getMethod_call_text ())
    {
      o << ::std::endl << "method_call_text: " << *i.getMethod_call_text ();
    }

    o << ::std::endl << "process_method_call: " << i.getProcess_method_call ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_instantiation_expression& i)
  {
    if (i.getBody_text ())
    {
      o << ::std::endl << "body_text: " << *i.getBody_text ();
    }

    o << ::std::endl << "body_expression: " << i.getBody_expression ();
    o << ::std::endl << "parameter_name: " << i.getParameter_name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_interface& i)
  {
    for (T_interface::PortConstIterator
         b (i.getPort ().begin ()), e (i.getPort ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "port: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_port& i)
  {
    for (T_port::MessageConstIterator
         b (i.getMessage ().begin ()), e (i.getMessage ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "message: " << *b;
    }

    if (i.getAnnotation ())
    {
      o << ::std::endl << "annotation: " << *i.getAnnotation ();
    }

    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_message& i)
  {
    for (T_message::ArgumentConstIterator
         b (i.getArgument ().begin ()), e (i.getArgument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    if (i.getType ())
    {
      o << ::std::endl << "type: " << *i.getType ();
    }

    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_cluster_interface& i)
  {
    for (T_cluster_interface::PortConstIterator
         b (i.getPort ().begin ()), e (i.getPort ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "port: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_instance_type::Value i)
  {
    return o << T_instance_type::_xsd_T_instance_type_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_instance_type& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_annotation&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_top_level_annotation& i)
  {
    o << static_cast< const ::poosl::T_annotation& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_data_class_annotation& i)
  {
    o << static_cast< const ::poosl::T_annotation& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_process_class_annotation& i)
  {
    o << static_cast< const ::poosl::T_annotation& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_cluster_class_annotation& i)
  {
    o << static_cast< const ::poosl::T_annotation& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_channel_annotation& i)
  {
    o << static_cast< const ::poosl::T_annotation& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_instance_annotation& i)
  {
    o << static_cast< const ::poosl::T_annotation& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_port_annotation& i)
  {
    o << static_cast< const ::poosl::T_annotation& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_connection_annotation& i)
  {
    o << static_cast< const ::poosl::T_annotation& > (i);

    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace poosl
{
  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (const ::std::string& u,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::poosl::T_poosl_specification > (
      ::poosl::parsePoosl_specification (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (const ::std::string& u,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::poosl::T_poosl_specification > (
      ::poosl::parsePoosl_specification (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::poosl::T_poosl_specification > (
      ::poosl::parsePoosl_specification (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::poosl::parsePoosl_specification (isrc, f, p);
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::poosl::parsePoosl_specification (isrc, h, f, p);
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::poosl::parsePoosl_specification (isrc, h, f, p);
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::poosl::parsePoosl_specification (isrc, f, p);
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::poosl::parsePoosl_specification (isrc, h, f, p);
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::poosl::parsePoosl_specification (isrc, h, f, p);
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::xercesc::InputSource& i,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::poosl::T_poosl_specification > (
      ::poosl::parsePoosl_specification (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::xercesc::InputSource& i,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::poosl::T_poosl_specification > (
      ::poosl::parsePoosl_specification (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::poosl::T_poosl_specification > (
      ::poosl::parsePoosl_specification (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (const ::xercesc::DOMDocument& doc,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::poosl::T_poosl_specification > (
        ::poosl::parsePoosl_specification (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "poosl_specification" &&
        n.namespace_ () == "uri:poosl")
    {
      ::std::unique_ptr< ::poosl::T_poosl_specification > r (
        ::xsd::cxx::tree::traits< ::poosl::T_poosl_specification, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "poosl_specification",
      "uri:poosl");
  }

  ::std::unique_ptr< ::poosl::T_poosl_specification >
  parsePoosl_specification (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "poosl_specification" &&
        n.namespace_ () == "uri:poosl")
    {
      ::std::unique_ptr< ::poosl::T_poosl_specification > r (
        ::xsd::cxx::tree::traits< ::poosl::T_poosl_specification, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "poosl_specification",
      "uri:poosl");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace poosl
{
  void
  serializePoosl_specification (::std::ostream& o,
                                const ::poosl::T_poosl_specification& s,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializePoosl_specification (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializePoosl_specification (::std::ostream& o,
                                const ::poosl::T_poosl_specification& s,
                                ::xml_schema::ErrorHandler& h,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializePoosl_specification (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializePoosl_specification (::std::ostream& o,
                                const ::poosl::T_poosl_specification& s,
                                ::xercesc::DOMErrorHandler& h,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializePoosl_specification (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializePoosl_specification (::xercesc::XMLFormatTarget& t,
                                const ::poosl::T_poosl_specification& s,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializePoosl_specification (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializePoosl_specification (::xercesc::XMLFormatTarget& t,
                                const ::poosl::T_poosl_specification& s,
                                ::xml_schema::ErrorHandler& h,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializePoosl_specification (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializePoosl_specification (::xercesc::XMLFormatTarget& t,
                                const ::poosl::T_poosl_specification& s,
                                ::xercesc::DOMErrorHandler& h,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializePoosl_specification (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializePoosl_specification (::xercesc::DOMDocument& d,
                                const ::poosl::T_poosl_specification& s,
                                ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "poosl_specification" &&
        n.namespace_ () == "uri:poosl")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "poosl_specification",
        "uri:poosl");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializePoosl_specification (const ::poosl::T_poosl_specification& s,
                                const ::xml_schema::NamespaceInfomap& m,
                                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "poosl_specification",
        "uri:poosl",
        m, f));

    ::poosl::serializePoosl_specification (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_poosl_specification& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << *i.getName ();
    }

    // data_classes
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data_classes",
          "uri:poosl",
          e));

      s << i.getData_classes ();
    }

    // process_classes
    //
    if (i.getProcess_classes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_classes",
          "uri:poosl",
          e));

      s << *i.getProcess_classes ();
    }

    // cluster_classes
    //
    if (i.getCluster_classes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cluster_classes",
          "uri:poosl",
          e));

      s << *i.getCluster_classes ();
    }

    // top_level_specification
    //
    if (i.getTop_level_specification ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "top_level_specification",
          "uri:poosl",
          e));

      s << *i.getTop_level_specification ();
    }

    // description
    //
    if (i.getDescription ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "description",
          "uri:poosl",
          e));

      s << *i.getDescription ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_cluster_classes& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // cluster_class
    //
    for (T_cluster_classes::Cluster_classConstIterator
         b (i.getCluster_class ().begin ()), n (i.getCluster_class ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cluster_class",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_process_classes& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // process_class
    //
    for (T_process_classes::Process_classConstIterator
         b (i.getProcess_class ().begin ()), n (i.getProcess_class ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_class",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_data_classes& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // data_class
    //
    for (T_data_classes::Data_classConstIterator
         b (i.getData_class ().begin ()), n (i.getData_class ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data_class",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_data_class& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // super_class
    //
    if (i.getSuper_class ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "super_class",
          "uri:poosl",
          e));

      s << *i.getSuper_class ();
    }

    // instance_variable
    //
    for (T_data_class::Instance_variableConstIterator
         b (i.getInstance_variable ().begin ()), n (i.getInstance_variable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance_variable",
          "uri:poosl",
          e));

      s << *b;
    }

    // data_method
    //
    for (T_data_class::Data_methodConstIterator
         b (i.getData_method ().begin ()), n (i.getData_method ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data_method",
          "uri:poosl",
          e));

      s << *b;
    }

    // annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "annotation",
          "uri:poosl",
          e));

      s << *i.getAnnotation ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.getName ();
    }

    // native
    //
    if (i.getNative ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "native",
          e));

      a << *i.getNative ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_data_method& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // return_type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "return_type",
          "uri:poosl",
          e));

      s << i.getReturn_type ();
    }

    // argument
    //
    for (T_data_method::ArgumentConstIterator
         b (i.getArgument ().begin ()), n (i.getArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "uri:poosl",
          e));

      s << *b;
    }

    // local_variable
    //
    for (T_data_method::Local_variableConstIterator
         b (i.getLocal_variable ().begin ()), n (i.getLocal_variable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "local_variable",
          "uri:poosl",
          e));

      s << *b;
    }

    // body_text
    //
    if (i.getBody_text ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body_text",
          "uri:poosl",
          e));

      s << *i.getBody_text ();
    }

    // body_expression
    //
    if (i.getBody_expression ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body_expression",
          "uri:poosl",
          e));

      s << *i.getBody_expression ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.getName ();
    }

    // native
    //
    if (i.getNative ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "native",
          e));

      a << *i.getNative ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_process_class& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // interface
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interface",
          "uri:poosl",
          e));

      s << i.getInterface ();
    }

    // super_class
    //
    if (i.getSuper_class ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "super_class",
          "uri:poosl",
          e));

      s << *i.getSuper_class ();
    }

    // instantiation_parameter
    //
    for (T_process_class::Instantiation_parameterConstIterator
         b (i.getInstantiation_parameter ().begin ()), n (i.getInstantiation_parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instantiation_parameter",
          "uri:poosl",
          e));

      s << *b;
    }

    // instance_variable
    //
    for (T_process_class::Instance_variableConstIterator
         b (i.getInstance_variable ().begin ()), n (i.getInstance_variable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance_variable",
          "uri:poosl",
          e));

      s << *b;
    }

    // initial_method_call
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "initial_method_call",
          "uri:poosl",
          e));

      s << i.getInitial_method_call ();
    }

    // process_method
    //
    for (T_process_class::Process_methodConstIterator
         b (i.getProcess_method ().begin ()), n (i.getProcess_method ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_method",
          "uri:poosl",
          e));

      s << *b;
    }

    // annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "annotation",
          "uri:poosl",
          e));

      s << *i.getAnnotation ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_process_method& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // argument
    //
    for (T_process_method::ArgumentConstIterator
         b (i.getArgument ().begin ()), n (i.getArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "uri:poosl",
          e));

      s << *b;
    }

    // output_parameter
    //
    for (T_process_method::Output_parameterConstIterator
         b (i.getOutput_parameter ().begin ()), n (i.getOutput_parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output_parameter",
          "uri:poosl",
          e));

      s << *b;
    }

    // local_variable
    //
    for (T_process_method::Local_variableConstIterator
         b (i.getLocal_variable ().begin ()), n (i.getLocal_variable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "local_variable",
          "uri:poosl",
          e));

      s << *b;
    }

    // body_text
    //
    if (i.getBody_text ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body_text",
          "uri:poosl",
          e));

      s << *i.getBody_text ();
    }

    // body_statement
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body_statement",
          "uri:poosl",
          e));

      s << i.getBody_statement ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_cluster_class& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // interface
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interface",
          "uri:poosl",
          e));

      s << i.getInterface ();
    }

    // instantiation_parameter
    //
    for (T_cluster_class::Instantiation_parameterConstIterator
         b (i.getInstantiation_parameter ().begin ()), n (i.getInstantiation_parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instantiation_parameter",
          "uri:poosl",
          e));

      s << *b;
    }

    // channel
    //
    for (T_cluster_class::ChannelConstIterator
         b (i.getChannel ().begin ()), n (i.getChannel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channel",
          "uri:poosl",
          e));

      s << *b;
    }

    // instance
    //
    for (T_cluster_class::InstanceConstIterator
         b (i.getInstance ().begin ()), n (i.getInstance ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance",
          "uri:poosl",
          e));

      s << *b;
    }

    // annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "annotation",
          "uri:poosl",
          e));

      s << *i.getAnnotation ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_top_level_specification& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // instance
    //
    for (T_top_level_specification::InstanceConstIterator
         b (i.getInstance ().begin ()), n (i.getInstance ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance",
          "uri:poosl",
          e));

      s << *b;
    }

    // channel
    //
    for (T_top_level_specification::ChannelConstIterator
         b (i.getChannel ().begin ()), n (i.getChannel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channel",
          "uri:poosl",
          e));

      s << *b;
    }

    // annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "annotation",
          "uri:poosl",
          e));

      s << *i.getAnnotation ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_channel_internal& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "annotation",
          "uri:poosl",
          e));

      s << *i.getAnnotation ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_channel& i)
  {
    e << static_cast< const ::poosl::T_channel_internal& > (i);

    // output_port
    //
    if (i.getOutput_port ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "output_port",
          e));

      a << *i.getOutput_port ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_instance& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // instantiation_expression
    //
    for (T_instance::Instantiation_expressionConstIterator
         b (i.getInstantiation_expression ().begin ()), n (i.getInstantiation_expression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instantiation_expression",
          "uri:poosl",
          e));

      s << *b;
    }

    // connection
    //
    for (T_instance::ConnectionConstIterator
         b (i.getConnection ().begin ()), n (i.getConnection ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "connection",
          "uri:poosl",
          e));

      s << *b;
    }

    // annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "annotation",
          "uri:poosl",
          e));

      s << *i.getAnnotation ();
    }

    // type
    //
    if (i.getType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.getType ();
    }

    // class
    //
    if (i.getClass ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "class",
          e));

      a << *i.getClass ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_connection& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "annotation",
          "uri:poosl",
          e));

      s << *i.getAnnotation ();
    }

    // port
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "port",
          e));

      a << i.getPort ();
    }

    // channel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "channel",
          e));

      a << i.getChannel ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_initial_method_call& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // method_call_text
    //
    if (i.getMethod_call_text ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "method_call_text",
          "uri:poosl",
          e));

      s << *i.getMethod_call_text ();
    }

    // process_method_call
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_method_call",
          "uri:poosl",
          e));

      s << i.getProcess_method_call ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_instantiation_expression& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // body_text
    //
    if (i.getBody_text ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body_text",
          "uri:poosl",
          e));

      s << *i.getBody_text ();
    }

    // body_expression
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body_expression",
          "uri:poosl",
          e));

      s << i.getBody_expression ();
    }

    // parameter_name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "parameter_name",
          e));

      a << i.getParameter_name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_interface& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // port
    //
    for (T_interface::PortConstIterator
         b (i.getPort ().begin ()), n (i.getPort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "port",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_port& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // message
    //
    for (T_port::MessageConstIterator
         b (i.getMessage ().begin ()), n (i.getMessage ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "message",
          "uri:poosl",
          e));

      s << *b;
    }

    // annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "annotation",
          "uri:poosl",
          e));

      s << *i.getAnnotation ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_message& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // argument
    //
    for (T_message::ArgumentConstIterator
         b (i.getArgument ().begin ()), n (i.getArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "uri:poosl",
          e));

      s << *b;
    }

    // type
    //
    if (i.getType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.getType ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_cluster_interface& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // port
    //
    for (T_cluster_interface::PortConstIterator
         b (i.getPort ().begin ()), n (i.getPort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "port",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_instance_type& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_instance_type& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_instance_type& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_annotation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // any
    //
    for (T_annotation::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_top_level_annotation& i)
  {
    e << static_cast< const ::poosl::T_annotation& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_data_class_annotation& i)
  {
    e << static_cast< const ::poosl::T_annotation& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_process_class_annotation& i)
  {
    e << static_cast< const ::poosl::T_annotation& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_cluster_class_annotation& i)
  {
    e << static_cast< const ::poosl::T_annotation& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_channel_annotation& i)
  {
    e << static_cast< const ::poosl::T_annotation& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_instance_annotation& i)
  {
    e << static_cast< const ::poosl::T_annotation& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_port_annotation& i)
  {
    e << static_cast< const ::poosl::T_annotation& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_connection_annotation& i)
  {
    e << static_cast< const ::poosl::T_annotation& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

