// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "pooslstatements.hxx"

namespace poosl
{
  // T_constant_type
  // 

  T_constant_type::
  T_constant_type ()
  : ::xml_schema::String ()
  {
  }

  T_constant_type::
  T_constant_type (Value v)
  : ::xml_schema::String (_xsd_T_constant_type_literals_[v])
  {
  }

  T_constant_type::
  T_constant_type (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_constant_type::
  T_constant_type (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_constant_type::
  T_constant_type (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_constant_type::
  T_constant_type (const T_constant_type& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_constant_type& T_constant_type::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_constant_type_literals_[v]);

    return *this;
  }


  // T_binary_operator
  // 

  T_binary_operator::
  T_binary_operator ()
  : ::xml_schema::String ()
  {
  }

  T_binary_operator::
  T_binary_operator (Value v)
  : ::xml_schema::String (_xsd_T_binary_operator_literals_[v])
  {
  }

  T_binary_operator::
  T_binary_operator (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_binary_operator::
  T_binary_operator (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_binary_operator::
  T_binary_operator (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_binary_operator::
  T_binary_operator (const T_binary_operator& v,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_binary_operator& T_binary_operator::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_binary_operator_literals_[v]);

    return *this;
  }


  // T_unary_operator
  // 

  T_unary_operator::
  T_unary_operator ()
  : ::xml_schema::String ()
  {
  }

  T_unary_operator::
  T_unary_operator (Value v)
  : ::xml_schema::String (_xsd_T_unary_operator_literals_[v])
  {
  }

  T_unary_operator::
  T_unary_operator (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_unary_operator::
  T_unary_operator (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_unary_operator::
  T_unary_operator (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_unary_operator::
  T_unary_operator (const T_unary_operator& v,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_unary_operator& T_unary_operator::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_unary_operator_literals_[v]);

    return *this;
  }


  // T_expressions
  // 

  const T_expressions::Sequence_of_expressionsSequence& T_expressions::
  getSequence_of_expressions () const
  {
    return this->sequence_of_expressions_;
  }

  T_expressions::Sequence_of_expressionsSequence& T_expressions::
  getSequence_of_expressions ()
  {
    return this->sequence_of_expressions_;
  }

  void T_expressions::
  setSequence_of_expressions (const Sequence_of_expressionsSequence& s)
  {
    this->sequence_of_expressions_ = s;
  }

  const T_expressions::AssignmentSequence& T_expressions::
  getAssignment () const
  {
    return this->assignment_;
  }

  T_expressions::AssignmentSequence& T_expressions::
  getAssignment ()
  {
    return this->assignment_;
  }

  void T_expressions::
  setAssignment (const AssignmentSequence& s)
  {
    this->assignment_ = s;
  }

  const T_expressions::Data_method_callSequence& T_expressions::
  getData_method_call () const
  {
    return this->data_method_call_;
  }

  T_expressions::Data_method_callSequence& T_expressions::
  getData_method_call ()
  {
    return this->data_method_call_;
  }

  void T_expressions::
  setData_method_call (const Data_method_callSequence& s)
  {
    this->data_method_call_ = s;
  }

  const T_expressions::ConstantSequence& T_expressions::
  getConstant () const
  {
    return this->constant_;
  }

  T_expressions::ConstantSequence& T_expressions::
  getConstant ()
  {
    return this->constant_;
  }

  void T_expressions::
  setConstant (const ConstantSequence& s)
  {
    this->constant_ = s;
  }

  const T_expressions::VariableSequence& T_expressions::
  getVariable () const
  {
    return this->variable_;
  }

  T_expressions::VariableSequence& T_expressions::
  getVariable ()
  {
    return this->variable_;
  }

  void T_expressions::
  setVariable (const VariableSequence& s)
  {
    this->variable_ = s;
  }

  const T_expressions::Binary_operationSequence& T_expressions::
  getBinary_operation () const
  {
    return this->binary_operation_;
  }

  T_expressions::Binary_operationSequence& T_expressions::
  getBinary_operation ()
  {
    return this->binary_operation_;
  }

  void T_expressions::
  setBinary_operation (const Binary_operationSequence& s)
  {
    this->binary_operation_ = s;
  }

  const T_expressions::Unary_operationSequence& T_expressions::
  getUnary_operation () const
  {
    return this->unary_operation_;
  }

  T_expressions::Unary_operationSequence& T_expressions::
  getUnary_operation ()
  {
    return this->unary_operation_;
  }

  void T_expressions::
  setUnary_operation (const Unary_operationSequence& s)
  {
    this->unary_operation_ = s;
  }

  const T_expressions::SelfSequence& T_expressions::
  getSelf () const
  {
    return this->self_;
  }

  T_expressions::SelfSequence& T_expressions::
  getSelf ()
  {
    return this->self_;
  }

  void T_expressions::
  setSelf (const SelfSequence& s)
  {
    this->self_ = s;
  }

  const T_expressions::NilSequence& T_expressions::
  getNil () const
  {
    return this->nil_;
  }

  T_expressions::NilSequence& T_expressions::
  getNil ()
  {
    return this->nil_;
  }

  void T_expressions::
  setNil (const NilSequence& s)
  {
    this->nil_ = s;
  }

  const T_expressions::Current_timeSequence& T_expressions::
  getCurrent_time () const
  {
    return this->current_time_;
  }

  T_expressions::Current_timeSequence& T_expressions::
  getCurrent_time ()
  {
    return this->current_time_;
  }

  void T_expressions::
  setCurrent_time (const Current_timeSequence& s)
  {
    this->current_time_ = s;
  }

  const T_expressions::IfSequence& T_expressions::
  getIf () const
  {
    return this->if__;
  }

  T_expressions::IfSequence& T_expressions::
  getIf ()
  {
    return this->if__;
  }

  void T_expressions::
  setIf (const IfSequence& s)
  {
    this->if__ = s;
  }

  const T_expressions::WhileSequence& T_expressions::
  getWhile () const
  {
    return this->while__;
  }

  T_expressions::WhileSequence& T_expressions::
  getWhile ()
  {
    return this->while__;
  }

  void T_expressions::
  setWhile (const WhileSequence& s)
  {
    this->while__ = s;
  }

  const T_expressions::NewSequence& T_expressions::
  getNew () const
  {
    return this->new__;
  }

  T_expressions::NewSequence& T_expressions::
  getNew ()
  {
    return this->new__;
  }

  void T_expressions::
  setNew (const NewSequence& s)
  {
    this->new__ = s;
  }

  const T_expressions::ReturnSequence& T_expressions::
  getReturn () const
  {
    return this->return__;
  }

  T_expressions::ReturnSequence& T_expressions::
  getReturn ()
  {
    return this->return__;
  }

  void T_expressions::
  setReturn (const ReturnSequence& s)
  {
    this->return__ = s;
  }

  const T_expressions::Stmt_handleOptional& T_expressions::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_expressions::Stmt_handleOptional& T_expressions::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_expressions::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_expressions::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_expression
  // 


  // T_assignment
  // 

  const T_assignment::Variable_nameType& T_assignment::
  getVariable_name () const
  {
    return this->variable_name_.get ();
  }

  T_assignment::Variable_nameType& T_assignment::
  getVariable_name ()
  {
    return this->variable_name_.get ();
  }

  void T_assignment::
  setVariable_name (const Variable_nameType& x)
  {
    this->variable_name_.set (x);
  }

  void T_assignment::
  setVariable_name (::std::unique_ptr< Variable_nameType > x)
  {
    this->variable_name_.set (std::move (x));
  }


  // T_data_method_call
  // 

  const T_data_method_call::ReceiverType& T_data_method_call::
  getReceiver () const
  {
    return this->receiver_.get ();
  }

  T_data_method_call::ReceiverType& T_data_method_call::
  getReceiver ()
  {
    return this->receiver_.get ();
  }

  void T_data_method_call::
  setReceiver (const ReceiverType& x)
  {
    this->receiver_.set (x);
  }

  void T_data_method_call::
  setReceiver (::std::unique_ptr< ReceiverType > x)
  {
    this->receiver_.set (std::move (x));
  }

  const T_data_method_call::ArgumentSequence& T_data_method_call::
  getArgument () const
  {
    return this->argument_;
  }

  T_data_method_call::ArgumentSequence& T_data_method_call::
  getArgument ()
  {
    return this->argument_;
  }

  void T_data_method_call::
  setArgument (const ArgumentSequence& s)
  {
    this->argument_ = s;
  }

  const T_data_method_call::Method_nameType& T_data_method_call::
  getMethod_name () const
  {
    return this->method_name_.get ();
  }

  T_data_method_call::Method_nameType& T_data_method_call::
  getMethod_name ()
  {
    return this->method_name_.get ();
  }

  void T_data_method_call::
  setMethod_name (const Method_nameType& x)
  {
    this->method_name_.set (x);
  }

  void T_data_method_call::
  setMethod_name (::std::unique_ptr< Method_nameType > x)
  {
    this->method_name_.set (std::move (x));
  }

  const T_data_method_call::SuperType& T_data_method_call::
  getSuper () const
  {
    return this->super_.get ();
  }

  T_data_method_call::SuperType& T_data_method_call::
  getSuper ()
  {
    return this->super_.get ();
  }

  void T_data_method_call::
  setSuper (const SuperType& x)
  {
    this->super_.set (x);
  }

  void T_data_method_call::
  setSuper (::std::unique_ptr< SuperType > x)
  {
    this->super_.set (std::move (x));
  }

  const T_data_method_call::Stmt_handleOptional& T_data_method_call::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_data_method_call::Stmt_handleOptional& T_data_method_call::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_data_method_call::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_data_method_call::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_constant
  // 

  const T_constant::TypeOptional& T_constant::
  getType () const
  {
    return this->type_;
  }

  T_constant::TypeOptional& T_constant::
  getType ()
  {
    return this->type_;
  }

  void T_constant::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void T_constant::
  setType (const TypeOptional& x)
  {
    this->type_ = x;
  }

  void T_constant::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }


  // T_current_time
  // 


  // T_variable_ref
  // 

  const T_variable_ref::NameOptional& T_variable_ref::
  getName () const
  {
    return this->name_;
  }

  T_variable_ref::NameOptional& T_variable_ref::
  getName ()
  {
    return this->name_;
  }

  void T_variable_ref::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_variable_ref::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void T_variable_ref::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // T_binary_operation
  // 

  const T_binary_operation::Left_operandType& T_binary_operation::
  getLeft_operand () const
  {
    return this->left_operand_.get ();
  }

  T_binary_operation::Left_operandType& T_binary_operation::
  getLeft_operand ()
  {
    return this->left_operand_.get ();
  }

  void T_binary_operation::
  setLeft_operand (const Left_operandType& x)
  {
    this->left_operand_.set (x);
  }

  void T_binary_operation::
  setLeft_operand (::std::unique_ptr< Left_operandType > x)
  {
    this->left_operand_.set (std::move (x));
  }

  const T_binary_operation::Right_operandType& T_binary_operation::
  getRight_operand () const
  {
    return this->right_operand_.get ();
  }

  T_binary_operation::Right_operandType& T_binary_operation::
  getRight_operand ()
  {
    return this->right_operand_.get ();
  }

  void T_binary_operation::
  setRight_operand (const Right_operandType& x)
  {
    this->right_operand_.set (x);
  }

  void T_binary_operation::
  setRight_operand (::std::unique_ptr< Right_operandType > x)
  {
    this->right_operand_.set (std::move (x));
  }

  const T_binary_operation::OperatorOptional& T_binary_operation::
  getOperator () const
  {
    return this->operator__;
  }

  T_binary_operation::OperatorOptional& T_binary_operation::
  getOperator ()
  {
    return this->operator__;
  }

  void T_binary_operation::
  setOperator (const OperatorType& x)
  {
    this->operator__.set (x);
  }

  void T_binary_operation::
  setOperator (const OperatorOptional& x)
  {
    this->operator__ = x;
  }

  void T_binary_operation::
  setOperator (::std::unique_ptr< OperatorType > x)
  {
    this->operator__.set (std::move (x));
  }

  const T_binary_operation::Stmt_handleOptional& T_binary_operation::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_binary_operation::Stmt_handleOptional& T_binary_operation::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_binary_operation::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_binary_operation::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_unary_operation
  // 

  const T_unary_operation::OperandType& T_unary_operation::
  getOperand () const
  {
    return this->operand_.get ();
  }

  T_unary_operation::OperandType& T_unary_operation::
  getOperand ()
  {
    return this->operand_.get ();
  }

  void T_unary_operation::
  setOperand (const OperandType& x)
  {
    this->operand_.set (x);
  }

  void T_unary_operation::
  setOperand (::std::unique_ptr< OperandType > x)
  {
    this->operand_.set (std::move (x));
  }

  const T_unary_operation::OperatorOptional& T_unary_operation::
  getOperator () const
  {
    return this->operator__;
  }

  T_unary_operation::OperatorOptional& T_unary_operation::
  getOperator ()
  {
    return this->operator__;
  }

  void T_unary_operation::
  setOperator (const OperatorType& x)
  {
    this->operator__.set (x);
  }

  void T_unary_operation::
  setOperator (const OperatorOptional& x)
  {
    this->operator__ = x;
  }

  void T_unary_operation::
  setOperator (::std::unique_ptr< OperatorType > x)
  {
    this->operator__.set (std::move (x));
  }

  const T_unary_operation::Stmt_handleOptional& T_unary_operation::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_unary_operation::Stmt_handleOptional& T_unary_operation::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_unary_operation::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_unary_operation::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_if_expression
  // 

  const T_if_expression::ConditionType& T_if_expression::
  getCondition () const
  {
    return this->condition_.get ();
  }

  T_if_expression::ConditionType& T_if_expression::
  getCondition ()
  {
    return this->condition_.get ();
  }

  void T_if_expression::
  setCondition (const ConditionType& x)
  {
    this->condition_.set (x);
  }

  void T_if_expression::
  setCondition (::std::unique_ptr< ConditionType > x)
  {
    this->condition_.set (std::move (x));
  }

  const T_if_expression::ThenType& T_if_expression::
  getThen () const
  {
    return this->then_.get ();
  }

  T_if_expression::ThenType& T_if_expression::
  getThen ()
  {
    return this->then_.get ();
  }

  void T_if_expression::
  setThen (const ThenType& x)
  {
    this->then_.set (x);
  }

  void T_if_expression::
  setThen (::std::unique_ptr< ThenType > x)
  {
    this->then_.set (std::move (x));
  }

  const T_if_expression::ElseOptional& T_if_expression::
  getElse () const
  {
    return this->else__;
  }

  T_if_expression::ElseOptional& T_if_expression::
  getElse ()
  {
    return this->else__;
  }

  void T_if_expression::
  setElse (const ElseType& x)
  {
    this->else__.set (x);
  }

  void T_if_expression::
  setElse (const ElseOptional& x)
  {
    this->else__ = x;
  }

  void T_if_expression::
  setElse (::std::unique_ptr< ElseType > x)
  {
    this->else__.set (std::move (x));
  }


  // T_while_expression
  // 

  const T_while_expression::ConditionType& T_while_expression::
  getCondition () const
  {
    return this->condition_.get ();
  }

  T_while_expression::ConditionType& T_while_expression::
  getCondition ()
  {
    return this->condition_.get ();
  }

  void T_while_expression::
  setCondition (const ConditionType& x)
  {
    this->condition_.set (x);
  }

  void T_while_expression::
  setCondition (::std::unique_ptr< ConditionType > x)
  {
    this->condition_.set (std::move (x));
  }

  const T_while_expression::BodyType& T_while_expression::
  getBody () const
  {
    return this->body_.get ();
  }

  T_while_expression::BodyType& T_while_expression::
  getBody ()
  {
    return this->body_.get ();
  }

  void T_while_expression::
  setBody (const BodyType& x)
  {
    this->body_.set (x);
  }

  void T_while_expression::
  setBody (::std::unique_ptr< BodyType > x)
  {
    this->body_.set (std::move (x));
  }


  // T_object_creation
  // 

  const T_object_creation::Data_classOptional& T_object_creation::
  getData_class () const
  {
    return this->data_class_;
  }

  T_object_creation::Data_classOptional& T_object_creation::
  getData_class ()
  {
    return this->data_class_;
  }

  void T_object_creation::
  setData_class (const Data_classType& x)
  {
    this->data_class_.set (x);
  }

  void T_object_creation::
  setData_class (const Data_classOptional& x)
  {
    this->data_class_ = x;
  }

  void T_object_creation::
  setData_class (::std::unique_ptr< Data_classType > x)
  {
    this->data_class_.set (std::move (x));
  }


  // T_statements
  // 

  const T_statements::Sequence_of_statementsSequence& T_statements::
  getSequence_of_statements () const
  {
    return this->sequence_of_statements_;
  }

  T_statements::Sequence_of_statementsSequence& T_statements::
  getSequence_of_statements ()
  {
    return this->sequence_of_statements_;
  }

  void T_statements::
  setSequence_of_statements (const Sequence_of_statementsSequence& s)
  {
    this->sequence_of_statements_ = s;
  }

  const T_statements::Parallel_statementsSequence& T_statements::
  getParallel_statements () const
  {
    return this->parallel_statements_;
  }

  T_statements::Parallel_statementsSequence& T_statements::
  getParallel_statements ()
  {
    return this->parallel_statements_;
  }

  void T_statements::
  setParallel_statements (const Parallel_statementsSequence& s)
  {
    this->parallel_statements_ = s;
  }

  const T_statements::Select_statementsSequence& T_statements::
  getSelect_statements () const
  {
    return this->select_statements_;
  }

  T_statements::Select_statementsSequence& T_statements::
  getSelect_statements ()
  {
    return this->select_statements_;
  }

  void T_statements::
  setSelect_statements (const Select_statementsSequence& s)
  {
    this->select_statements_ = s;
  }

  const T_statements::ExpressionSequence& T_statements::
  getExpression () const
  {
    return this->expression_;
  }

  T_statements::ExpressionSequence& T_statements::
  getExpression ()
  {
    return this->expression_;
  }

  void T_statements::
  setExpression (const ExpressionSequence& s)
  {
    this->expression_ = s;
  }

  const T_statements::Process_method_callSequence& T_statements::
  getProcess_method_call () const
  {
    return this->process_method_call_;
  }

  T_statements::Process_method_callSequence& T_statements::
  getProcess_method_call ()
  {
    return this->process_method_call_;
  }

  void T_statements::
  setProcess_method_call (const Process_method_callSequence& s)
  {
    this->process_method_call_ = s;
  }

  const T_statements::Message_sendSequence& T_statements::
  getMessage_send () const
  {
    return this->message_send_;
  }

  T_statements::Message_sendSequence& T_statements::
  getMessage_send ()
  {
    return this->message_send_;
  }

  void T_statements::
  setMessage_send (const Message_sendSequence& s)
  {
    this->message_send_ = s;
  }

  const T_statements::Message_receiveSequence& T_statements::
  getMessage_receive () const
  {
    return this->message_receive_;
  }

  T_statements::Message_receiveSequence& T_statements::
  getMessage_receive ()
  {
    return this->message_receive_;
  }

  void T_statements::
  setMessage_receive (const Message_receiveSequence& s)
  {
    this->message_receive_ = s;
  }

  const T_statements::GuardSequence& T_statements::
  getGuard () const
  {
    return this->guard_;
  }

  T_statements::GuardSequence& T_statements::
  getGuard ()
  {
    return this->guard_;
  }

  void T_statements::
  setGuard (const GuardSequence& s)
  {
    this->guard_ = s;
  }

  const T_statements::IfSequence& T_statements::
  getIf () const
  {
    return this->if__;
  }

  T_statements::IfSequence& T_statements::
  getIf ()
  {
    return this->if__;
  }

  void T_statements::
  setIf (const IfSequence& s)
  {
    this->if__ = s;
  }

  const T_statements::WhileSequence& T_statements::
  getWhile () const
  {
    return this->while__;
  }

  T_statements::WhileSequence& T_statements::
  getWhile ()
  {
    return this->while__;
  }

  void T_statements::
  setWhile (const WhileSequence& s)
  {
    this->while__ = s;
  }

  const T_statements::SwitchSequence& T_statements::
  getSwitch () const
  {
    return this->switch__;
  }

  T_statements::SwitchSequence& T_statements::
  getSwitch ()
  {
    return this->switch__;
  }

  void T_statements::
  setSwitch (const SwitchSequence& s)
  {
    this->switch__ = s;
  }

  const T_statements::AbortSequence& T_statements::
  getAbort () const
  {
    return this->abort_;
  }

  T_statements::AbortSequence& T_statements::
  getAbort ()
  {
    return this->abort_;
  }

  void T_statements::
  setAbort (const AbortSequence& s)
  {
    this->abort_ = s;
  }

  const T_statements::InterruptSequence& T_statements::
  getInterrupt () const
  {
    return this->interrupt_;
  }

  T_statements::InterruptSequence& T_statements::
  getInterrupt ()
  {
    return this->interrupt_;
  }

  void T_statements::
  setInterrupt (const InterruptSequence& s)
  {
    this->interrupt_ = s;
  }

  const T_statements::SkipSequence& T_statements::
  getSkip () const
  {
    return this->skip_;
  }

  T_statements::SkipSequence& T_statements::
  getSkip ()
  {
    return this->skip_;
  }

  void T_statements::
  setSkip (const SkipSequence& s)
  {
    this->skip_ = s;
  }

  const T_statements::DelaySequence& T_statements::
  getDelay () const
  {
    return this->delay_;
  }

  T_statements::DelaySequence& T_statements::
  getDelay ()
  {
    return this->delay_;
  }

  void T_statements::
  setDelay (const DelaySequence& s)
  {
    this->delay_ = s;
  }

  const T_statements::Stmt_handleOptional& T_statements::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_statements::Stmt_handleOptional& T_statements::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_statements::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_statements::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_statement
  // 


  // T_process_method_call
  // 

  const T_process_method_call::ArgumentSequence& T_process_method_call::
  getArgument () const
  {
    return this->argument_;
  }

  T_process_method_call::ArgumentSequence& T_process_method_call::
  getArgument ()
  {
    return this->argument_;
  }

  void T_process_method_call::
  setArgument (const ArgumentSequence& s)
  {
    this->argument_ = s;
  }

  const T_process_method_call::Return_variableSequence& T_process_method_call::
  getReturn_variable () const
  {
    return this->return_variable_;
  }

  T_process_method_call::Return_variableSequence& T_process_method_call::
  getReturn_variable ()
  {
    return this->return_variable_;
  }

  void T_process_method_call::
  setReturn_variable (const Return_variableSequence& s)
  {
    this->return_variable_ = s;
  }

  const T_process_method_call::Method_nameType& T_process_method_call::
  getMethod_name () const
  {
    return this->method_name_.get ();
  }

  T_process_method_call::Method_nameType& T_process_method_call::
  getMethod_name ()
  {
    return this->method_name_.get ();
  }

  void T_process_method_call::
  setMethod_name (const Method_nameType& x)
  {
    this->method_name_.set (x);
  }

  void T_process_method_call::
  setMethod_name (::std::unique_ptr< Method_nameType > x)
  {
    this->method_name_.set (std::move (x));
  }

  const T_process_method_call::Stmt_handleOptional& T_process_method_call::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_process_method_call::Stmt_handleOptional& T_process_method_call::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_process_method_call::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_process_method_call::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_initial_process_method_call
  // 


  // T_message_receive
  // 

  const T_message_receive::VariableSequence& T_message_receive::
  getVariable () const
  {
    return this->variable_;
  }

  T_message_receive::VariableSequence& T_message_receive::
  getVariable ()
  {
    return this->variable_;
  }

  void T_message_receive::
  setVariable (const VariableSequence& s)
  {
    this->variable_ = s;
  }

  const T_message_receive::ConditionOptional& T_message_receive::
  getCondition () const
  {
    return this->condition_;
  }

  T_message_receive::ConditionOptional& T_message_receive::
  getCondition ()
  {
    return this->condition_;
  }

  void T_message_receive::
  setCondition (const ConditionType& x)
  {
    this->condition_.set (x);
  }

  void T_message_receive::
  setCondition (const ConditionOptional& x)
  {
    this->condition_ = x;
  }

  void T_message_receive::
  setCondition (::std::unique_ptr< ConditionType > x)
  {
    this->condition_.set (std::move (x));
  }

  const T_message_receive::Atomic_expressionOptional& T_message_receive::
  getAtomic_expression () const
  {
    return this->atomic_expression_;
  }

  T_message_receive::Atomic_expressionOptional& T_message_receive::
  getAtomic_expression ()
  {
    return this->atomic_expression_;
  }

  void T_message_receive::
  setAtomic_expression (const Atomic_expressionType& x)
  {
    this->atomic_expression_.set (x);
  }

  void T_message_receive::
  setAtomic_expression (const Atomic_expressionOptional& x)
  {
    this->atomic_expression_ = x;
  }

  void T_message_receive::
  setAtomic_expression (::std::unique_ptr< Atomic_expressionType > x)
  {
    this->atomic_expression_.set (std::move (x));
  }

  const T_message_receive::PortType& T_message_receive::
  getPort () const
  {
    return this->port_.get ();
  }

  T_message_receive::PortType& T_message_receive::
  getPort ()
  {
    return this->port_.get ();
  }

  void T_message_receive::
  setPort (const PortType& x)
  {
    this->port_.set (x);
  }

  void T_message_receive::
  setPort (::std::unique_ptr< PortType > x)
  {
    this->port_.set (std::move (x));
  }

  const T_message_receive::Message_nameOptional& T_message_receive::
  getMessage_name () const
  {
    return this->message_name_;
  }

  T_message_receive::Message_nameOptional& T_message_receive::
  getMessage_name ()
  {
    return this->message_name_;
  }

  void T_message_receive::
  setMessage_name (const Message_nameType& x)
  {
    this->message_name_.set (x);
  }

  void T_message_receive::
  setMessage_name (const Message_nameOptional& x)
  {
    this->message_name_ = x;
  }

  void T_message_receive::
  setMessage_name (::std::unique_ptr< Message_nameType > x)
  {
    this->message_name_.set (std::move (x));
  }

  const T_message_receive::Stmt_handleOptional& T_message_receive::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_message_receive::Stmt_handleOptional& T_message_receive::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_message_receive::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_message_receive::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_message_send
  // 

  const T_message_send::ArgumentSequence& T_message_send::
  getArgument () const
  {
    return this->argument_;
  }

  T_message_send::ArgumentSequence& T_message_send::
  getArgument ()
  {
    return this->argument_;
  }

  void T_message_send::
  setArgument (const ArgumentSequence& s)
  {
    this->argument_ = s;
  }

  const T_message_send::Atomic_expressionOptional& T_message_send::
  getAtomic_expression () const
  {
    return this->atomic_expression_;
  }

  T_message_send::Atomic_expressionOptional& T_message_send::
  getAtomic_expression ()
  {
    return this->atomic_expression_;
  }

  void T_message_send::
  setAtomic_expression (const Atomic_expressionType& x)
  {
    this->atomic_expression_.set (x);
  }

  void T_message_send::
  setAtomic_expression (const Atomic_expressionOptional& x)
  {
    this->atomic_expression_ = x;
  }

  void T_message_send::
  setAtomic_expression (::std::unique_ptr< Atomic_expressionType > x)
  {
    this->atomic_expression_.set (std::move (x));
  }

  const T_message_send::PortType& T_message_send::
  getPort () const
  {
    return this->port_.get ();
  }

  T_message_send::PortType& T_message_send::
  getPort ()
  {
    return this->port_.get ();
  }

  void T_message_send::
  setPort (const PortType& x)
  {
    this->port_.set (x);
  }

  void T_message_send::
  setPort (::std::unique_ptr< PortType > x)
  {
    this->port_.set (std::move (x));
  }

  const T_message_send::Message_nameOptional& T_message_send::
  getMessage_name () const
  {
    return this->message_name_;
  }

  T_message_send::Message_nameOptional& T_message_send::
  getMessage_name ()
  {
    return this->message_name_;
  }

  void T_message_send::
  setMessage_name (const Message_nameType& x)
  {
    this->message_name_.set (x);
  }

  void T_message_send::
  setMessage_name (const Message_nameOptional& x)
  {
    this->message_name_ = x;
  }

  void T_message_send::
  setMessage_name (::std::unique_ptr< Message_nameType > x)
  {
    this->message_name_.set (std::move (x));
  }

  const T_message_send::Stmt_handleOptional& T_message_send::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_message_send::Stmt_handleOptional& T_message_send::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_message_send::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_message_send::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_guard
  // 

  const T_guard::ExpressionType& T_guard::
  getExpression () const
  {
    return this->expression_.get ();
  }

  T_guard::ExpressionType& T_guard::
  getExpression ()
  {
    return this->expression_.get ();
  }

  void T_guard::
  setExpression (const ExpressionType& x)
  {
    this->expression_.set (x);
  }

  void T_guard::
  setExpression (::std::unique_ptr< ExpressionType > x)
  {
    this->expression_.set (std::move (x));
  }

  const T_guard::StatementType& T_guard::
  getStatement () const
  {
    return this->statement_.get ();
  }

  T_guard::StatementType& T_guard::
  getStatement ()
  {
    return this->statement_.get ();
  }

  void T_guard::
  setStatement (const StatementType& x)
  {
    this->statement_.set (x);
  }

  void T_guard::
  setStatement (::std::unique_ptr< StatementType > x)
  {
    this->statement_.set (std::move (x));
  }

  const T_guard::Stmt_handleOptional& T_guard::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_guard::Stmt_handleOptional& T_guard::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_guard::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_guard::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_if_statement
  // 

  const T_if_statement::ConditionType& T_if_statement::
  getCondition () const
  {
    return this->condition_.get ();
  }

  T_if_statement::ConditionType& T_if_statement::
  getCondition ()
  {
    return this->condition_.get ();
  }

  void T_if_statement::
  setCondition (const ConditionType& x)
  {
    this->condition_.set (x);
  }

  void T_if_statement::
  setCondition (::std::unique_ptr< ConditionType > x)
  {
    this->condition_.set (std::move (x));
  }

  const T_if_statement::ThenType& T_if_statement::
  getThen () const
  {
    return this->then_.get ();
  }

  T_if_statement::ThenType& T_if_statement::
  getThen ()
  {
    return this->then_.get ();
  }

  void T_if_statement::
  setThen (const ThenType& x)
  {
    this->then_.set (x);
  }

  void T_if_statement::
  setThen (::std::unique_ptr< ThenType > x)
  {
    this->then_.set (std::move (x));
  }

  const T_if_statement::ElseOptional& T_if_statement::
  getElse () const
  {
    return this->else__;
  }

  T_if_statement::ElseOptional& T_if_statement::
  getElse ()
  {
    return this->else__;
  }

  void T_if_statement::
  setElse (const ElseType& x)
  {
    this->else__.set (x);
  }

  void T_if_statement::
  setElse (const ElseOptional& x)
  {
    this->else__ = x;
  }

  void T_if_statement::
  setElse (::std::unique_ptr< ElseType > x)
  {
    this->else__.set (std::move (x));
  }

  const T_if_statement::Stmt_handleOptional& T_if_statement::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_if_statement::Stmt_handleOptional& T_if_statement::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_if_statement::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_if_statement::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_while_statement
  // 

  const T_while_statement::ConditionType& T_while_statement::
  getCondition () const
  {
    return this->condition_.get ();
  }

  T_while_statement::ConditionType& T_while_statement::
  getCondition ()
  {
    return this->condition_.get ();
  }

  void T_while_statement::
  setCondition (const ConditionType& x)
  {
    this->condition_.set (x);
  }

  void T_while_statement::
  setCondition (::std::unique_ptr< ConditionType > x)
  {
    this->condition_.set (std::move (x));
  }

  const T_while_statement::BodyType& T_while_statement::
  getBody () const
  {
    return this->body_.get ();
  }

  T_while_statement::BodyType& T_while_statement::
  getBody ()
  {
    return this->body_.get ();
  }

  void T_while_statement::
  setBody (const BodyType& x)
  {
    this->body_.set (x);
  }

  void T_while_statement::
  setBody (::std::unique_ptr< BodyType > x)
  {
    this->body_.set (std::move (x));
  }

  const T_while_statement::Stmt_handleOptional& T_while_statement::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_while_statement::Stmt_handleOptional& T_while_statement::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_while_statement::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_while_statement::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_switch_statement
  // 

  const T_switch_statement::Control_expressionType& T_switch_statement::
  getControl_expression () const
  {
    return this->control_expression_.get ();
  }

  T_switch_statement::Control_expressionType& T_switch_statement::
  getControl_expression ()
  {
    return this->control_expression_.get ();
  }

  void T_switch_statement::
  setControl_expression (const Control_expressionType& x)
  {
    this->control_expression_.set (x);
  }

  void T_switch_statement::
  setControl_expression (::std::unique_ptr< Control_expressionType > x)
  {
    this->control_expression_.set (std::move (x));
  }

  const T_switch_statement::CaseSequence& T_switch_statement::
  getCase () const
  {
    return this->case__;
  }

  T_switch_statement::CaseSequence& T_switch_statement::
  getCase ()
  {
    return this->case__;
  }

  void T_switch_statement::
  setCase (const CaseSequence& s)
  {
    this->case__ = s;
  }

  const T_switch_statement::DefaultSequence& T_switch_statement::
  getDefault () const
  {
    return this->default__;
  }

  T_switch_statement::DefaultSequence& T_switch_statement::
  getDefault ()
  {
    return this->default__;
  }

  void T_switch_statement::
  setDefault (const DefaultSequence& s)
  {
    this->default__ = s;
  }

  const T_switch_statement::Stmt_handleOptional& T_switch_statement::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_switch_statement::Stmt_handleOptional& T_switch_statement::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_switch_statement::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_switch_statement::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_switch_case_statement
  // 

  const T_switch_case_statement::Value_expressionSequence& T_switch_case_statement::
  getValue_expression () const
  {
    return this->value_expression_;
  }

  T_switch_case_statement::Value_expressionSequence& T_switch_case_statement::
  getValue_expression ()
  {
    return this->value_expression_;
  }

  void T_switch_case_statement::
  setValue_expression (const Value_expressionSequence& s)
  {
    this->value_expression_ = s;
  }

  const T_switch_case_statement::BodyType& T_switch_case_statement::
  getBody () const
  {
    return this->body_.get ();
  }

  T_switch_case_statement::BodyType& T_switch_case_statement::
  getBody ()
  {
    return this->body_.get ();
  }

  void T_switch_case_statement::
  setBody (const BodyType& x)
  {
    this->body_.set (x);
  }

  void T_switch_case_statement::
  setBody (::std::unique_ptr< BodyType > x)
  {
    this->body_.set (std::move (x));
  }


  // T_abort
  // 

  const T_abort::Normal_behaviorType& T_abort::
  getNormal_behavior () const
  {
    return this->normal_behavior_.get ();
  }

  T_abort::Normal_behaviorType& T_abort::
  getNormal_behavior ()
  {
    return this->normal_behavior_.get ();
  }

  void T_abort::
  setNormal_behavior (const Normal_behaviorType& x)
  {
    this->normal_behavior_.set (x);
  }

  void T_abort::
  setNormal_behavior (::std::unique_ptr< Normal_behaviorType > x)
  {
    this->normal_behavior_.set (std::move (x));
  }

  const T_abort::Aborting_behaviorType& T_abort::
  getAborting_behavior () const
  {
    return this->aborting_behavior_.get ();
  }

  T_abort::Aborting_behaviorType& T_abort::
  getAborting_behavior ()
  {
    return this->aborting_behavior_.get ();
  }

  void T_abort::
  setAborting_behavior (const Aborting_behaviorType& x)
  {
    this->aborting_behavior_.set (x);
  }

  void T_abort::
  setAborting_behavior (::std::unique_ptr< Aborting_behaviorType > x)
  {
    this->aborting_behavior_.set (std::move (x));
  }

  const T_abort::Stmt_handleOptional& T_abort::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_abort::Stmt_handleOptional& T_abort::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_abort::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_abort::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_interrupt
  // 

  const T_interrupt::Normal_behaviorType& T_interrupt::
  getNormal_behavior () const
  {
    return this->normal_behavior_.get ();
  }

  T_interrupt::Normal_behaviorType& T_interrupt::
  getNormal_behavior ()
  {
    return this->normal_behavior_.get ();
  }

  void T_interrupt::
  setNormal_behavior (const Normal_behaviorType& x)
  {
    this->normal_behavior_.set (x);
  }

  void T_interrupt::
  setNormal_behavior (::std::unique_ptr< Normal_behaviorType > x)
  {
    this->normal_behavior_.set (std::move (x));
  }

  const T_interrupt::Interrupting_behaviorType& T_interrupt::
  getInterrupting_behavior () const
  {
    return this->interrupting_behavior_.get ();
  }

  T_interrupt::Interrupting_behaviorType& T_interrupt::
  getInterrupting_behavior ()
  {
    return this->interrupting_behavior_.get ();
  }

  void T_interrupt::
  setInterrupting_behavior (const Interrupting_behaviorType& x)
  {
    this->interrupting_behavior_.set (x);
  }

  void T_interrupt::
  setInterrupting_behavior (::std::unique_ptr< Interrupting_behaviorType > x)
  {
    this->interrupting_behavior_.set (std::move (x));
  }

  const T_interrupt::Stmt_handleOptional& T_interrupt::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_interrupt::Stmt_handleOptional& T_interrupt::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_interrupt::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_interrupt::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace poosl
{
  // T_constant_type
  //

  T_constant_type::
  T_constant_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_constant_type_convert ();
  }

  T_constant_type::
  T_constant_type (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_constant_type_convert ();
  }

  T_constant_type::
  T_constant_type (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_constant_type_convert ();
  }

  T_constant_type* T_constant_type::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_constant_type (*this, f, c);
  }

  T_constant_type::Value T_constant_type::
  _xsd_T_constant_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_constant_type_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_constant_type_indexes_,
                      _xsd_T_constant_type_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_T_constant_type_indexes_ + 5 || _xsd_T_constant_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_constant_type::
  _xsd_T_constant_type_literals_[5] =
  {
    "string",
    "character",
    "integer",
    "real",
    "boolean"
  };

  const T_constant_type::Value T_constant_type::
  _xsd_T_constant_type_indexes_[5] =
  {
    ::poosl::T_constant_type::boolean,
    ::poosl::T_constant_type::character,
    ::poosl::T_constant_type::integer,
    ::poosl::T_constant_type::real,
    ::poosl::T_constant_type::string
  };

  // T_binary_operator
  //

  T_binary_operator::
  T_binary_operator (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_binary_operator_convert ();
  }

  T_binary_operator::
  T_binary_operator (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_binary_operator_convert ();
  }

  T_binary_operator::
  T_binary_operator (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_binary_operator_convert ();
  }

  T_binary_operator* T_binary_operator::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_binary_operator (*this, f, c);
  }

  T_binary_operator::Value T_binary_operator::
  _xsd_T_binary_operator_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_binary_operator_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_binary_operator_indexes_,
                      _xsd_T_binary_operator_indexes_ + 14,
                      *this,
                      c));

    if (i == _xsd_T_binary_operator_indexes_ + 14 || _xsd_T_binary_operator_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_binary_operator::
  _xsd_T_binary_operator_literals_[14] =
  {
    "+",
    "-",
    "*",
    "/",
    "=",
    "!=",
    "==",
    "!==",
    "&",
    "|",
    "<",
    ">",
    ">=",
    "<="
  };

  const T_binary_operator::Value T_binary_operator::
  _xsd_T_binary_operator_indexes_[14] =
  {
    ::poosl::T_binary_operator::cxx__,
    ::poosl::T_binary_operator::cxx___,
    ::poosl::T_binary_operator::cxx_5,
    ::poosl::T_binary_operator::cxx_2,
    ::poosl::T_binary_operator::cxx_,
    ::poosl::T_binary_operator::cxx_1,
    ::poosl::T_binary_operator::cxx_3,
    ::poosl::T_binary_operator::cxx_7,
    ::poosl::T_binary_operator::cxx__3,
    ::poosl::T_binary_operator::cxx_4,
    ::poosl::T_binary_operator::cxx__1,
    ::poosl::T_binary_operator::cxx_8,
    ::poosl::T_binary_operator::cxx__2,
    ::poosl::T_binary_operator::cxx_6
  };

  // T_unary_operator
  //

  T_unary_operator::
  T_unary_operator (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_unary_operator_convert ();
  }

  T_unary_operator::
  T_unary_operator (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_unary_operator_convert ();
  }

  T_unary_operator::
  T_unary_operator (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_unary_operator_convert ();
  }

  T_unary_operator* T_unary_operator::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_unary_operator (*this, f, c);
  }

  T_unary_operator::Value T_unary_operator::
  _xsd_T_unary_operator_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_unary_operator_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_unary_operator_indexes_,
                      _xsd_T_unary_operator_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_T_unary_operator_indexes_ + 2 || _xsd_T_unary_operator_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_unary_operator::
  _xsd_T_unary_operator_literals_[2] =
  {
    "-",
    "!"
  };

  const T_unary_operator::Value T_unary_operator::
  _xsd_T_unary_operator_indexes_[2] =
  {
    ::poosl::T_unary_operator::cxx_1,
    ::poosl::T_unary_operator::cxx_
  };

  // T_expressions
  //

  T_expressions::
  T_expressions ()
  : ::xml_schema::Type (),
    sequence_of_expressions_ (this),
    assignment_ (this),
    data_method_call_ (this),
    constant_ (this),
    variable_ (this),
    binary_operation_ (this),
    unary_operation_ (this),
    self_ (this),
    nil_ (this),
    current_time_ (this),
    if__ (this),
    while__ (this),
    new__ (this),
    return__ (this),
    stmt_handle_ (this)
  {
  }

  T_expressions::
  T_expressions (const T_expressions& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    sequence_of_expressions_ (x.sequence_of_expressions_, f, this),
    assignment_ (x.assignment_, f, this),
    data_method_call_ (x.data_method_call_, f, this),
    constant_ (x.constant_, f, this),
    variable_ (x.variable_, f, this),
    binary_operation_ (x.binary_operation_, f, this),
    unary_operation_ (x.unary_operation_, f, this),
    self_ (x.self_, f, this),
    nil_ (x.nil_, f, this),
    current_time_ (x.current_time_, f, this),
    if__ (x.if__, f, this),
    while__ (x.while__, f, this),
    new__ (x.new__, f, this),
    return__ (x.return__, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_expressions::
  T_expressions (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    sequence_of_expressions_ (this),
    assignment_ (this),
    data_method_call_ (this),
    constant_ (this),
    variable_ (this),
    binary_operation_ (this),
    unary_operation_ (this),
    self_ (this),
    nil_ (this),
    current_time_ (this),
    if__ (this),
    while__ (this),
    new__ (this),
    return__ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_expressions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sequence_of_expressions
      //
      if (n.name () == "sequence_of_expressions" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Sequence_of_expressionsType > r (
          Sequence_of_expressionsTraits::create (i, f, this));

        this->sequence_of_expressions_.push_back (::std::move (r));
        continue;
      }

      // assignment
      //
      if (n.name () == "assignment" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AssignmentType > r (
          AssignmentTraits::create (i, f, this));

        this->assignment_.push_back (::std::move (r));
        continue;
      }

      // data_method_call
      //
      if (n.name () == "data_method_call" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Data_method_callType > r (
          Data_method_callTraits::create (i, f, this));

        this->data_method_call_.push_back (::std::move (r));
        continue;
      }

      // constant
      //
      if (n.name () == "constant" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ConstantType > r (
          ConstantTraits::create (i, f, this));

        this->constant_.push_back (::std::move (r));
        continue;
      }

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        this->variable_.push_back (::std::move (r));
        continue;
      }

      // binary_operation
      //
      if (n.name () == "binary_operation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Binary_operationType > r (
          Binary_operationTraits::create (i, f, this));

        this->binary_operation_.push_back (::std::move (r));
        continue;
      }

      // unary_operation
      //
      if (n.name () == "unary_operation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Unary_operationType > r (
          Unary_operationTraits::create (i, f, this));

        this->unary_operation_.push_back (::std::move (r));
        continue;
      }

      // self
      //
      if (n.name () == "self" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SelfType > r (
          SelfTraits::create (i, f, this));

        this->self_.push_back (::std::move (r));
        continue;
      }

      // nil
      //
      if (n.name () == "nil" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NilType > r (
          NilTraits::create (i, f, this));

        this->nil_.push_back (::std::move (r));
        continue;
      }

      // current_time
      //
      if (n.name () == "current_time" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Current_timeType > r (
          Current_timeTraits::create (i, f, this));

        this->current_time_.push_back (::std::move (r));
        continue;
      }

      // if
      //
      if (n.name () == "if" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< IfType > r (
          IfTraits::create (i, f, this));

        this->if__.push_back (::std::move (r));
        continue;
      }

      // while
      //
      if (n.name () == "while" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< WhileType > r (
          WhileTraits::create (i, f, this));

        this->while__.push_back (::std::move (r));
        continue;
      }

      // new
      //
      if (n.name () == "new" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NewType > r (
          NewTraits::create (i, f, this));

        this->new__.push_back (::std::move (r));
        continue;
      }

      // return
      //
      if (n.name () == "return" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ReturnType > r (
          ReturnTraits::create (i, f, this));

        this->return__.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_expressions* T_expressions::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_expressions (*this, f, c);
  }

  T_expressions& T_expressions::
  operator= (const T_expressions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->sequence_of_expressions_ = x.sequence_of_expressions_;
      this->assignment_ = x.assignment_;
      this->data_method_call_ = x.data_method_call_;
      this->constant_ = x.constant_;
      this->variable_ = x.variable_;
      this->binary_operation_ = x.binary_operation_;
      this->unary_operation_ = x.unary_operation_;
      this->self_ = x.self_;
      this->nil_ = x.nil_;
      this->current_time_ = x.current_time_;
      this->if__ = x.if__;
      this->while__ = x.while__;
      this->new__ = x.new__;
      this->return__ = x.return__;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_expressions::
  ~T_expressions ()
  {
  }

  // T_expression
  //

  T_expression::
  T_expression ()
  : ::poosl::T_expressions ()
  {
  }

  T_expression::
  T_expression (const T_expression& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::poosl::T_expressions (x, f, c)
  {
  }

  T_expression::
  T_expression (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::poosl::T_expressions (e, f, c)
  {
  }

  T_expression* T_expression::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_expression (*this, f, c);
  }

  T_expression::
  ~T_expression ()
  {
  }

  // T_assignment
  //

  T_assignment::
  T_assignment ()
  : ::poosl::T_expression (),
    variable_name_ (this)
  {
  }

  T_assignment::
  T_assignment (const Variable_nameType& variable_name)
  : ::poosl::T_expression (),
    variable_name_ (variable_name, this)
  {
  }

  T_assignment::
  T_assignment (const T_assignment& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::poosl::T_expression (x, f, c),
    variable_name_ (x.variable_name_, f, this)
  {
  }

  T_assignment::
  T_assignment (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::poosl::T_expression (e, f | ::xml_schema::Flags::base, c),
    variable_name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_assignment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::poosl::T_expression::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "variable_name" && n.namespace_ ().empty ())
      {
        this->variable_name_.set (Variable_nameTraits::create (i, f, this));
        continue;
      }
    }

    if (!variable_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "variable_name",
        "");
    }
  }

  T_assignment* T_assignment::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_assignment (*this, f, c);
  }

  T_assignment& T_assignment::
  operator= (const T_assignment& x)
  {
    if (this != &x)
    {
      static_cast< ::poosl::T_expression& > (*this) = x;
      this->variable_name_ = x.variable_name_;
    }

    return *this;
  }

  T_assignment::
  ~T_assignment ()
  {
  }

  // T_data_method_call
  //

  T_data_method_call::
  T_data_method_call ()
  : ::xml_schema::Type (),
    receiver_ (this),
    argument_ (this),
    method_name_ (this),
    super_ (this),
    stmt_handle_ (this)
  {
  }

  T_data_method_call::
  T_data_method_call (const ReceiverType& receiver,
                      const Method_nameType& method_name,
                      const SuperType& super)
  : ::xml_schema::Type (),
    receiver_ (receiver, this),
    argument_ (this),
    method_name_ (method_name, this),
    super_ (super, this),
    stmt_handle_ (this)
  {
  }

  T_data_method_call::
  T_data_method_call (::std::unique_ptr< ReceiverType > receiver,
                      const Method_nameType& method_name,
                      const SuperType& super)
  : ::xml_schema::Type (),
    receiver_ (std::move (receiver), this),
    argument_ (this),
    method_name_ (method_name, this),
    super_ (super, this),
    stmt_handle_ (this)
  {
  }

  T_data_method_call::
  T_data_method_call (const T_data_method_call& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    receiver_ (x.receiver_, f, this),
    argument_ (x.argument_, f, this),
    method_name_ (x.method_name_, f, this),
    super_ (x.super_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_data_method_call::
  T_data_method_call (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    receiver_ (this),
    argument_ (this),
    method_name_ (this),
    super_ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_data_method_call::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // receiver
      //
      if (n.name () == "receiver" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ReceiverType > r (
          ReceiverTraits::create (i, f, this));

        if (!receiver_.present ())
        {
          this->receiver_.set (::std::move (r));
          continue;
        }
      }

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ArgumentType > r (
          ArgumentTraits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "receiver",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "method_name" && n.namespace_ ().empty ())
      {
        this->method_name_.set (Method_nameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "super" && n.namespace_ ().empty ())
      {
        this->super_.set (SuperTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }

    if (!method_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "method_name",
        "");
    }

    if (!super_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "super",
        "");
    }
  }

  T_data_method_call* T_data_method_call::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_data_method_call (*this, f, c);
  }

  T_data_method_call& T_data_method_call::
  operator= (const T_data_method_call& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->receiver_ = x.receiver_;
      this->argument_ = x.argument_;
      this->method_name_ = x.method_name_;
      this->super_ = x.super_;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_data_method_call::
  ~T_data_method_call ()
  {
  }

  // T_constant
  //

  T_constant::
  T_constant ()
  : ::xml_schema::String (),
    type_ (this)
  {
  }

  T_constant::
  T_constant (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    type_ (this)
  {
  }

  T_constant::
  T_constant (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    type_ (this)
  {
  }

  T_constant::
  T_constant (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    type_ (this)
  {
  }

  T_constant::
  T_constant (const T_constant& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  T_constant::
  T_constant (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void T_constant::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_constant* T_constant::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_constant (*this, f, c);
  }

  T_constant& T_constant::
  operator= (const T_constant& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::String& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  T_constant::
  ~T_constant ()
  {
  }

  // T_current_time
  //

  T_current_time::
  T_current_time ()
  : ::xml_schema::Type ()
  {
  }

  T_current_time::
  T_current_time (const T_current_time& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c)
  {
  }

  T_current_time::
  T_current_time (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f, c)
  {
  }

  T_current_time::
  T_current_time (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (a, f, c)
  {
  }

  T_current_time::
  T_current_time (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (s, e, f, c)
  {
  }

  T_current_time* T_current_time::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_current_time (*this, f, c);
  }

  T_current_time::
  ~T_current_time ()
  {
  }

  // T_variable_ref
  //

  T_variable_ref::
  T_variable_ref ()
  : ::xml_schema::Type (),
    name_ (this)
  {
  }

  T_variable_ref::
  T_variable_ref (const T_variable_ref& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this)
  {
  }

  T_variable_ref::
  T_variable_ref (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void T_variable_ref::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_variable_ref* T_variable_ref::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_variable_ref (*this, f, c);
  }

  T_variable_ref& T_variable_ref::
  operator= (const T_variable_ref& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
    }

    return *this;
  }

  T_variable_ref::
  ~T_variable_ref ()
  {
  }

  // T_binary_operation
  //

  T_binary_operation::
  T_binary_operation ()
  : ::xml_schema::Type (),
    left_operand_ (this),
    right_operand_ (this),
    operator__ (this),
    stmt_handle_ (this)
  {
  }

  T_binary_operation::
  T_binary_operation (const Left_operandType& left_operand,
                      const Right_operandType& right_operand)
  : ::xml_schema::Type (),
    left_operand_ (left_operand, this),
    right_operand_ (right_operand, this),
    operator__ (this),
    stmt_handle_ (this)
  {
  }

  T_binary_operation::
  T_binary_operation (::std::unique_ptr< Left_operandType > left_operand,
                      ::std::unique_ptr< Right_operandType > right_operand)
  : ::xml_schema::Type (),
    left_operand_ (std::move (left_operand), this),
    right_operand_ (std::move (right_operand), this),
    operator__ (this),
    stmt_handle_ (this)
  {
  }

  T_binary_operation::
  T_binary_operation (const T_binary_operation& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    left_operand_ (x.left_operand_, f, this),
    right_operand_ (x.right_operand_, f, this),
    operator__ (x.operator__, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_binary_operation::
  T_binary_operation (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    left_operand_ (this),
    right_operand_ (this),
    operator__ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_binary_operation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // left_operand
      //
      if (n.name () == "left_operand" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Left_operandType > r (
          Left_operandTraits::create (i, f, this));

        if (!left_operand_.present ())
        {
          this->left_operand_.set (::std::move (r));
          continue;
        }
      }

      // right_operand
      //
      if (n.name () == "right_operand" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Right_operandType > r (
          Right_operandTraits::create (i, f, this));

        if (!right_operand_.present ())
        {
          this->right_operand_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!left_operand_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "left_operand",
        "uri:poosl");
    }

    if (!right_operand_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "right_operand",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "operator" && n.namespace_ ().empty ())
      {
        this->operator__.set (OperatorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_binary_operation* T_binary_operation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_binary_operation (*this, f, c);
  }

  T_binary_operation& T_binary_operation::
  operator= (const T_binary_operation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->left_operand_ = x.left_operand_;
      this->right_operand_ = x.right_operand_;
      this->operator__ = x.operator__;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_binary_operation::
  ~T_binary_operation ()
  {
  }

  // T_unary_operation
  //

  T_unary_operation::
  T_unary_operation ()
  : ::xml_schema::Type (),
    operand_ (this),
    operator__ (this),
    stmt_handle_ (this)
  {
  }

  T_unary_operation::
  T_unary_operation (const OperandType& operand)
  : ::xml_schema::Type (),
    operand_ (operand, this),
    operator__ (this),
    stmt_handle_ (this)
  {
  }

  T_unary_operation::
  T_unary_operation (::std::unique_ptr< OperandType > operand)
  : ::xml_schema::Type (),
    operand_ (std::move (operand), this),
    operator__ (this),
    stmt_handle_ (this)
  {
  }

  T_unary_operation::
  T_unary_operation (const T_unary_operation& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    operand_ (x.operand_, f, this),
    operator__ (x.operator__, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_unary_operation::
  T_unary_operation (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    operand_ (this),
    operator__ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_unary_operation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // operand
      //
      if (n.name () == "operand" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< OperandType > r (
          OperandTraits::create (i, f, this));

        if (!operand_.present ())
        {
          this->operand_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!operand_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "operand",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "operator" && n.namespace_ ().empty ())
      {
        this->operator__.set (OperatorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_unary_operation* T_unary_operation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_unary_operation (*this, f, c);
  }

  T_unary_operation& T_unary_operation::
  operator= (const T_unary_operation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->operand_ = x.operand_;
      this->operator__ = x.operator__;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_unary_operation::
  ~T_unary_operation ()
  {
  }

  // T_if_expression
  //

  T_if_expression::
  T_if_expression ()
  : ::xml_schema::Type (),
    condition_ (this),
    then_ (this),
    else__ (this)
  {
  }

  T_if_expression::
  T_if_expression (const ConditionType& condition,
                   const ThenType& then)
  : ::xml_schema::Type (),
    condition_ (condition, this),
    then_ (then, this),
    else__ (this)
  {
  }

  T_if_expression::
  T_if_expression (::std::unique_ptr< ConditionType > condition,
                   ::std::unique_ptr< ThenType > then)
  : ::xml_schema::Type (),
    condition_ (std::move (condition), this),
    then_ (std::move (then), this),
    else__ (this)
  {
  }

  T_if_expression::
  T_if_expression (const T_if_expression& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    condition_ (x.condition_, f, this),
    then_ (x.then_, f, this),
    else__ (x.else__, f, this)
  {
  }

  T_if_expression::
  T_if_expression (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    condition_ (this),
    then_ (this),
    else__ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_if_expression::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // condition
      //
      if (n.name () == "condition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ConditionType > r (
          ConditionTraits::create (i, f, this));

        if (!condition_.present ())
        {
          this->condition_.set (::std::move (r));
          continue;
        }
      }

      // then
      //
      if (n.name () == "then" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ThenType > r (
          ThenTraits::create (i, f, this));

        if (!then_.present ())
        {
          this->then_.set (::std::move (r));
          continue;
        }
      }

      // else
      //
      if (n.name () == "else" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ElseType > r (
          ElseTraits::create (i, f, this));

        if (!this->else__)
        {
          this->else__.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!condition_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "condition",
        "uri:poosl");
    }

    if (!then_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "then",
        "uri:poosl");
    }
  }

  T_if_expression* T_if_expression::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_if_expression (*this, f, c);
  }

  T_if_expression& T_if_expression::
  operator= (const T_if_expression& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->condition_ = x.condition_;
      this->then_ = x.then_;
      this->else__ = x.else__;
    }

    return *this;
  }

  T_if_expression::
  ~T_if_expression ()
  {
  }

  // T_while_expression
  //

  T_while_expression::
  T_while_expression ()
  : ::xml_schema::Type (),
    condition_ (this),
    body_ (this)
  {
  }

  T_while_expression::
  T_while_expression (const ConditionType& condition,
                      const BodyType& body)
  : ::xml_schema::Type (),
    condition_ (condition, this),
    body_ (body, this)
  {
  }

  T_while_expression::
  T_while_expression (::std::unique_ptr< ConditionType > condition,
                      ::std::unique_ptr< BodyType > body)
  : ::xml_schema::Type (),
    condition_ (std::move (condition), this),
    body_ (std::move (body), this)
  {
  }

  T_while_expression::
  T_while_expression (const T_while_expression& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    condition_ (x.condition_, f, this),
    body_ (x.body_, f, this)
  {
  }

  T_while_expression::
  T_while_expression (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    condition_ (this),
    body_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_while_expression::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // condition
      //
      if (n.name () == "condition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ConditionType > r (
          ConditionTraits::create (i, f, this));

        if (!condition_.present ())
        {
          this->condition_.set (::std::move (r));
          continue;
        }
      }

      // body
      //
      if (n.name () == "body" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< BodyType > r (
          BodyTraits::create (i, f, this));

        if (!body_.present ())
        {
          this->body_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!condition_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "condition",
        "uri:poosl");
    }

    if (!body_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "body",
        "uri:poosl");
    }
  }

  T_while_expression* T_while_expression::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_while_expression (*this, f, c);
  }

  T_while_expression& T_while_expression::
  operator= (const T_while_expression& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->condition_ = x.condition_;
      this->body_ = x.body_;
    }

    return *this;
  }

  T_while_expression::
  ~T_while_expression ()
  {
  }

  // T_object_creation
  //

  T_object_creation::
  T_object_creation ()
  : ::xml_schema::Type (),
    data_class_ (this)
  {
  }

  T_object_creation::
  T_object_creation (const T_object_creation& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    data_class_ (x.data_class_, f, this)
  {
  }

  T_object_creation::
  T_object_creation (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    data_class_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void T_object_creation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "data_class" && n.namespace_ ().empty ())
      {
        this->data_class_.set (Data_classTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_object_creation* T_object_creation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_object_creation (*this, f, c);
  }

  T_object_creation& T_object_creation::
  operator= (const T_object_creation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->data_class_ = x.data_class_;
    }

    return *this;
  }

  T_object_creation::
  ~T_object_creation ()
  {
  }

  // T_statements
  //

  T_statements::
  T_statements ()
  : ::xml_schema::Type (),
    sequence_of_statements_ (this),
    parallel_statements_ (this),
    select_statements_ (this),
    expression_ (this),
    process_method_call_ (this),
    message_send_ (this),
    message_receive_ (this),
    guard_ (this),
    if__ (this),
    while__ (this),
    switch__ (this),
    abort_ (this),
    interrupt_ (this),
    skip_ (this),
    delay_ (this),
    stmt_handle_ (this)
  {
  }

  T_statements::
  T_statements (const T_statements& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    sequence_of_statements_ (x.sequence_of_statements_, f, this),
    parallel_statements_ (x.parallel_statements_, f, this),
    select_statements_ (x.select_statements_, f, this),
    expression_ (x.expression_, f, this),
    process_method_call_ (x.process_method_call_, f, this),
    message_send_ (x.message_send_, f, this),
    message_receive_ (x.message_receive_, f, this),
    guard_ (x.guard_, f, this),
    if__ (x.if__, f, this),
    while__ (x.while__, f, this),
    switch__ (x.switch__, f, this),
    abort_ (x.abort_, f, this),
    interrupt_ (x.interrupt_, f, this),
    skip_ (x.skip_, f, this),
    delay_ (x.delay_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_statements::
  T_statements (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    sequence_of_statements_ (this),
    parallel_statements_ (this),
    select_statements_ (this),
    expression_ (this),
    process_method_call_ (this),
    message_send_ (this),
    message_receive_ (this),
    guard_ (this),
    if__ (this),
    while__ (this),
    switch__ (this),
    abort_ (this),
    interrupt_ (this),
    skip_ (this),
    delay_ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_statements::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sequence_of_statements
      //
      if (n.name () == "sequence_of_statements" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Sequence_of_statementsType > r (
          Sequence_of_statementsTraits::create (i, f, this));

        this->sequence_of_statements_.push_back (::std::move (r));
        continue;
      }

      // parallel_statements
      //
      if (n.name () == "parallel_statements" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Parallel_statementsType > r (
          Parallel_statementsTraits::create (i, f, this));

        this->parallel_statements_.push_back (::std::move (r));
        continue;
      }

      // select_statements
      //
      if (n.name () == "select_statements" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Select_statementsType > r (
          Select_statementsTraits::create (i, f, this));

        this->select_statements_.push_back (::std::move (r));
        continue;
      }

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ExpressionType > r (
          ExpressionTraits::create (i, f, this));

        this->expression_.push_back (::std::move (r));
        continue;
      }

      // process_method_call
      //
      if (n.name () == "process_method_call" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_method_callType > r (
          Process_method_callTraits::create (i, f, this));

        this->process_method_call_.push_back (::std::move (r));
        continue;
      }

      // message_send
      //
      if (n.name () == "message_send" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Message_sendType > r (
          Message_sendTraits::create (i, f, this));

        this->message_send_.push_back (::std::move (r));
        continue;
      }

      // message_receive
      //
      if (n.name () == "message_receive" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Message_receiveType > r (
          Message_receiveTraits::create (i, f, this));

        this->message_receive_.push_back (::std::move (r));
        continue;
      }

      // guard
      //
      if (n.name () == "guard" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< GuardType > r (
          GuardTraits::create (i, f, this));

        this->guard_.push_back (::std::move (r));
        continue;
      }

      // if
      //
      if (n.name () == "if" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< IfType > r (
          IfTraits::create (i, f, this));

        this->if__.push_back (::std::move (r));
        continue;
      }

      // while
      //
      if (n.name () == "while" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< WhileType > r (
          WhileTraits::create (i, f, this));

        this->while__.push_back (::std::move (r));
        continue;
      }

      // switch
      //
      if (n.name () == "switch" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SwitchType > r (
          SwitchTraits::create (i, f, this));

        this->switch__.push_back (::std::move (r));
        continue;
      }

      // abort
      //
      if (n.name () == "abort" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AbortType > r (
          AbortTraits::create (i, f, this));

        this->abort_.push_back (::std::move (r));
        continue;
      }

      // interrupt
      //
      if (n.name () == "interrupt" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InterruptType > r (
          InterruptTraits::create (i, f, this));

        this->interrupt_.push_back (::std::move (r));
        continue;
      }

      // skip
      //
      if (n.name () == "skip" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SkipType > r (
          SkipTraits::create (i, f, this));

        this->skip_.push_back (::std::move (r));
        continue;
      }

      // delay
      //
      if (n.name () == "delay" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< DelayType > r (
          DelayTraits::create (i, f, this));

        this->delay_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_statements* T_statements::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_statements (*this, f, c);
  }

  T_statements& T_statements::
  operator= (const T_statements& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->sequence_of_statements_ = x.sequence_of_statements_;
      this->parallel_statements_ = x.parallel_statements_;
      this->select_statements_ = x.select_statements_;
      this->expression_ = x.expression_;
      this->process_method_call_ = x.process_method_call_;
      this->message_send_ = x.message_send_;
      this->message_receive_ = x.message_receive_;
      this->guard_ = x.guard_;
      this->if__ = x.if__;
      this->while__ = x.while__;
      this->switch__ = x.switch__;
      this->abort_ = x.abort_;
      this->interrupt_ = x.interrupt_;
      this->skip_ = x.skip_;
      this->delay_ = x.delay_;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_statements::
  ~T_statements ()
  {
  }

  // T_statement
  //

  T_statement::
  T_statement ()
  : ::poosl::T_statements ()
  {
  }

  T_statement::
  T_statement (const T_statement& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::poosl::T_statements (x, f, c)
  {
  }

  T_statement::
  T_statement (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::poosl::T_statements (e, f, c)
  {
  }

  T_statement* T_statement::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_statement (*this, f, c);
  }

  T_statement::
  ~T_statement ()
  {
  }

  // T_process_method_call
  //

  T_process_method_call::
  T_process_method_call ()
  : ::xml_schema::Type (),
    argument_ (this),
    return_variable_ (this),
    method_name_ (this),
    stmt_handle_ (this)
  {
  }

  T_process_method_call::
  T_process_method_call (const Method_nameType& method_name)
  : ::xml_schema::Type (),
    argument_ (this),
    return_variable_ (this),
    method_name_ (method_name, this),
    stmt_handle_ (this)
  {
  }

  T_process_method_call::
  T_process_method_call (const T_process_method_call& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    argument_ (x.argument_, f, this),
    return_variable_ (x.return_variable_, f, this),
    method_name_ (x.method_name_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_process_method_call::
  T_process_method_call (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    argument_ (this),
    return_variable_ (this),
    method_name_ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_process_method_call::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ArgumentType > r (
          ArgumentTraits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      // return_variable
      //
      if (n.name () == "return_variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Return_variableType > r (
          Return_variableTraits::create (i, f, this));

        this->return_variable_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "method_name" && n.namespace_ ().empty ())
      {
        this->method_name_.set (Method_nameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }

    if (!method_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "method_name",
        "");
    }
  }

  T_process_method_call* T_process_method_call::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_process_method_call (*this, f, c);
  }

  T_process_method_call& T_process_method_call::
  operator= (const T_process_method_call& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->argument_ = x.argument_;
      this->return_variable_ = x.return_variable_;
      this->method_name_ = x.method_name_;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_process_method_call::
  ~T_process_method_call ()
  {
  }

  // T_initial_process_method_call
  //

  T_initial_process_method_call::
  T_initial_process_method_call ()
  : ::poosl::T_process_method_call ()
  {
  }

  T_initial_process_method_call::
  T_initial_process_method_call (const ::poosl::T_process_method_call& _xsd_T_process_method_call_base)
  : ::poosl::T_process_method_call (_xsd_T_process_method_call_base)
  {
  }

  T_initial_process_method_call::
  T_initial_process_method_call (const Method_nameType& method_name)
  : ::poosl::T_process_method_call (method_name)
  {
  }

  T_initial_process_method_call::
  T_initial_process_method_call (const T_initial_process_method_call& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::poosl::T_process_method_call (x, f, c)
  {
  }

  T_initial_process_method_call::
  T_initial_process_method_call (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::poosl::T_process_method_call (e, f, c)
  {
  }

  T_initial_process_method_call* T_initial_process_method_call::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_initial_process_method_call (*this, f, c);
  }

  T_initial_process_method_call::
  ~T_initial_process_method_call ()
  {
  }

  // T_message_receive
  //

  T_message_receive::
  T_message_receive ()
  : ::xml_schema::Type (),
    variable_ (this),
    condition_ (this),
    atomic_expression_ (this),
    port_ (this),
    message_name_ (this),
    stmt_handle_ (this)
  {
  }

  T_message_receive::
  T_message_receive (const PortType& port)
  : ::xml_schema::Type (),
    variable_ (this),
    condition_ (this),
    atomic_expression_ (this),
    port_ (port, this),
    message_name_ (this),
    stmt_handle_ (this)
  {
  }

  T_message_receive::
  T_message_receive (const T_message_receive& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variable_ (x.variable_, f, this),
    condition_ (x.condition_, f, this),
    atomic_expression_ (x.atomic_expression_, f, this),
    port_ (x.port_, f, this),
    message_name_ (x.message_name_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_message_receive::
  T_message_receive (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variable_ (this),
    condition_ (this),
    atomic_expression_ (this),
    port_ (this),
    message_name_ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_message_receive::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        this->variable_.push_back (::std::move (r));
        continue;
      }

      // condition
      //
      if (n.name () == "condition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ConditionType > r (
          ConditionTraits::create (i, f, this));

        if (!this->condition_)
        {
          this->condition_.set (::std::move (r));
          continue;
        }
      }

      // atomic_expression
      //
      if (n.name () == "atomic_expression" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Atomic_expressionType > r (
          Atomic_expressionTraits::create (i, f, this));

        if (!this->atomic_expression_)
        {
          this->atomic_expression_.set (::std::move (r));
          continue;
        }
      }

      // port
      //
      if (n.name () == "port" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< PortType > r (
          PortTraits::create (i, f, this));

        if (!port_.present ())
        {
          this->port_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "port",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "message_name" && n.namespace_ ().empty ())
      {
        this->message_name_.set (Message_nameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_message_receive* T_message_receive::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_message_receive (*this, f, c);
  }

  T_message_receive& T_message_receive::
  operator= (const T_message_receive& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->variable_ = x.variable_;
      this->condition_ = x.condition_;
      this->atomic_expression_ = x.atomic_expression_;
      this->port_ = x.port_;
      this->message_name_ = x.message_name_;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_message_receive::
  ~T_message_receive ()
  {
  }

  // T_message_send
  //

  T_message_send::
  T_message_send ()
  : ::xml_schema::Type (),
    argument_ (this),
    atomic_expression_ (this),
    port_ (this),
    message_name_ (this),
    stmt_handle_ (this)
  {
  }

  T_message_send::
  T_message_send (const PortType& port)
  : ::xml_schema::Type (),
    argument_ (this),
    atomic_expression_ (this),
    port_ (port, this),
    message_name_ (this),
    stmt_handle_ (this)
  {
  }

  T_message_send::
  T_message_send (const T_message_send& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    argument_ (x.argument_, f, this),
    atomic_expression_ (x.atomic_expression_, f, this),
    port_ (x.port_, f, this),
    message_name_ (x.message_name_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_message_send::
  T_message_send (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    argument_ (this),
    atomic_expression_ (this),
    port_ (this),
    message_name_ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_message_send::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ArgumentType > r (
          ArgumentTraits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      // atomic_expression
      //
      if (n.name () == "atomic_expression" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Atomic_expressionType > r (
          Atomic_expressionTraits::create (i, f, this));

        if (!this->atomic_expression_)
        {
          this->atomic_expression_.set (::std::move (r));
          continue;
        }
      }

      // port
      //
      if (n.name () == "port" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< PortType > r (
          PortTraits::create (i, f, this));

        if (!port_.present ())
        {
          this->port_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "port",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "message_name" && n.namespace_ ().empty ())
      {
        this->message_name_.set (Message_nameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_message_send* T_message_send::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_message_send (*this, f, c);
  }

  T_message_send& T_message_send::
  operator= (const T_message_send& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->argument_ = x.argument_;
      this->atomic_expression_ = x.atomic_expression_;
      this->port_ = x.port_;
      this->message_name_ = x.message_name_;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_message_send::
  ~T_message_send ()
  {
  }

  // T_guard
  //

  T_guard::
  T_guard ()
  : ::xml_schema::Type (),
    expression_ (this),
    statement_ (this),
    stmt_handle_ (this)
  {
  }

  T_guard::
  T_guard (const ExpressionType& expression,
           const StatementType& statement)
  : ::xml_schema::Type (),
    expression_ (expression, this),
    statement_ (statement, this),
    stmt_handle_ (this)
  {
  }

  T_guard::
  T_guard (::std::unique_ptr< ExpressionType > expression,
           ::std::unique_ptr< StatementType > statement)
  : ::xml_schema::Type (),
    expression_ (std::move (expression), this),
    statement_ (std::move (statement), this),
    stmt_handle_ (this)
  {
  }

  T_guard::
  T_guard (const T_guard& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    expression_ (x.expression_, f, this),
    statement_ (x.statement_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_guard::
  T_guard (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    expression_ (this),
    statement_ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_guard::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ExpressionType > r (
          ExpressionTraits::create (i, f, this));

        if (!expression_.present ())
        {
          this->expression_.set (::std::move (r));
          continue;
        }
      }

      // statement
      //
      if (n.name () == "statement" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< StatementType > r (
          StatementTraits::create (i, f, this));

        if (!statement_.present ())
        {
          this->statement_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!expression_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "expression",
        "uri:poosl");
    }

    if (!statement_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "statement",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_guard* T_guard::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_guard (*this, f, c);
  }

  T_guard& T_guard::
  operator= (const T_guard& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->expression_ = x.expression_;
      this->statement_ = x.statement_;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_guard::
  ~T_guard ()
  {
  }

  // T_if_statement
  //

  T_if_statement::
  T_if_statement ()
  : ::xml_schema::Type (),
    condition_ (this),
    then_ (this),
    else__ (this),
    stmt_handle_ (this)
  {
  }

  T_if_statement::
  T_if_statement (const ConditionType& condition,
                  const ThenType& then)
  : ::xml_schema::Type (),
    condition_ (condition, this),
    then_ (then, this),
    else__ (this),
    stmt_handle_ (this)
  {
  }

  T_if_statement::
  T_if_statement (::std::unique_ptr< ConditionType > condition,
                  ::std::unique_ptr< ThenType > then)
  : ::xml_schema::Type (),
    condition_ (std::move (condition), this),
    then_ (std::move (then), this),
    else__ (this),
    stmt_handle_ (this)
  {
  }

  T_if_statement::
  T_if_statement (const T_if_statement& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    condition_ (x.condition_, f, this),
    then_ (x.then_, f, this),
    else__ (x.else__, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_if_statement::
  T_if_statement (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    condition_ (this),
    then_ (this),
    else__ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_if_statement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // condition
      //
      if (n.name () == "condition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ConditionType > r (
          ConditionTraits::create (i, f, this));

        if (!condition_.present ())
        {
          this->condition_.set (::std::move (r));
          continue;
        }
      }

      // then
      //
      if (n.name () == "then" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ThenType > r (
          ThenTraits::create (i, f, this));

        if (!then_.present ())
        {
          this->then_.set (::std::move (r));
          continue;
        }
      }

      // else
      //
      if (n.name () == "else" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ElseType > r (
          ElseTraits::create (i, f, this));

        if (!this->else__)
        {
          this->else__.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!condition_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "condition",
        "uri:poosl");
    }

    if (!then_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "then",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_if_statement* T_if_statement::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_if_statement (*this, f, c);
  }

  T_if_statement& T_if_statement::
  operator= (const T_if_statement& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->condition_ = x.condition_;
      this->then_ = x.then_;
      this->else__ = x.else__;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_if_statement::
  ~T_if_statement ()
  {
  }

  // T_while_statement
  //

  T_while_statement::
  T_while_statement ()
  : ::xml_schema::Type (),
    condition_ (this),
    body_ (this),
    stmt_handle_ (this)
  {
  }

  T_while_statement::
  T_while_statement (const ConditionType& condition,
                     const BodyType& body)
  : ::xml_schema::Type (),
    condition_ (condition, this),
    body_ (body, this),
    stmt_handle_ (this)
  {
  }

  T_while_statement::
  T_while_statement (::std::unique_ptr< ConditionType > condition,
                     ::std::unique_ptr< BodyType > body)
  : ::xml_schema::Type (),
    condition_ (std::move (condition), this),
    body_ (std::move (body), this),
    stmt_handle_ (this)
  {
  }

  T_while_statement::
  T_while_statement (const T_while_statement& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    condition_ (x.condition_, f, this),
    body_ (x.body_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_while_statement::
  T_while_statement (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    condition_ (this),
    body_ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_while_statement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // condition
      //
      if (n.name () == "condition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ConditionType > r (
          ConditionTraits::create (i, f, this));

        if (!condition_.present ())
        {
          this->condition_.set (::std::move (r));
          continue;
        }
      }

      // body
      //
      if (n.name () == "body" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< BodyType > r (
          BodyTraits::create (i, f, this));

        if (!body_.present ())
        {
          this->body_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!condition_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "condition",
        "uri:poosl");
    }

    if (!body_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "body",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_while_statement* T_while_statement::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_while_statement (*this, f, c);
  }

  T_while_statement& T_while_statement::
  operator= (const T_while_statement& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->condition_ = x.condition_;
      this->body_ = x.body_;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_while_statement::
  ~T_while_statement ()
  {
  }

  // T_switch_statement
  //

  T_switch_statement::
  T_switch_statement ()
  : ::xml_schema::Type (),
    control_expression_ (this),
    case__ (this),
    default__ (this),
    stmt_handle_ (this)
  {
  }

  T_switch_statement::
  T_switch_statement (const Control_expressionType& control_expression)
  : ::xml_schema::Type (),
    control_expression_ (control_expression, this),
    case__ (this),
    default__ (this),
    stmt_handle_ (this)
  {
  }

  T_switch_statement::
  T_switch_statement (::std::unique_ptr< Control_expressionType > control_expression)
  : ::xml_schema::Type (),
    control_expression_ (std::move (control_expression), this),
    case__ (this),
    default__ (this),
    stmt_handle_ (this)
  {
  }

  T_switch_statement::
  T_switch_statement (const T_switch_statement& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    control_expression_ (x.control_expression_, f, this),
    case__ (x.case__, f, this),
    default__ (x.default__, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_switch_statement::
  T_switch_statement (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    control_expression_ (this),
    case__ (this),
    default__ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_switch_statement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // control_expression
      //
      if (n.name () == "control_expression" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Control_expressionType > r (
          Control_expressionTraits::create (i, f, this));

        if (!control_expression_.present ())
        {
          this->control_expression_.set (::std::move (r));
          continue;
        }
      }

      // case
      //
      if (n.name () == "case" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< CaseType > r (
          CaseTraits::create (i, f, this));

        this->case__.push_back (::std::move (r));
        continue;
      }

      // default
      //
      if (n.name () == "default" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< DefaultType > r (
          DefaultTraits::create (i, f, this));

        this->default__.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!control_expression_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "control_expression",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_switch_statement* T_switch_statement::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_switch_statement (*this, f, c);
  }

  T_switch_statement& T_switch_statement::
  operator= (const T_switch_statement& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->control_expression_ = x.control_expression_;
      this->case__ = x.case__;
      this->default__ = x.default__;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_switch_statement::
  ~T_switch_statement ()
  {
  }

  // T_switch_case_statement
  //

  T_switch_case_statement::
  T_switch_case_statement ()
  : ::xml_schema::Type (),
    value_expression_ (this),
    body_ (this)
  {
  }

  T_switch_case_statement::
  T_switch_case_statement (const BodyType& body)
  : ::xml_schema::Type (),
    value_expression_ (this),
    body_ (body, this)
  {
  }

  T_switch_case_statement::
  T_switch_case_statement (::std::unique_ptr< BodyType > body)
  : ::xml_schema::Type (),
    value_expression_ (this),
    body_ (std::move (body), this)
  {
  }

  T_switch_case_statement::
  T_switch_case_statement (const T_switch_case_statement& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_expression_ (x.value_expression_, f, this),
    body_ (x.body_, f, this)
  {
  }

  T_switch_case_statement::
  T_switch_case_statement (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_expression_ (this),
    body_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_switch_case_statement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // value_expression
      //
      if (n.name () == "value_expression" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Value_expressionType > r (
          Value_expressionTraits::create (i, f, this));

        this->value_expression_.push_back (::std::move (r));
        continue;
      }

      // body
      //
      if (n.name () == "body" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< BodyType > r (
          BodyTraits::create (i, f, this));

        if (!body_.present ())
        {
          this->body_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!body_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "body",
        "uri:poosl");
    }
  }

  T_switch_case_statement* T_switch_case_statement::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_switch_case_statement (*this, f, c);
  }

  T_switch_case_statement& T_switch_case_statement::
  operator= (const T_switch_case_statement& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->value_expression_ = x.value_expression_;
      this->body_ = x.body_;
    }

    return *this;
  }

  T_switch_case_statement::
  ~T_switch_case_statement ()
  {
  }

  // T_abort
  //

  T_abort::
  T_abort ()
  : ::xml_schema::Type (),
    normal_behavior_ (this),
    aborting_behavior_ (this),
    stmt_handle_ (this)
  {
  }

  T_abort::
  T_abort (const Normal_behaviorType& normal_behavior,
           const Aborting_behaviorType& aborting_behavior)
  : ::xml_schema::Type (),
    normal_behavior_ (normal_behavior, this),
    aborting_behavior_ (aborting_behavior, this),
    stmt_handle_ (this)
  {
  }

  T_abort::
  T_abort (::std::unique_ptr< Normal_behaviorType > normal_behavior,
           ::std::unique_ptr< Aborting_behaviorType > aborting_behavior)
  : ::xml_schema::Type (),
    normal_behavior_ (std::move (normal_behavior), this),
    aborting_behavior_ (std::move (aborting_behavior), this),
    stmt_handle_ (this)
  {
  }

  T_abort::
  T_abort (const T_abort& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    normal_behavior_ (x.normal_behavior_, f, this),
    aborting_behavior_ (x.aborting_behavior_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_abort::
  T_abort (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    normal_behavior_ (this),
    aborting_behavior_ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_abort::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // normal_behavior
      //
      if (n.name () == "normal_behavior" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Normal_behaviorType > r (
          Normal_behaviorTraits::create (i, f, this));

        if (!normal_behavior_.present ())
        {
          this->normal_behavior_.set (::std::move (r));
          continue;
        }
      }

      // aborting_behavior
      //
      if (n.name () == "aborting_behavior" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Aborting_behaviorType > r (
          Aborting_behaviorTraits::create (i, f, this));

        if (!aborting_behavior_.present ())
        {
          this->aborting_behavior_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!normal_behavior_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "normal_behavior",
        "uri:poosl");
    }

    if (!aborting_behavior_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "aborting_behavior",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_abort* T_abort::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_abort (*this, f, c);
  }

  T_abort& T_abort::
  operator= (const T_abort& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->normal_behavior_ = x.normal_behavior_;
      this->aborting_behavior_ = x.aborting_behavior_;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_abort::
  ~T_abort ()
  {
  }

  // T_interrupt
  //

  T_interrupt::
  T_interrupt ()
  : ::xml_schema::Type (),
    normal_behavior_ (this),
    interrupting_behavior_ (this),
    stmt_handle_ (this)
  {
  }

  T_interrupt::
  T_interrupt (const Normal_behaviorType& normal_behavior,
               const Interrupting_behaviorType& interrupting_behavior)
  : ::xml_schema::Type (),
    normal_behavior_ (normal_behavior, this),
    interrupting_behavior_ (interrupting_behavior, this),
    stmt_handle_ (this)
  {
  }

  T_interrupt::
  T_interrupt (::std::unique_ptr< Normal_behaviorType > normal_behavior,
               ::std::unique_ptr< Interrupting_behaviorType > interrupting_behavior)
  : ::xml_schema::Type (),
    normal_behavior_ (std::move (normal_behavior), this),
    interrupting_behavior_ (std::move (interrupting_behavior), this),
    stmt_handle_ (this)
  {
  }

  T_interrupt::
  T_interrupt (const T_interrupt& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    normal_behavior_ (x.normal_behavior_, f, this),
    interrupting_behavior_ (x.interrupting_behavior_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_interrupt::
  T_interrupt (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    normal_behavior_ (this),
    interrupting_behavior_ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_interrupt::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // normal_behavior
      //
      if (n.name () == "normal_behavior" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Normal_behaviorType > r (
          Normal_behaviorTraits::create (i, f, this));

        if (!normal_behavior_.present ())
        {
          this->normal_behavior_.set (::std::move (r));
          continue;
        }
      }

      // interrupting_behavior
      //
      if (n.name () == "interrupting_behavior" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Interrupting_behaviorType > r (
          Interrupting_behaviorTraits::create (i, f, this));

        if (!interrupting_behavior_.present ())
        {
          this->interrupting_behavior_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!normal_behavior_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "normal_behavior",
        "uri:poosl");
    }

    if (!interrupting_behavior_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "interrupting_behavior",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_interrupt* T_interrupt::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_interrupt (*this, f, c);
  }

  T_interrupt& T_interrupt::
  operator= (const T_interrupt& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->normal_behavior_ = x.normal_behavior_;
      this->interrupting_behavior_ = x.interrupting_behavior_;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_interrupt::
  ~T_interrupt ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace poosl
{
  ::std::ostream&
  operator<< (::std::ostream& o, T_constant_type::Value i)
  {
    return o << T_constant_type::_xsd_T_constant_type_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_constant_type& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_binary_operator::Value i)
  {
    return o << T_binary_operator::_xsd_T_binary_operator_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_binary_operator& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_unary_operator::Value i)
  {
    return o << T_unary_operator::_xsd_T_unary_operator_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_unary_operator& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_expressions& i)
  {
    for (T_expressions::Sequence_of_expressionsConstIterator
         b (i.getSequence_of_expressions ().begin ()), e (i.getSequence_of_expressions ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "sequence_of_expressions: " << *b;
    }

    for (T_expressions::AssignmentConstIterator
         b (i.getAssignment ().begin ()), e (i.getAssignment ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "assignment: " << *b;
    }

    for (T_expressions::Data_method_callConstIterator
         b (i.getData_method_call ().begin ()), e (i.getData_method_call ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "data_method_call: " << *b;
    }

    for (T_expressions::ConstantConstIterator
         b (i.getConstant ().begin ()), e (i.getConstant ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "constant: " << *b;
    }

    for (T_expressions::VariableConstIterator
         b (i.getVariable ().begin ()), e (i.getVariable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variable: " << *b;
    }

    for (T_expressions::Binary_operationConstIterator
         b (i.getBinary_operation ().begin ()), e (i.getBinary_operation ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "binary_operation: " << *b;
    }

    for (T_expressions::Unary_operationConstIterator
         b (i.getUnary_operation ().begin ()), e (i.getUnary_operation ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "unary_operation: " << *b;
    }

    for (T_expressions::SelfConstIterator
         b (i.getSelf ().begin ()), e (i.getSelf ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "self: " << *b;
    }

    for (T_expressions::NilConstIterator
         b (i.getNil ().begin ()), e (i.getNil ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "nil: " << *b;
    }

    for (T_expressions::Current_timeConstIterator
         b (i.getCurrent_time ().begin ()), e (i.getCurrent_time ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "current_time: " << *b;
    }

    for (T_expressions::IfConstIterator
         b (i.getIf ().begin ()), e (i.getIf ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "if: " << *b;
    }

    for (T_expressions::WhileConstIterator
         b (i.getWhile ().begin ()), e (i.getWhile ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "while: " << *b;
    }

    for (T_expressions::NewConstIterator
         b (i.getNew ().begin ()), e (i.getNew ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "new: " << *b;
    }

    for (T_expressions::ReturnConstIterator
         b (i.getReturn ().begin ()), e (i.getReturn ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "return: " << *b;
    }

    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_expression& i)
  {
    o << static_cast< const ::poosl::T_expressions& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_assignment& i)
  {
    o << static_cast< const ::poosl::T_expression& > (i);

    o << ::std::endl << "variable_name: " << i.getVariable_name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_data_method_call& i)
  {
    o << ::std::endl << "receiver: " << i.getReceiver ();
    for (T_data_method_call::ArgumentConstIterator
         b (i.getArgument ().begin ()), e (i.getArgument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    o << ::std::endl << "method_name: " << i.getMethod_name ();
    o << ::std::endl << "super: " << i.getSuper ();
    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_constant& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    if (i.getType ())
    {
      o << ::std::endl << "type: " << *i.getType ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_current_time&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_variable_ref& i)
  {
    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_binary_operation& i)
  {
    o << ::std::endl << "left_operand: " << i.getLeft_operand ();
    o << ::std::endl << "right_operand: " << i.getRight_operand ();
    if (i.getOperator ())
    {
      o << ::std::endl << "operator: " << *i.getOperator ();
    }

    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_unary_operation& i)
  {
    o << ::std::endl << "operand: " << i.getOperand ();
    if (i.getOperator ())
    {
      o << ::std::endl << "operator: " << *i.getOperator ();
    }

    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_if_expression& i)
  {
    o << ::std::endl << "condition: " << i.getCondition ();
    o << ::std::endl << "then: " << i.getThen ();
    if (i.getElse ())
    {
      o << ::std::endl << "else: " << *i.getElse ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_while_expression& i)
  {
    o << ::std::endl << "condition: " << i.getCondition ();
    o << ::std::endl << "body: " << i.getBody ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_object_creation& i)
  {
    if (i.getData_class ())
    {
      o << ::std::endl << "data_class: " << *i.getData_class ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_statements& i)
  {
    for (T_statements::Sequence_of_statementsConstIterator
         b (i.getSequence_of_statements ().begin ()), e (i.getSequence_of_statements ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "sequence_of_statements: " << *b;
    }

    for (T_statements::Parallel_statementsConstIterator
         b (i.getParallel_statements ().begin ()), e (i.getParallel_statements ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "parallel_statements: " << *b;
    }

    for (T_statements::Select_statementsConstIterator
         b (i.getSelect_statements ().begin ()), e (i.getSelect_statements ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "select_statements: " << *b;
    }

    for (T_statements::ExpressionConstIterator
         b (i.getExpression ().begin ()), e (i.getExpression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expression: " << *b;
    }

    for (T_statements::Process_method_callConstIterator
         b (i.getProcess_method_call ().begin ()), e (i.getProcess_method_call ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "process_method_call: " << *b;
    }

    for (T_statements::Message_sendConstIterator
         b (i.getMessage_send ().begin ()), e (i.getMessage_send ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "message_send: " << *b;
    }

    for (T_statements::Message_receiveConstIterator
         b (i.getMessage_receive ().begin ()), e (i.getMessage_receive ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "message_receive: " << *b;
    }

    for (T_statements::GuardConstIterator
         b (i.getGuard ().begin ()), e (i.getGuard ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "guard: " << *b;
    }

    for (T_statements::IfConstIterator
         b (i.getIf ().begin ()), e (i.getIf ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "if: " << *b;
    }

    for (T_statements::WhileConstIterator
         b (i.getWhile ().begin ()), e (i.getWhile ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "while: " << *b;
    }

    for (T_statements::SwitchConstIterator
         b (i.getSwitch ().begin ()), e (i.getSwitch ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "switch: " << *b;
    }

    for (T_statements::AbortConstIterator
         b (i.getAbort ().begin ()), e (i.getAbort ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "abort: " << *b;
    }

    for (T_statements::InterruptConstIterator
         b (i.getInterrupt ().begin ()), e (i.getInterrupt ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "interrupt: " << *b;
    }

    for (T_statements::SkipConstIterator
         b (i.getSkip ().begin ()), e (i.getSkip ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "skip: " << *b;
    }

    for (T_statements::DelayConstIterator
         b (i.getDelay ().begin ()), e (i.getDelay ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "delay: " << *b;
    }

    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_statement& i)
  {
    o << static_cast< const ::poosl::T_statements& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_process_method_call& i)
  {
    for (T_process_method_call::ArgumentConstIterator
         b (i.getArgument ().begin ()), e (i.getArgument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    for (T_process_method_call::Return_variableConstIterator
         b (i.getReturn_variable ().begin ()), e (i.getReturn_variable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "return_variable: " << *b;
    }

    o << ::std::endl << "method_name: " << i.getMethod_name ();
    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_initial_process_method_call& i)
  {
    o << static_cast< const ::poosl::T_process_method_call& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_message_receive& i)
  {
    for (T_message_receive::VariableConstIterator
         b (i.getVariable ().begin ()), e (i.getVariable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variable: " << *b;
    }

    if (i.getCondition ())
    {
      o << ::std::endl << "condition: " << *i.getCondition ();
    }

    if (i.getAtomic_expression ())
    {
      o << ::std::endl << "atomic_expression: " << *i.getAtomic_expression ();
    }

    o << ::std::endl << "port: " << i.getPort ();
    if (i.getMessage_name ())
    {
      o << ::std::endl << "message_name: " << *i.getMessage_name ();
    }

    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_message_send& i)
  {
    for (T_message_send::ArgumentConstIterator
         b (i.getArgument ().begin ()), e (i.getArgument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    if (i.getAtomic_expression ())
    {
      o << ::std::endl << "atomic_expression: " << *i.getAtomic_expression ();
    }

    o << ::std::endl << "port: " << i.getPort ();
    if (i.getMessage_name ())
    {
      o << ::std::endl << "message_name: " << *i.getMessage_name ();
    }

    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_guard& i)
  {
    o << ::std::endl << "expression: " << i.getExpression ();
    o << ::std::endl << "statement: " << i.getStatement ();
    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_if_statement& i)
  {
    o << ::std::endl << "condition: " << i.getCondition ();
    o << ::std::endl << "then: " << i.getThen ();
    if (i.getElse ())
    {
      o << ::std::endl << "else: " << *i.getElse ();
    }

    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_while_statement& i)
  {
    o << ::std::endl << "condition: " << i.getCondition ();
    o << ::std::endl << "body: " << i.getBody ();
    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_switch_statement& i)
  {
    o << ::std::endl << "control_expression: " << i.getControl_expression ();
    for (T_switch_statement::CaseConstIterator
         b (i.getCase ().begin ()), e (i.getCase ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "case: " << *b;
    }

    for (T_switch_statement::DefaultConstIterator
         b (i.getDefault ().begin ()), e (i.getDefault ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "default: " << *b;
    }

    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_switch_case_statement& i)
  {
    for (T_switch_case_statement::Value_expressionConstIterator
         b (i.getValue_expression ().begin ()), e (i.getValue_expression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "value_expression: " << *b;
    }

    o << ::std::endl << "body: " << i.getBody ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_abort& i)
  {
    o << ::std::endl << "normal_behavior: " << i.getNormal_behavior ();
    o << ::std::endl << "aborting_behavior: " << i.getAborting_behavior ();
    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_interrupt& i)
  {
    o << ::std::endl << "normal_behavior: " << i.getNormal_behavior ();
    o << ::std::endl << "interrupting_behavior: " << i.getInterrupting_behavior ();
    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace poosl
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace poosl
{
  void
  operator<< (::xercesc::DOMElement& e, const T_constant_type& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_constant_type& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_constant_type& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_binary_operator& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_binary_operator& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_binary_operator& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_unary_operator& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_unary_operator& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_unary_operator& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_expressions& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // sequence_of_expressions
    //
    for (T_expressions::Sequence_of_expressionsConstIterator
         b (i.getSequence_of_expressions ().begin ()), n (i.getSequence_of_expressions ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sequence_of_expressions",
          "uri:poosl",
          e));

      s << *b;
    }

    // assignment
    //
    for (T_expressions::AssignmentConstIterator
         b (i.getAssignment ().begin ()), n (i.getAssignment ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "assignment",
          "uri:poosl",
          e));

      s << *b;
    }

    // data_method_call
    //
    for (T_expressions::Data_method_callConstIterator
         b (i.getData_method_call ().begin ()), n (i.getData_method_call ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data_method_call",
          "uri:poosl",
          e));

      s << *b;
    }

    // constant
    //
    for (T_expressions::ConstantConstIterator
         b (i.getConstant ().begin ()), n (i.getConstant ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constant",
          "uri:poosl",
          e));

      s << *b;
    }

    // variable
    //
    for (T_expressions::VariableConstIterator
         b (i.getVariable ().begin ()), n (i.getVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "uri:poosl",
          e));

      s << *b;
    }

    // binary_operation
    //
    for (T_expressions::Binary_operationConstIterator
         b (i.getBinary_operation ().begin ()), n (i.getBinary_operation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "binary_operation",
          "uri:poosl",
          e));

      s << *b;
    }

    // unary_operation
    //
    for (T_expressions::Unary_operationConstIterator
         b (i.getUnary_operation ().begin ()), n (i.getUnary_operation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "unary_operation",
          "uri:poosl",
          e));

      s << *b;
    }

    // self
    //
    for (T_expressions::SelfConstIterator
         b (i.getSelf ().begin ()), n (i.getSelf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "self",
          "uri:poosl",
          e));

      s << *b;
    }

    // nil
    //
    for (T_expressions::NilConstIterator
         b (i.getNil ().begin ()), n (i.getNil ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nil",
          "uri:poosl",
          e));

      s << *b;
    }

    // current_time
    //
    for (T_expressions::Current_timeConstIterator
         b (i.getCurrent_time ().begin ()), n (i.getCurrent_time ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "current_time",
          "uri:poosl",
          e));

      s << *b;
    }

    // if
    //
    for (T_expressions::IfConstIterator
         b (i.getIf ().begin ()), n (i.getIf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "if",
          "uri:poosl",
          e));

      s << *b;
    }

    // while
    //
    for (T_expressions::WhileConstIterator
         b (i.getWhile ().begin ()), n (i.getWhile ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "while",
          "uri:poosl",
          e));

      s << *b;
    }

    // new
    //
    for (T_expressions::NewConstIterator
         b (i.getNew ().begin ()), n (i.getNew ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "new",
          "uri:poosl",
          e));

      s << *b;
    }

    // return
    //
    for (T_expressions::ReturnConstIterator
         b (i.getReturn ().begin ()), n (i.getReturn ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "return",
          "uri:poosl",
          e));

      s << *b;
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_expression& i)
  {
    e << static_cast< const ::poosl::T_expressions& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_assignment& i)
  {
    e << static_cast< const ::poosl::T_expression& > (i);

    // variable_name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "variable_name",
          e));

      a << i.getVariable_name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_data_method_call& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // receiver
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "receiver",
          "uri:poosl",
          e));

      s << i.getReceiver ();
    }

    // argument
    //
    for (T_data_method_call::ArgumentConstIterator
         b (i.getArgument ().begin ()), n (i.getArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "uri:poosl",
          e));

      s << *b;
    }

    // method_name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "method_name",
          e));

      a << i.getMethod_name ();
    }

    // super
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "super",
          e));

      a << i.getSuper ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_constant& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);

    // type
    //
    if (i.getType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.getType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_current_time& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const T_current_time&)
  {
  }

  void
  operator<< (::xml_schema::ListStream&,
              const T_current_time&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_variable_ref& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_binary_operation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // left_operand
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "left_operand",
          "uri:poosl",
          e));

      s << i.getLeft_operand ();
    }

    // right_operand
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "right_operand",
          "uri:poosl",
          e));

      s << i.getRight_operand ();
    }

    // operator
    //
    if (i.getOperator ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "operator",
          e));

      a << *i.getOperator ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_unary_operation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // operand
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "operand",
          "uri:poosl",
          e));

      s << i.getOperand ();
    }

    // operator
    //
    if (i.getOperator ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "operator",
          e));

      a << *i.getOperator ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_if_expression& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // condition
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "condition",
          "uri:poosl",
          e));

      s << i.getCondition ();
    }

    // then
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "then",
          "uri:poosl",
          e));

      s << i.getThen ();
    }

    // else
    //
    if (i.getElse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "else",
          "uri:poosl",
          e));

      s << *i.getElse ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_while_expression& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // condition
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "condition",
          "uri:poosl",
          e));

      s << i.getCondition ();
    }

    // body
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body",
          "uri:poosl",
          e));

      s << i.getBody ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_object_creation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // data_class
    //
    if (i.getData_class ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "data_class",
          e));

      a << *i.getData_class ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_statements& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // sequence_of_statements
    //
    for (T_statements::Sequence_of_statementsConstIterator
         b (i.getSequence_of_statements ().begin ()), n (i.getSequence_of_statements ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sequence_of_statements",
          "uri:poosl",
          e));

      s << *b;
    }

    // parallel_statements
    //
    for (T_statements::Parallel_statementsConstIterator
         b (i.getParallel_statements ().begin ()), n (i.getParallel_statements ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parallel_statements",
          "uri:poosl",
          e));

      s << *b;
    }

    // select_statements
    //
    for (T_statements::Select_statementsConstIterator
         b (i.getSelect_statements ().begin ()), n (i.getSelect_statements ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "select_statements",
          "uri:poosl",
          e));

      s << *b;
    }

    // expression
    //
    for (T_statements::ExpressionConstIterator
         b (i.getExpression ().begin ()), n (i.getExpression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "uri:poosl",
          e));

      s << *b;
    }

    // process_method_call
    //
    for (T_statements::Process_method_callConstIterator
         b (i.getProcess_method_call ().begin ()), n (i.getProcess_method_call ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_method_call",
          "uri:poosl",
          e));

      s << *b;
    }

    // message_send
    //
    for (T_statements::Message_sendConstIterator
         b (i.getMessage_send ().begin ()), n (i.getMessage_send ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "message_send",
          "uri:poosl",
          e));

      s << *b;
    }

    // message_receive
    //
    for (T_statements::Message_receiveConstIterator
         b (i.getMessage_receive ().begin ()), n (i.getMessage_receive ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "message_receive",
          "uri:poosl",
          e));

      s << *b;
    }

    // guard
    //
    for (T_statements::GuardConstIterator
         b (i.getGuard ().begin ()), n (i.getGuard ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "guard",
          "uri:poosl",
          e));

      s << *b;
    }

    // if
    //
    for (T_statements::IfConstIterator
         b (i.getIf ().begin ()), n (i.getIf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "if",
          "uri:poosl",
          e));

      s << *b;
    }

    // while
    //
    for (T_statements::WhileConstIterator
         b (i.getWhile ().begin ()), n (i.getWhile ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "while",
          "uri:poosl",
          e));

      s << *b;
    }

    // switch
    //
    for (T_statements::SwitchConstIterator
         b (i.getSwitch ().begin ()), n (i.getSwitch ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "switch",
          "uri:poosl",
          e));

      s << *b;
    }

    // abort
    //
    for (T_statements::AbortConstIterator
         b (i.getAbort ().begin ()), n (i.getAbort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "abort",
          "uri:poosl",
          e));

      s << *b;
    }

    // interrupt
    //
    for (T_statements::InterruptConstIterator
         b (i.getInterrupt ().begin ()), n (i.getInterrupt ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interrupt",
          "uri:poosl",
          e));

      s << *b;
    }

    // skip
    //
    for (T_statements::SkipConstIterator
         b (i.getSkip ().begin ()), n (i.getSkip ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "skip",
          "uri:poosl",
          e));

      s << *b;
    }

    // delay
    //
    for (T_statements::DelayConstIterator
         b (i.getDelay ().begin ()), n (i.getDelay ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "delay",
          "uri:poosl",
          e));

      s << *b;
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_statement& i)
  {
    e << static_cast< const ::poosl::T_statements& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_process_method_call& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // argument
    //
    for (T_process_method_call::ArgumentConstIterator
         b (i.getArgument ().begin ()), n (i.getArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "uri:poosl",
          e));

      s << *b;
    }

    // return_variable
    //
    for (T_process_method_call::Return_variableConstIterator
         b (i.getReturn_variable ().begin ()), n (i.getReturn_variable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "return_variable",
          "uri:poosl",
          e));

      s << *b;
    }

    // method_name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "method_name",
          e));

      a << i.getMethod_name ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_initial_process_method_call& i)
  {
    e << static_cast< const ::poosl::T_process_method_call& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_message_receive& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variable
    //
    for (T_message_receive::VariableConstIterator
         b (i.getVariable ().begin ()), n (i.getVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "uri:poosl",
          e));

      s << *b;
    }

    // condition
    //
    if (i.getCondition ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "condition",
          "uri:poosl",
          e));

      s << *i.getCondition ();
    }

    // atomic_expression
    //
    if (i.getAtomic_expression ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "atomic_expression",
          "uri:poosl",
          e));

      s << *i.getAtomic_expression ();
    }

    // port
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "port",
          "uri:poosl",
          e));

      s << i.getPort ();
    }

    // message_name
    //
    if (i.getMessage_name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "message_name",
          e));

      a << *i.getMessage_name ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_message_send& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // argument
    //
    for (T_message_send::ArgumentConstIterator
         b (i.getArgument ().begin ()), n (i.getArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "uri:poosl",
          e));

      s << *b;
    }

    // atomic_expression
    //
    if (i.getAtomic_expression ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "atomic_expression",
          "uri:poosl",
          e));

      s << *i.getAtomic_expression ();
    }

    // port
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "port",
          "uri:poosl",
          e));

      s << i.getPort ();
    }

    // message_name
    //
    if (i.getMessage_name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "message_name",
          e));

      a << *i.getMessage_name ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_guard& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // expression
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "uri:poosl",
          e));

      s << i.getExpression ();
    }

    // statement
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "statement",
          "uri:poosl",
          e));

      s << i.getStatement ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_if_statement& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // condition
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "condition",
          "uri:poosl",
          e));

      s << i.getCondition ();
    }

    // then
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "then",
          "uri:poosl",
          e));

      s << i.getThen ();
    }

    // else
    //
    if (i.getElse ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "else",
          "uri:poosl",
          e));

      s << *i.getElse ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_while_statement& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // condition
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "condition",
          "uri:poosl",
          e));

      s << i.getCondition ();
    }

    // body
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body",
          "uri:poosl",
          e));

      s << i.getBody ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_switch_statement& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // control_expression
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "control_expression",
          "uri:poosl",
          e));

      s << i.getControl_expression ();
    }

    // case
    //
    for (T_switch_statement::CaseConstIterator
         b (i.getCase ().begin ()), n (i.getCase ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "case",
          "uri:poosl",
          e));

      s << *b;
    }

    // default
    //
    for (T_switch_statement::DefaultConstIterator
         b (i.getDefault ().begin ()), n (i.getDefault ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "default",
          "uri:poosl",
          e));

      s << *b;
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_switch_case_statement& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // value_expression
    //
    for (T_switch_case_statement::Value_expressionConstIterator
         b (i.getValue_expression ().begin ()), n (i.getValue_expression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value_expression",
          "uri:poosl",
          e));

      s << *b;
    }

    // body
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body",
          "uri:poosl",
          e));

      s << i.getBody ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_abort& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // normal_behavior
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "normal_behavior",
          "uri:poosl",
          e));

      s << i.getNormal_behavior ();
    }

    // aborting_behavior
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "aborting_behavior",
          "uri:poosl",
          e));

      s << i.getAborting_behavior ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_interrupt& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // normal_behavior
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "normal_behavior",
          "uri:poosl",
          e));

      s << i.getNormal_behavior ();
    }

    // interrupting_behavior
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interrupting_behavior",
          "uri:poosl",
          e));

      s << i.getInterrupting_behavior ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

