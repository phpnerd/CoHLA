// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rotalumisresponse.hxx"

namespace poosl
{
  // T_load_response
  // 

  const T_load_response::ResultType& T_load_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_load_response::ResultType& T_load_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_load_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_load_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }

  const T_load_response::ErrorType& T_load_response::
  getError () const
  {
    return this->error_.get ();
  }

  T_load_response::ErrorType& T_load_response::
  getError ()
  {
    return this->error_.get ();
  }

  void T_load_response::
  setError (const ErrorType& x)
  {
    this->error_.set (x);
  }

  void T_load_response::
  setError (::std::unique_ptr< ErrorType > x)
  {
    this->error_.set (std::move (x));
  }

  const T_load_response::ContentsType& T_load_response::
  getContents () const
  {
    return this->contents_.get ();
  }

  T_load_response::ContentsType& T_load_response::
  getContents ()
  {
    return this->contents_.get ();
  }

  void T_load_response::
  setContents (const ContentsType& x)
  {
    this->contents_.set (x);
  }

  void T_load_response::
  setContents (::std::unique_ptr< ContentsType > x)
  {
    this->contents_.set (std::move (x));
  }


  // T_save_response
  // 

  const T_save_response::ResultType& T_save_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_save_response::ResultType& T_save_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_save_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_save_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }

  const T_save_response::ErrorType& T_save_response::
  getError () const
  {
    return this->error_.get ();
  }

  T_save_response::ErrorType& T_save_response::
  getError ()
  {
    return this->error_.get ();
  }

  void T_save_response::
  setError (const ErrorType& x)
  {
    this->error_.set (x);
  }

  void T_save_response::
  setError (::std::unique_ptr< ErrorType > x)
  {
    this->error_.set (std::move (x));
  }


  // T_file_io_result
  // 

  T_file_io_result::
  T_file_io_result ()
  : ::xml_schema::String ()
  {
  }

  T_file_io_result::
  T_file_io_result (Value v)
  : ::xml_schema::String (_xsd_T_file_io_result_literals_[v])
  {
  }

  T_file_io_result::
  T_file_io_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_file_io_result::
  T_file_io_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_file_io_result::
  T_file_io_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_file_io_result::
  T_file_io_result (const T_file_io_result& v,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_file_io_result& T_file_io_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_file_io_result_literals_[v]);

    return *this;
  }


  // T_serialize_response
  // 

  const T_serialize_response::ResultType& T_serialize_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_serialize_response::ResultType& T_serialize_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_serialize_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_serialize_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }

  const T_serialize_response::ContentsType& T_serialize_response::
  getContents () const
  {
    return this->contents_.get ();
  }

  T_serialize_response::ContentsType& T_serialize_response::
  getContents ()
  {
    return this->contents_.get ();
  }

  void T_serialize_response::
  setContents (const ContentsType& x)
  {
    this->contents_.set (x);
  }

  void T_serialize_response::
  setContents (::std::unique_ptr< ContentsType > x)
  {
    this->contents_.set (std::move (x));
  }


  // T_deserialize_response
  // 

  const T_deserialize_response::ErrorType& T_deserialize_response::
  getError () const
  {
    return this->error_.get ();
  }

  T_deserialize_response::ErrorType& T_deserialize_response::
  getError ()
  {
    return this->error_.get ();
  }

  void T_deserialize_response::
  setError (const ErrorType& x)
  {
    this->error_.set (x);
  }

  void T_deserialize_response::
  setError (::std::unique_ptr< ErrorType > x)
  {
    this->error_.set (std::move (x));
  }

  const T_deserialize_response::HandleType& T_deserialize_response::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_deserialize_response::HandleType& T_deserialize_response::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_deserialize_response::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }


  // T_compile_response
  // 

  const T_compile_response::ErrorType& T_compile_response::
  getError () const
  {
    return this->error_.get ();
  }

  T_compile_response::ErrorType& T_compile_response::
  getError ()
  {
    return this->error_.get ();
  }

  void T_compile_response::
  setError (const ErrorType& x)
  {
    this->error_.set (x);
  }

  void T_compile_response::
  setError (::std::unique_ptr< ErrorType > x)
  {
    this->error_.set (std::move (x));
  }

  const T_compile_response::HandleType& T_compile_response::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_compile_response::HandleType& T_compile_response::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_compile_response::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }


  // T_serialize_result
  // 

  T_serialize_result::
  T_serialize_result ()
  : ::xml_schema::String ()
  {
  }

  T_serialize_result::
  T_serialize_result (Value v)
  : ::xml_schema::String (_xsd_T_serialize_result_literals_[v])
  {
  }

  T_serialize_result::
  T_serialize_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_serialize_result::
  T_serialize_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_serialize_result::
  T_serialize_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_serialize_result::
  T_serialize_result (const T_serialize_result& v,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_serialize_result& T_serialize_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_serialize_result_literals_[v]);

    return *this;
  }


  // T_parse_result
  // 

  T_parse_result::
  T_parse_result ()
  : ::xml_schema::String ()
  {
  }

  T_parse_result::
  T_parse_result (Value v)
  : ::xml_schema::String (_xsd_T_parse_result_literals_[v])
  {
  }

  T_parse_result::
  T_parse_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_parse_result::
  T_parse_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_parse_result::
  T_parse_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_parse_result::
  T_parse_result (const T_parse_result& v,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_parse_result& T_parse_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_parse_result_literals_[v]);

    return *this;
  }


  // T_list_classes_response
  // 

  const T_list_classes_response::Class_nameSequence& T_list_classes_response::
  getClass_name () const
  {
    return this->class_name_;
  }

  T_list_classes_response::Class_nameSequence& T_list_classes_response::
  getClass_name ()
  {
    return this->class_name_;
  }

  void T_list_classes_response::
  setClass_name (const Class_nameSequence& s)
  {
    this->class_name_ = s;
  }

  const T_list_classes_response::HandleSequence& T_list_classes_response::
  getHandle () const
  {
    return this->handle_;
  }

  T_list_classes_response::HandleSequence& T_list_classes_response::
  getHandle ()
  {
    return this->handle_;
  }

  void T_list_classes_response::
  setHandle (const HandleSequence& s)
  {
    this->handle_ = s;
  }


  // T_list_files_response
  // 

  const T_list_files_response::FileSequence& T_list_files_response::
  getFile () const
  {
    return this->file_;
  }

  T_list_files_response::FileSequence& T_list_files_response::
  getFile ()
  {
    return this->file_;
  }

  void T_list_files_response::
  setFile (const FileSequence& s)
  {
    this->file_ = s;
  }


  // T_get_position_response
  // 

  const T_get_position_response::Stmt_handleType& T_get_position_response::
  getStmt_handle () const
  {
    return this->stmt_handle_.get ();
  }

  T_get_position_response::Stmt_handleType& T_get_position_response::
  getStmt_handle ()
  {
    return this->stmt_handle_.get ();
  }

  void T_get_position_response::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  const T_get_position_response::BeginType& T_get_position_response::
  getBegin () const
  {
    return this->begin_.get ();
  }

  T_get_position_response::BeginType& T_get_position_response::
  getBegin ()
  {
    return this->begin_.get ();
  }

  void T_get_position_response::
  setBegin (const BeginType& x)
  {
    this->begin_.set (x);
  }

  void T_get_position_response::
  setBegin (::std::unique_ptr< BeginType > x)
  {
    this->begin_.set (std::move (x));
  }

  const T_get_position_response::EndType& T_get_position_response::
  getEnd () const
  {
    return this->end_.get ();
  }

  T_get_position_response::EndType& T_get_position_response::
  getEnd ()
  {
    return this->end_.get ();
  }

  void T_get_position_response::
  setEnd (const EndType& x)
  {
    this->end_.set (x);
  }

  void T_get_position_response::
  setEnd (::std::unique_ptr< EndType > x)
  {
    this->end_.set (std::move (x));
  }


  // T_get_top_level_specification_response
  // 

  const T_get_top_level_specification_response::ResultType& T_get_top_level_specification_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_get_top_level_specification_response::ResultType& T_get_top_level_specification_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_get_top_level_specification_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_get_top_level_specification_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }

  const T_get_top_level_specification_response::Class_nameType& T_get_top_level_specification_response::
  getClass_name () const
  {
    return this->class_name_.get ();
  }

  T_get_top_level_specification_response::Class_nameType& T_get_top_level_specification_response::
  getClass_name ()
  {
    return this->class_name_.get ();
  }

  void T_get_top_level_specification_response::
  setClass_name (const Class_nameType& x)
  {
    this->class_name_.set (x);
  }

  void T_get_top_level_specification_response::
  setClass_name (::std::unique_ptr< Class_nameType > x)
  {
    this->class_name_.set (std::move (x));
  }

  const T_get_top_level_specification_response::HandleType& T_get_top_level_specification_response::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_get_top_level_specification_response::HandleType& T_get_top_level_specification_response::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_get_top_level_specification_response::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }


  // T_get_class_definition_response
  // 

  const T_get_class_definition_response::ResultType& T_get_class_definition_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_get_class_definition_response::ResultType& T_get_class_definition_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_get_class_definition_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_get_class_definition_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }

  const T_get_class_definition_response::Cluster_classOptional& T_get_class_definition_response::
  getCluster_class () const
  {
    return this->cluster_class_;
  }

  T_get_class_definition_response::Cluster_classOptional& T_get_class_definition_response::
  getCluster_class ()
  {
    return this->cluster_class_;
  }

  void T_get_class_definition_response::
  setCluster_class (const Cluster_classType& x)
  {
    this->cluster_class_.set (x);
  }

  void T_get_class_definition_response::
  setCluster_class (const Cluster_classOptional& x)
  {
    this->cluster_class_ = x;
  }

  void T_get_class_definition_response::
  setCluster_class (::std::unique_ptr< Cluster_classType > x)
  {
    this->cluster_class_.set (std::move (x));
  }

  const T_get_class_definition_response::Process_classOptional& T_get_class_definition_response::
  getProcess_class () const
  {
    return this->process_class_;
  }

  T_get_class_definition_response::Process_classOptional& T_get_class_definition_response::
  getProcess_class ()
  {
    return this->process_class_;
  }

  void T_get_class_definition_response::
  setProcess_class (const Process_classType& x)
  {
    this->process_class_.set (x);
  }

  void T_get_class_definition_response::
  setProcess_class (const Process_classOptional& x)
  {
    this->process_class_ = x;
  }

  void T_get_class_definition_response::
  setProcess_class (::std::unique_ptr< Process_classType > x)
  {
    this->process_class_.set (std::move (x));
  }

  const T_get_class_definition_response::Data_classOptional& T_get_class_definition_response::
  getData_class () const
  {
    return this->data_class_;
  }

  T_get_class_definition_response::Data_classOptional& T_get_class_definition_response::
  getData_class ()
  {
    return this->data_class_;
  }

  void T_get_class_definition_response::
  setData_class (const Data_classType& x)
  {
    this->data_class_.set (x);
  }

  void T_get_class_definition_response::
  setData_class (const Data_classOptional& x)
  {
    this->data_class_ = x;
  }

  void T_get_class_definition_response::
  setData_class (::std::unique_ptr< Data_classType > x)
  {
    this->data_class_.set (std::move (x));
  }


  // T_cluster_class_def
  // 

  const T_cluster_class_def::ClassType& T_cluster_class_def::
  getClass () const
  {
    return this->class__.get ();
  }

  T_cluster_class_def::ClassType& T_cluster_class_def::
  getClass ()
  {
    return this->class__.get ();
  }

  void T_cluster_class_def::
  setClass (const ClassType& x)
  {
    this->class__.set (x);
  }

  void T_cluster_class_def::
  setClass (::std::unique_ptr< ClassType > x)
  {
    this->class__.set (std::move (x));
  }

  const T_cluster_class_def::HandleType& T_cluster_class_def::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_cluster_class_def::HandleType& T_cluster_class_def::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_cluster_class_def::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  const T_cluster_class_def::Instatiation_parametersType& T_cluster_class_def::
  getInstatiation_parameters () const
  {
    return this->instatiation_parameters_.get ();
  }

  T_cluster_class_def::Instatiation_parametersType& T_cluster_class_def::
  getInstatiation_parameters ()
  {
    return this->instatiation_parameters_.get ();
  }

  void T_cluster_class_def::
  setInstatiation_parameters (const Instatiation_parametersType& x)
  {
    this->instatiation_parameters_.set (x);
  }

  void T_cluster_class_def::
  setInstatiation_parameters (::std::unique_ptr< Instatiation_parametersType > x)
  {
    this->instatiation_parameters_.set (std::move (x));
  }

  const T_cluster_class_def::InstanceSequence& T_cluster_class_def::
  getInstance () const
  {
    return this->instance_;
  }

  T_cluster_class_def::InstanceSequence& T_cluster_class_def::
  getInstance ()
  {
    return this->instance_;
  }

  void T_cluster_class_def::
  setInstance (const InstanceSequence& s)
  {
    this->instance_ = s;
  }


  // T_process_class_def
  // 

  const T_process_class_def::ClassType& T_process_class_def::
  getClass () const
  {
    return this->class__.get ();
  }

  T_process_class_def::ClassType& T_process_class_def::
  getClass ()
  {
    return this->class__.get ();
  }

  void T_process_class_def::
  setClass (const ClassType& x)
  {
    this->class__.set (x);
  }

  void T_process_class_def::
  setClass (::std::unique_ptr< ClassType > x)
  {
    this->class__.set (std::move (x));
  }

  const T_process_class_def::HandleType& T_process_class_def::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_process_class_def::HandleType& T_process_class_def::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_process_class_def::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  const T_process_class_def::Instatiation_parametersType& T_process_class_def::
  getInstatiation_parameters () const
  {
    return this->instatiation_parameters_.get ();
  }

  T_process_class_def::Instatiation_parametersType& T_process_class_def::
  getInstatiation_parameters ()
  {
    return this->instatiation_parameters_.get ();
  }

  void T_process_class_def::
  setInstatiation_parameters (const Instatiation_parametersType& x)
  {
    this->instatiation_parameters_.set (x);
  }

  void T_process_class_def::
  setInstatiation_parameters (::std::unique_ptr< Instatiation_parametersType > x)
  {
    this->instatiation_parameters_.set (std::move (x));
  }

  const T_process_class_def::InterfaceType& T_process_class_def::
  getInterface () const
  {
    return this->interface_.get ();
  }

  T_process_class_def::InterfaceType& T_process_class_def::
  getInterface ()
  {
    return this->interface_.get ();
  }

  void T_process_class_def::
  setInterface (const InterfaceType& x)
  {
    this->interface_.set (x);
  }

  void T_process_class_def::
  setInterface (::std::unique_ptr< InterfaceType > x)
  {
    this->interface_.set (std::move (x));
  }

  const T_process_class_def::Instance_variablesType& T_process_class_def::
  getInstance_variables () const
  {
    return this->instance_variables_.get ();
  }

  T_process_class_def::Instance_variablesType& T_process_class_def::
  getInstance_variables ()
  {
    return this->instance_variables_.get ();
  }

  void T_process_class_def::
  setInstance_variables (const Instance_variablesType& x)
  {
    this->instance_variables_.set (x);
  }

  void T_process_class_def::
  setInstance_variables (::std::unique_ptr< Instance_variablesType > x)
  {
    this->instance_variables_.set (std::move (x));
  }

  const T_process_class_def::Initial_method_callType& T_process_class_def::
  getInitial_method_call () const
  {
    return this->initial_method_call_.get ();
  }

  T_process_class_def::Initial_method_callType& T_process_class_def::
  getInitial_method_call ()
  {
    return this->initial_method_call_.get ();
  }

  void T_process_class_def::
  setInitial_method_call (const Initial_method_callType& x)
  {
    this->initial_method_call_.set (x);
  }

  void T_process_class_def::
  setInitial_method_call (::std::unique_ptr< Initial_method_callType > x)
  {
    this->initial_method_call_.set (std::move (x));
  }

  const T_process_class_def::MethodsType& T_process_class_def::
  getMethods () const
  {
    return this->methods_.get ();
  }

  T_process_class_def::MethodsType& T_process_class_def::
  getMethods ()
  {
    return this->methods_.get ();
  }

  void T_process_class_def::
  setMethods (const MethodsType& x)
  {
    this->methods_.set (x);
  }

  void T_process_class_def::
  setMethods (::std::unique_ptr< MethodsType > x)
  {
    this->methods_.set (std::move (x));
  }


  // T_data_class_def
  // 

  const T_data_class_def::ClassType& T_data_class_def::
  getClass () const
  {
    return this->class__.get ();
  }

  T_data_class_def::ClassType& T_data_class_def::
  getClass ()
  {
    return this->class__.get ();
  }

  void T_data_class_def::
  setClass (const ClassType& x)
  {
    this->class__.set (x);
  }

  void T_data_class_def::
  setClass (::std::unique_ptr< ClassType > x)
  {
    this->class__.set (std::move (x));
  }

  const T_data_class_def::HandleType& T_data_class_def::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_data_class_def::HandleType& T_data_class_def::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_data_class_def::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  const T_data_class_def::Instance_variablesType& T_data_class_def::
  getInstance_variables () const
  {
    return this->instance_variables_.get ();
  }

  T_data_class_def::Instance_variablesType& T_data_class_def::
  getInstance_variables ()
  {
    return this->instance_variables_.get ();
  }

  void T_data_class_def::
  setInstance_variables (const Instance_variablesType& x)
  {
    this->instance_variables_.set (x);
  }

  void T_data_class_def::
  setInstance_variables (::std::unique_ptr< Instance_variablesType > x)
  {
    this->instance_variables_.set (std::move (x));
  }

  const T_data_class_def::MethodsType& T_data_class_def::
  getMethods () const
  {
    return this->methods_.get ();
  }

  T_data_class_def::MethodsType& T_data_class_def::
  getMethods ()
  {
    return this->methods_.get ();
  }

  void T_data_class_def::
  setMethods (const MethodsType& x)
  {
    this->methods_.set (x);
  }

  void T_data_class_def::
  setMethods (::std::unique_ptr< MethodsType > x)
  {
    this->methods_.set (std::move (x));
  }


  // T_get_method_definition_response
  // 

  const T_get_method_definition_response::ResultType& T_get_method_definition_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_get_method_definition_response::ResultType& T_get_method_definition_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_get_method_definition_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_get_method_definition_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }

  const T_get_method_definition_response::Process_methodOptional& T_get_method_definition_response::
  getProcess_method () const
  {
    return this->process_method_;
  }

  T_get_method_definition_response::Process_methodOptional& T_get_method_definition_response::
  getProcess_method ()
  {
    return this->process_method_;
  }

  void T_get_method_definition_response::
  setProcess_method (const Process_methodType& x)
  {
    this->process_method_.set (x);
  }

  void T_get_method_definition_response::
  setProcess_method (const Process_methodOptional& x)
  {
    this->process_method_ = x;
  }

  void T_get_method_definition_response::
  setProcess_method (::std::unique_ptr< Process_methodType > x)
  {
    this->process_method_.set (std::move (x));
  }

  const T_get_method_definition_response::Data_methodOptional& T_get_method_definition_response::
  getData_method () const
  {
    return this->data_method_;
  }

  T_get_method_definition_response::Data_methodOptional& T_get_method_definition_response::
  getData_method ()
  {
    return this->data_method_;
  }

  void T_get_method_definition_response::
  setData_method (const Data_methodType& x)
  {
    this->data_method_.set (x);
  }

  void T_get_method_definition_response::
  setData_method (const Data_methodOptional& x)
  {
    this->data_method_ = x;
  }

  void T_get_method_definition_response::
  setData_method (::std::unique_ptr< Data_methodType > x)
  {
    this->data_method_.set (std::move (x));
  }


  // T_process_method_def
  // 

  const T_process_method_def::NameOptional& T_process_method_def::
  getName () const
  {
    return this->name_;
  }

  T_process_method_def::NameOptional& T_process_method_def::
  getName ()
  {
    return this->name_;
  }

  void T_process_method_def::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_process_method_def::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void T_process_method_def::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_process_method_def::Input_parameterSequence& T_process_method_def::
  getInput_parameter () const
  {
    return this->input_parameter_;
  }

  T_process_method_def::Input_parameterSequence& T_process_method_def::
  getInput_parameter ()
  {
    return this->input_parameter_;
  }

  void T_process_method_def::
  setInput_parameter (const Input_parameterSequence& s)
  {
    this->input_parameter_ = s;
  }

  const T_process_method_def::Output_parameterSequence& T_process_method_def::
  getOutput_parameter () const
  {
    return this->output_parameter_;
  }

  T_process_method_def::Output_parameterSequence& T_process_method_def::
  getOutput_parameter ()
  {
    return this->output_parameter_;
  }

  void T_process_method_def::
  setOutput_parameter (const Output_parameterSequence& s)
  {
    this->output_parameter_ = s;
  }

  const T_process_method_def::Local_variableSequence& T_process_method_def::
  getLocal_variable () const
  {
    return this->local_variable_;
  }

  T_process_method_def::Local_variableSequence& T_process_method_def::
  getLocal_variable ()
  {
    return this->local_variable_;
  }

  void T_process_method_def::
  setLocal_variable (const Local_variableSequence& s)
  {
    this->local_variable_ = s;
  }

  const T_process_method_def::Body_textType& T_process_method_def::
  getBody_text () const
  {
    return this->body_text_.get ();
  }

  T_process_method_def::Body_textType& T_process_method_def::
  getBody_text ()
  {
    return this->body_text_.get ();
  }

  void T_process_method_def::
  setBody_text (const Body_textType& x)
  {
    this->body_text_.set (x);
  }

  void T_process_method_def::
  setBody_text (::std::unique_ptr< Body_textType > x)
  {
    this->body_text_.set (std::move (x));
  }

  const T_process_method_def::Body_statementsOptional& T_process_method_def::
  getBody_statements () const
  {
    return this->body_statements_;
  }

  T_process_method_def::Body_statementsOptional& T_process_method_def::
  getBody_statements ()
  {
    return this->body_statements_;
  }

  void T_process_method_def::
  setBody_statements (const Body_statementsType& x)
  {
    this->body_statements_.set (x);
  }

  void T_process_method_def::
  setBody_statements (const Body_statementsOptional& x)
  {
    this->body_statements_ = x;
  }

  void T_process_method_def::
  setBody_statements (::std::unique_ptr< Body_statementsType > x)
  {
    this->body_statements_.set (std::move (x));
  }


  // T_data_method_def
  // 

  const T_data_method_def::NameType& T_data_method_def::
  getName () const
  {
    return this->name_.get ();
  }

  T_data_method_def::NameType& T_data_method_def::
  getName ()
  {
    return this->name_.get ();
  }

  void T_data_method_def::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_data_method_def::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_data_method_def::ArgumentSequence& T_data_method_def::
  getArgument () const
  {
    return this->argument_;
  }

  T_data_method_def::ArgumentSequence& T_data_method_def::
  getArgument ()
  {
    return this->argument_;
  }

  void T_data_method_def::
  setArgument (const ArgumentSequence& s)
  {
    this->argument_ = s;
  }

  const T_data_method_def::Local_variableSequence& T_data_method_def::
  getLocal_variable () const
  {
    return this->local_variable_;
  }

  T_data_method_def::Local_variableSequence& T_data_method_def::
  getLocal_variable ()
  {
    return this->local_variable_;
  }

  void T_data_method_def::
  setLocal_variable (const Local_variableSequence& s)
  {
    this->local_variable_ = s;
  }

  const T_data_method_def::Body_textType& T_data_method_def::
  getBody_text () const
  {
    return this->body_text_.get ();
  }

  T_data_method_def::Body_textType& T_data_method_def::
  getBody_text ()
  {
    return this->body_text_.get ();
  }

  void T_data_method_def::
  setBody_text (const Body_textType& x)
  {
    this->body_text_.set (x);
  }

  void T_data_method_def::
  setBody_text (::std::unique_ptr< Body_textType > x)
  {
    this->body_text_.set (std::move (x));
  }

  const T_data_method_def::Body_expressionOptional& T_data_method_def::
  getBody_expression () const
  {
    return this->body_expression_;
  }

  T_data_method_def::Body_expressionOptional& T_data_method_def::
  getBody_expression ()
  {
    return this->body_expression_;
  }

  void T_data_method_def::
  setBody_expression (const Body_expressionType& x)
  {
    this->body_expression_.set (x);
  }

  void T_data_method_def::
  setBody_expression (const Body_expressionOptional& x)
  {
    this->body_expression_ = x;
  }

  void T_data_method_def::
  setBody_expression (::std::unique_ptr< Body_expressionType > x)
  {
    this->body_expression_.set (std::move (x));
  }

  const T_data_method_def::Return_typeType& T_data_method_def::
  getReturn_type () const
  {
    return this->return_type_.get ();
  }

  T_data_method_def::Return_typeType& T_data_method_def::
  getReturn_type ()
  {
    return this->return_type_.get ();
  }

  void T_data_method_def::
  setReturn_type (const Return_typeType& x)
  {
    this->return_type_.set (x);
  }

  void T_data_method_def::
  setReturn_type (::std::unique_ptr< Return_typeType > x)
  {
    this->return_type_.set (std::move (x));
  }


  // T_get_object_handle_response
  // 

  const T_get_object_handle_response::ResultType& T_get_object_handle_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_get_object_handle_response::ResultType& T_get_object_handle_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_get_object_handle_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_get_object_handle_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }

  const T_get_object_handle_response::HandleType& T_get_object_handle_response::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_get_object_handle_response::HandleType& T_get_object_handle_response::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_get_object_handle_response::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }


  // T_rename_object_response
  // 

  const T_rename_object_response::ResultType& T_rename_object_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_rename_object_response::ResultType& T_rename_object_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_rename_object_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_rename_object_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }


  // T_rename_object_response_result
  // 

  T_rename_object_response_result::
  T_rename_object_response_result ()
  : ::xml_schema::String ()
  {
  }

  T_rename_object_response_result::
  T_rename_object_response_result (Value v)
  : ::xml_schema::String (_xsd_T_rename_object_response_result_literals_[v])
  {
  }

  T_rename_object_response_result::
  T_rename_object_response_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_rename_object_response_result::
  T_rename_object_response_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_rename_object_response_result::
  T_rename_object_response_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_rename_object_response_result::
  T_rename_object_response_result (const T_rename_object_response_result& v,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_rename_object_response_result& T_rename_object_response_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_rename_object_response_result_literals_[v]);

    return *this;
  }


  // T_insert_object_response
  // 

  const T_insert_object_response::ResultType& T_insert_object_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_insert_object_response::ResultType& T_insert_object_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_insert_object_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_insert_object_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }


  // T_insert_object_response_result
  // 

  T_insert_object_response_result::
  T_insert_object_response_result ()
  : ::xml_schema::String ()
  {
  }

  T_insert_object_response_result::
  T_insert_object_response_result (Value v)
  : ::xml_schema::String (_xsd_T_insert_object_response_result_literals_[v])
  {
  }

  T_insert_object_response_result::
  T_insert_object_response_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_insert_object_response_result::
  T_insert_object_response_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_insert_object_response_result::
  T_insert_object_response_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_insert_object_response_result::
  T_insert_object_response_result (const T_insert_object_response_result& v,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_insert_object_response_result& T_insert_object_response_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_insert_object_response_result_literals_[v]);

    return *this;
  }


  // T_delete_object_response
  // 

  const T_delete_object_response::ObjectSequence& T_delete_object_response::
  getObject () const
  {
    return this->object_;
  }

  T_delete_object_response::ObjectSequence& T_delete_object_response::
  getObject ()
  {
    return this->object_;
  }

  void T_delete_object_response::
  setObject (const ObjectSequence& s)
  {
    this->object_ = s;
  }

  const T_delete_object_response::ResultSequence& T_delete_object_response::
  getResult () const
  {
    return this->result_;
  }

  T_delete_object_response::ResultSequence& T_delete_object_response::
  getResult ()
  {
    return this->result_;
  }

  void T_delete_object_response::
  setResult (const ResultSequence& s)
  {
    this->result_ = s;
  }


  // T_object_query_result
  // 

  T_object_query_result::
  T_object_query_result ()
  : ::xml_schema::String ()
  {
  }

  T_object_query_result::
  T_object_query_result (Value v)
  : ::xml_schema::String (_xsd_T_object_query_result_literals_[v])
  {
  }

  T_object_query_result::
  T_object_query_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_object_query_result::
  T_object_query_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_object_query_result::
  T_object_query_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_object_query_result::
  T_object_query_result (const T_object_query_result& v,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_object_query_result& T_object_query_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_object_query_result_literals_[v]);

    return *this;
  }


  // T_instantiate_response
  // 

  const T_instantiate_response::ResultType& T_instantiate_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_instantiate_response::ResultType& T_instantiate_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_instantiate_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_instantiate_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }


  // T_instantiate_result
  // 

  T_instantiate_result::
  T_instantiate_result ()
  : ::xml_schema::String ()
  {
  }

  T_instantiate_result::
  T_instantiate_result (Value v)
  : ::xml_schema::String (_xsd_T_instantiate_result_literals_[v])
  {
  }

  T_instantiate_result::
  T_instantiate_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_instantiate_result::
  T_instantiate_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_instantiate_result::
  T_instantiate_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_instantiate_result::
  T_instantiate_result (const T_instantiate_result& v,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_instantiate_result& T_instantiate_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_instantiate_result_literals_[v]);

    return *this;
  }


  // T_command_response
  // 

  const T_command_response::TypeOptional& T_command_response::
  getType () const
  {
    return this->type_;
  }

  T_command_response::TypeOptional& T_command_response::
  getType ()
  {
    return this->type_;
  }

  void T_command_response::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void T_command_response::
  setType (const TypeOptional& x)
  {
    this->type_ = x;
  }

  void T_command_response::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }

  const T_command_response::ResultOptional& T_command_response::
  getResult () const
  {
    return this->result_;
  }

  T_command_response::ResultOptional& T_command_response::
  getResult ()
  {
    return this->result_;
  }

  void T_command_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_command_response::
  setResult (const ResultOptional& x)
  {
    this->result_ = x;
  }

  void T_command_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }


  // T_get_transitions_response
  // 

  const T_get_transitions_response::TransitionsType& T_get_transitions_response::
  getTransitions () const
  {
    return this->transitions_.get ();
  }

  T_get_transitions_response::TransitionsType& T_get_transitions_response::
  getTransitions ()
  {
    return this->transitions_.get ();
  }

  void T_get_transitions_response::
  setTransitions (const TransitionsType& x)
  {
    this->transitions_.set (x);
  }

  void T_get_transitions_response::
  setTransitions (::std::unique_ptr< TransitionsType > x)
  {
    this->transitions_.set (std::move (x));
  }


  // T_perform_transition_response
  // 

  const T_perform_transition_response::ResultType& T_perform_transition_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_perform_transition_response::ResultType& T_perform_transition_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_perform_transition_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_perform_transition_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }


  // T_perform_transition_response_result
  // 

  T_perform_transition_response_result::
  T_perform_transition_response_result ()
  : ::xml_schema::String ()
  {
  }

  T_perform_transition_response_result::
  T_perform_transition_response_result (Value v)
  : ::xml_schema::String (_xsd_T_perform_transition_response_result_literals_[v])
  {
  }

  T_perform_transition_response_result::
  T_perform_transition_response_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_perform_transition_response_result::
  T_perform_transition_response_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_perform_transition_response_result::
  T_perform_transition_response_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_perform_transition_response_result::
  T_perform_transition_response_result (const T_perform_transition_response_result& v,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_perform_transition_response_result& T_perform_transition_response_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_perform_transition_response_result_literals_[v]);

    return *this;
  }


  // T_inspect_response
  // 

  const T_inspect_response::NameOptional& T_inspect_response::
  getName () const
  {
    return this->name_;
  }

  T_inspect_response::NameOptional& T_inspect_response::
  getName ()
  {
    return this->name_;
  }

  void T_inspect_response::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_inspect_response::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void T_inspect_response::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_inspect_response::HandleType& T_inspect_response::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_inspect_response::HandleType& T_inspect_response::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_inspect_response::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  const T_inspect_response::ResultType& T_inspect_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_inspect_response::ResultType& T_inspect_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_inspect_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_inspect_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }

  const T_inspect_response::ProcessOptional& T_inspect_response::
  getProcess () const
  {
    return this->process_;
  }

  T_inspect_response::ProcessOptional& T_inspect_response::
  getProcess ()
  {
    return this->process_;
  }

  void T_inspect_response::
  setProcess (const ProcessType& x)
  {
    this->process_.set (x);
  }

  void T_inspect_response::
  setProcess (const ProcessOptional& x)
  {
    this->process_ = x;
  }

  void T_inspect_response::
  setProcess (::std::unique_ptr< ProcessType > x)
  {
    this->process_.set (std::move (x));
  }

  const T_inspect_response::DataOptional& T_inspect_response::
  getData () const
  {
    return this->data_;
  }

  T_inspect_response::DataOptional& T_inspect_response::
  getData ()
  {
    return this->data_;
  }

  void T_inspect_response::
  setData (const DataType& x)
  {
    this->data_.set (x);
  }

  void T_inspect_response::
  setData (const DataOptional& x)
  {
    this->data_ = x;
  }

  void T_inspect_response::
  setData (::std::unique_ptr< DataType > x)
  {
    this->data_.set (std::move (x));
  }

  const T_inspect_response::SystemOptional& T_inspect_response::
  getSystem () const
  {
    return this->system_;
  }

  T_inspect_response::SystemOptional& T_inspect_response::
  getSystem ()
  {
    return this->system_;
  }

  void T_inspect_response::
  setSystem (const SystemType& x)
  {
    this->system_.set (x);
  }

  void T_inspect_response::
  setSystem (const SystemOptional& x)
  {
    this->system_ = x;
  }

  void T_inspect_response::
  setSystem (::std::unique_ptr< SystemType > x)
  {
    this->system_.set (std::move (x));
  }

  const T_inspect_response::ChannelOptional& T_inspect_response::
  getChannel () const
  {
    return this->channel_;
  }

  T_inspect_response::ChannelOptional& T_inspect_response::
  getChannel ()
  {
    return this->channel_;
  }

  void T_inspect_response::
  setChannel (const ChannelType& x)
  {
    this->channel_.set (x);
  }

  void T_inspect_response::
  setChannel (const ChannelOptional& x)
  {
    this->channel_ = x;
  }

  void T_inspect_response::
  setChannel (::std::unique_ptr< ChannelType > x)
  {
    this->channel_.set (std::move (x));
  }

  const T_inspect_response::StackframeOptional& T_inspect_response::
  getStackframe () const
  {
    return this->stackframe_;
  }

  T_inspect_response::StackframeOptional& T_inspect_response::
  getStackframe ()
  {
    return this->stackframe_;
  }

  void T_inspect_response::
  setStackframe (const StackframeType& x)
  {
    this->stackframe_.set (x);
  }

  void T_inspect_response::
  setStackframe (const StackframeOptional& x)
  {
    this->stackframe_ = x;
  }

  void T_inspect_response::
  setStackframe (::std::unique_ptr< StackframeType > x)
  {
    this->stackframe_.set (std::move (x));
  }

  const T_inspect_response::VariableOptional& T_inspect_response::
  getVariable () const
  {
    return this->variable_;
  }

  T_inspect_response::VariableOptional& T_inspect_response::
  getVariable ()
  {
    return this->variable_;
  }

  void T_inspect_response::
  setVariable (const VariableType& x)
  {
    this->variable_.set (x);
  }

  void T_inspect_response::
  setVariable (const VariableOptional& x)
  {
    this->variable_ = x;
  }

  void T_inspect_response::
  setVariable (::std::unique_ptr< VariableType > x)
  {
    this->variable_.set (std::move (x));
  }

  const T_inspect_response::Variable_contextOptional& T_inspect_response::
  getVariable_context () const
  {
    return this->variable_context_;
  }

  T_inspect_response::Variable_contextOptional& T_inspect_response::
  getVariable_context ()
  {
    return this->variable_context_;
  }

  void T_inspect_response::
  setVariable_context (const Variable_contextType& x)
  {
    this->variable_context_.set (x);
  }

  void T_inspect_response::
  setVariable_context (const Variable_contextOptional& x)
  {
    this->variable_context_ = x;
  }

  void T_inspect_response::
  setVariable_context (::std::unique_ptr< Variable_contextType > x)
  {
    this->variable_context_.set (std::move (x));
  }

  const T_inspect_response::TransitionOptional& T_inspect_response::
  getTransition () const
  {
    return this->transition_;
  }

  T_inspect_response::TransitionOptional& T_inspect_response::
  getTransition ()
  {
    return this->transition_;
  }

  void T_inspect_response::
  setTransition (const TransitionType& x)
  {
    this->transition_.set (x);
  }

  void T_inspect_response::
  setTransition (const TransitionOptional& x)
  {
    this->transition_ = x;
  }

  void T_inspect_response::
  setTransition (::std::unique_ptr< TransitionType > x)
  {
    this->transition_.set (std::move (x));
  }


  // T_inspect_process
  // 

  const T_inspect_process::Instance_variablesType& T_inspect_process::
  getInstance_variables () const
  {
    return this->instance_variables_.get ();
  }

  T_inspect_process::Instance_variablesType& T_inspect_process::
  getInstance_variables ()
  {
    return this->instance_variables_.get ();
  }

  void T_inspect_process::
  setInstance_variables (const Instance_variablesType& x)
  {
    this->instance_variables_.set (x);
  }

  void T_inspect_process::
  setInstance_variables (::std::unique_ptr< Instance_variablesType > x)
  {
    this->instance_variables_.set (std::move (x));
  }

  const T_inspect_process::Execution_treeType& T_inspect_process::
  getExecution_tree () const
  {
    return this->execution_tree_.get ();
  }

  T_inspect_process::Execution_treeType& T_inspect_process::
  getExecution_tree ()
  {
    return this->execution_tree_.get ();
  }

  void T_inspect_process::
  setExecution_tree (const Execution_treeType& x)
  {
    this->execution_tree_.set (x);
  }

  void T_inspect_process::
  setExecution_tree (::std::unique_ptr< Execution_treeType > x)
  {
    this->execution_tree_.set (std::move (x));
  }


  // T_inspect_port
  // 

  const T_inspect_port::NameType& T_inspect_port::
  getName () const
  {
    return this->name_.get ();
  }

  T_inspect_port::NameType& T_inspect_port::
  getName ()
  {
    return this->name_.get ();
  }

  void T_inspect_port::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_inspect_port::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_inspect_port::Up_channelOptional& T_inspect_port::
  getUp_channel () const
  {
    return this->up_channel_;
  }

  T_inspect_port::Up_channelOptional& T_inspect_port::
  getUp_channel ()
  {
    return this->up_channel_;
  }

  void T_inspect_port::
  setUp_channel (const Up_channelType& x)
  {
    this->up_channel_.set (x);
  }

  void T_inspect_port::
  setUp_channel (const Up_channelOptional& x)
  {
    this->up_channel_ = x;
  }

  void T_inspect_port::
  setUp_channel (::std::unique_ptr< Up_channelType > x)
  {
    this->up_channel_.set (std::move (x));
  }

  const T_inspect_port::Down_channelOptional& T_inspect_port::
  getDown_channel () const
  {
    return this->down_channel_;
  }

  T_inspect_port::Down_channelOptional& T_inspect_port::
  getDown_channel ()
  {
    return this->down_channel_;
  }

  void T_inspect_port::
  setDown_channel (const Down_channelType& x)
  {
    this->down_channel_.set (x);
  }

  void T_inspect_port::
  setDown_channel (const Down_channelOptional& x)
  {
    this->down_channel_ = x;
  }

  void T_inspect_port::
  setDown_channel (::std::unique_ptr< Down_channelType > x)
  {
    this->down_channel_.set (std::move (x));
  }


  // T_inspect_instance
  // 

  const T_inspect_instance::NameType& T_inspect_instance::
  getName () const
  {
    return this->name_.get ();
  }

  T_inspect_instance::NameType& T_inspect_instance::
  getName ()
  {
    return this->name_.get ();
  }

  void T_inspect_instance::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_inspect_instance::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_inspect_instance::TypeType& T_inspect_instance::
  getType () const
  {
    return this->type_.get ();
  }

  T_inspect_instance::TypeType& T_inspect_instance::
  getType ()
  {
    return this->type_.get ();
  }

  void T_inspect_instance::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void T_inspect_instance::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }

  const T_inspect_instance::Process_pathType& T_inspect_instance::
  getProcess_path () const
  {
    return this->process_path_.get ();
  }

  T_inspect_instance::Process_pathType& T_inspect_instance::
  getProcess_path ()
  {
    return this->process_path_.get ();
  }

  void T_inspect_instance::
  setProcess_path (const Process_pathType& x)
  {
    this->process_path_.set (x);
  }

  void T_inspect_instance::
  setProcess_path (::std::unique_ptr< Process_pathType > x)
  {
    this->process_path_.set (std::move (x));
  }

  const T_inspect_instance::ClusterOptional& T_inspect_instance::
  getCluster () const
  {
    return this->cluster_;
  }

  T_inspect_instance::ClusterOptional& T_inspect_instance::
  getCluster ()
  {
    return this->cluster_;
  }

  void T_inspect_instance::
  setCluster (const ClusterType& x)
  {
    this->cluster_.set (x);
  }

  void T_inspect_instance::
  setCluster (const ClusterOptional& x)
  {
    this->cluster_ = x;
  }

  void T_inspect_instance::
  setCluster (::std::unique_ptr< ClusterType > x)
  {
    this->cluster_.set (std::move (x));
  }

  const T_inspect_instance::PortSequence& T_inspect_instance::
  getPort () const
  {
    return this->port_;
  }

  T_inspect_instance::PortSequence& T_inspect_instance::
  getPort ()
  {
    return this->port_;
  }

  void T_inspect_instance::
  setPort (const PortSequence& s)
  {
    this->port_ = s;
  }


  // T_inspect_cluster
  // 

  const T_inspect_cluster::ChannelSequence& T_inspect_cluster::
  getChannel () const
  {
    return this->channel_;
  }

  T_inspect_cluster::ChannelSequence& T_inspect_cluster::
  getChannel ()
  {
    return this->channel_;
  }

  void T_inspect_cluster::
  setChannel (const ChannelSequence& s)
  {
    this->channel_ = s;
  }

  const T_inspect_cluster::InstanceSequence& T_inspect_cluster::
  getInstance () const
  {
    return this->instance_;
  }

  T_inspect_cluster::InstanceSequence& T_inspect_cluster::
  getInstance ()
  {
    return this->instance_;
  }

  void T_inspect_cluster::
  setInstance (const InstanceSequence& s)
  {
    this->instance_ = s;
  }


  // T_inspect_system
  // 

  const T_inspect_system::ChannelSequence& T_inspect_system::
  getChannel () const
  {
    return this->channel_;
  }

  T_inspect_system::ChannelSequence& T_inspect_system::
  getChannel ()
  {
    return this->channel_;
  }

  void T_inspect_system::
  setChannel (const ChannelSequence& s)
  {
    this->channel_ = s;
  }

  const T_inspect_system::InstanceSequence& T_inspect_system::
  getInstance () const
  {
    return this->instance_;
  }

  T_inspect_system::InstanceSequence& T_inspect_system::
  getInstance ()
  {
    return this->instance_;
  }

  void T_inspect_system::
  setInstance (const InstanceSequence& s)
  {
    this->instance_ = s;
  }


  // T_inspect_channel
  // 

  const T_inspect_channel::NameType& T_inspect_channel::
  getName () const
  {
    return this->name_.get ();
  }

  T_inspect_channel::NameType& T_inspect_channel::
  getName ()
  {
    return this->name_.get ();
  }

  void T_inspect_channel::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_inspect_channel::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_inspect_channel::Is_rootType& T_inspect_channel::
  getIs_root () const
  {
    return this->is_root_.get ();
  }

  T_inspect_channel::Is_rootType& T_inspect_channel::
  getIs_root ()
  {
    return this->is_root_.get ();
  }

  void T_inspect_channel::
  setIs_root (const Is_rootType& x)
  {
    this->is_root_.set (x);
  }


  // T_stackframe
  // 

  const T_stackframe::Dataclass_handleType& T_stackframe::
  getDataclass_handle () const
  {
    return this->dataclass_handle_.get ();
  }

  T_stackframe::Dataclass_handleType& T_stackframe::
  getDataclass_handle ()
  {
    return this->dataclass_handle_.get ();
  }

  void T_stackframe::
  setDataclass_handle (const Dataclass_handleType& x)
  {
    this->dataclass_handle_.set (x);
  }

  const T_stackframe::Dataclass_nameType& T_stackframe::
  getDataclass_name () const
  {
    return this->dataclass_name_.get ();
  }

  T_stackframe::Dataclass_nameType& T_stackframe::
  getDataclass_name ()
  {
    return this->dataclass_name_.get ();
  }

  void T_stackframe::
  setDataclass_name (const Dataclass_nameType& x)
  {
    this->dataclass_name_.set (x);
  }

  void T_stackframe::
  setDataclass_name (::std::unique_ptr< Dataclass_nameType > x)
  {
    this->dataclass_name_.set (std::move (x));
  }

  const T_stackframe::Method_nameType& T_stackframe::
  getMethod_name () const
  {
    return this->method_name_.get ();
  }

  T_stackframe::Method_nameType& T_stackframe::
  getMethod_name ()
  {
    return this->method_name_.get ();
  }

  void T_stackframe::
  setMethod_name (const Method_nameType& x)
  {
    this->method_name_.set (x);
  }

  void T_stackframe::
  setMethod_name (::std::unique_ptr< Method_nameType > x)
  {
    this->method_name_.set (std::move (x));
  }

  const T_stackframe::Local_variablesType& T_stackframe::
  getLocal_variables () const
  {
    return this->local_variables_.get ();
  }

  T_stackframe::Local_variablesType& T_stackframe::
  getLocal_variables ()
  {
    return this->local_variables_.get ();
  }

  void T_stackframe::
  setLocal_variables (const Local_variablesType& x)
  {
    this->local_variables_.set (x);
  }

  void T_stackframe::
  setLocal_variables (::std::unique_ptr< Local_variablesType > x)
  {
    this->local_variables_.set (std::move (x));
  }

  const T_stackframe::DownframeType& T_stackframe::
  getDownframe () const
  {
    return this->downframe_.get ();
  }

  T_stackframe::DownframeType& T_stackframe::
  getDownframe ()
  {
    return this->downframe_.get ();
  }

  void T_stackframe::
  setDownframe (const DownframeType& x)
  {
    this->downframe_.set (x);
  }

  const T_stackframe::UpframeType& T_stackframe::
  getUpframe () const
  {
    return this->upframe_.get ();
  }

  T_stackframe::UpframeType& T_stackframe::
  getUpframe ()
  {
    return this->upframe_.get ();
  }

  void T_stackframe::
  setUpframe (const UpframeType& x)
  {
    this->upframe_.set (x);
  }


  // T_inspect_variable_context
  // 

  const T_inspect_variable_context::VariableSequence& T_inspect_variable_context::
  getVariable () const
  {
    return this->variable_;
  }

  T_inspect_variable_context::VariableSequence& T_inspect_variable_context::
  getVariable ()
  {
    return this->variable_;
  }

  void T_inspect_variable_context::
  setVariable (const VariableSequence& s)
  {
    this->variable_ = s;
  }


  // T_inspect_variable
  // 

  const T_inspect_variable::HandleType& T_inspect_variable::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_inspect_variable::HandleType& T_inspect_variable::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_inspect_variable::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  const T_inspect_variable::ObjectType& T_inspect_variable::
  getObject () const
  {
    return this->object_.get ();
  }

  T_inspect_variable::ObjectType& T_inspect_variable::
  getObject ()
  {
    return this->object_.get ();
  }

  void T_inspect_variable::
  setObject (const ObjectType& x)
  {
    this->object_.set (x);
  }

  const T_inspect_variable::TypeType& T_inspect_variable::
  getType () const
  {
    return this->type_.get ();
  }

  T_inspect_variable::TypeType& T_inspect_variable::
  getType ()
  {
    return this->type_.get ();
  }

  void T_inspect_variable::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void T_inspect_variable::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }

  const T_inspect_variable::LiteralOptional& T_inspect_variable::
  getLiteral () const
  {
    return this->literal_;
  }

  T_inspect_variable::LiteralOptional& T_inspect_variable::
  getLiteral ()
  {
    return this->literal_;
  }

  void T_inspect_variable::
  setLiteral (const LiteralType& x)
  {
    this->literal_.set (x);
  }

  void T_inspect_variable::
  setLiteral (const LiteralOptional& x)
  {
    this->literal_ = x;
  }

  void T_inspect_variable::
  setLiteral (::std::unique_ptr< LiteralType > x)
  {
    this->literal_.set (std::move (x));
  }


  // T_inspect_data
  // 

  const T_inspect_data::HandleType& T_inspect_data::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_inspect_data::HandleType& T_inspect_data::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_inspect_data::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  const T_inspect_data::TypeType& T_inspect_data::
  getType () const
  {
    return this->type_.get ();
  }

  T_inspect_data::TypeType& T_inspect_data::
  getType ()
  {
    return this->type_.get ();
  }

  void T_inspect_data::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void T_inspect_data::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }

  const T_inspect_data::LiteralOptional& T_inspect_data::
  getLiteral () const
  {
    return this->literal_;
  }

  T_inspect_data::LiteralOptional& T_inspect_data::
  getLiteral ()
  {
    return this->literal_;
  }

  void T_inspect_data::
  setLiteral (const LiteralType& x)
  {
    this->literal_.set (x);
  }

  void T_inspect_data::
  setLiteral (const LiteralOptional& x)
  {
    this->literal_ = x;
  }

  void T_inspect_data::
  setLiteral (::std::unique_ptr< LiteralType > x)
  {
    this->literal_.set (std::move (x));
  }

  const T_inspect_data::VariablesOptional& T_inspect_data::
  getVariables () const
  {
    return this->variables_;
  }

  T_inspect_data::VariablesOptional& T_inspect_data::
  getVariables ()
  {
    return this->variables_;
  }

  void T_inspect_data::
  setVariables (const VariablesType& x)
  {
    this->variables_.set (x);
  }

  void T_inspect_data::
  setVariables (const VariablesOptional& x)
  {
    this->variables_ = x;
  }

  void T_inspect_data::
  setVariables (::std::unique_ptr< VariablesType > x)
  {
    this->variables_.set (std::move (x));
  }


  // T_inspect_transition
  // 

  const T_inspect_transition::TransitionType& T_inspect_transition::
  getTransition () const
  {
    return this->transition_.get ();
  }

  T_inspect_transition::TransitionType& T_inspect_transition::
  getTransition ()
  {
    return this->transition_.get ();
  }

  void T_inspect_transition::
  setTransition (const TransitionType& x)
  {
    this->transition_.set (x);
  }

  void T_inspect_transition::
  setTransition (::std::unique_ptr< TransitionType > x)
  {
    this->transition_.set (std::move (x));
  }


  // T_observe_response
  // 

  const T_observe_response::AspectType& T_observe_response::
  getAspect () const
  {
    return this->aspect_.get ();
  }

  T_observe_response::AspectType& T_observe_response::
  getAspect ()
  {
    return this->aspect_.get ();
  }

  void T_observe_response::
  setAspect (const AspectType& x)
  {
    this->aspect_.set (x);
  }

  void T_observe_response::
  setAspect (::std::unique_ptr< AspectType > x)
  {
    this->aspect_.set (std::move (x));
  }

  const T_observe_response::TypeType& T_observe_response::
  getType () const
  {
    return this->type_.get ();
  }

  T_observe_response::TypeType& T_observe_response::
  getType ()
  {
    return this->type_.get ();
  }

  void T_observe_response::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void T_observe_response::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }

  const T_observe_response::HandleType& T_observe_response::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_observe_response::HandleType& T_observe_response::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_observe_response::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }


  // T_execution_state_change_response
  // 

  const T_execution_state_change_response::BreakpointsOptional& T_execution_state_change_response::
  getBreakpoints () const
  {
    return this->breakpoints_;
  }

  T_execution_state_change_response::BreakpointsOptional& T_execution_state_change_response::
  getBreakpoints ()
  {
    return this->breakpoints_;
  }

  void T_execution_state_change_response::
  setBreakpoints (const BreakpointsType& x)
  {
    this->breakpoints_.set (x);
  }

  void T_execution_state_change_response::
  setBreakpoints (const BreakpointsOptional& x)
  {
    this->breakpoints_ = x;
  }

  void T_execution_state_change_response::
  setBreakpoints (::std::unique_ptr< BreakpointsType > x)
  {
    this->breakpoints_.set (std::move (x));
  }

  const T_execution_state_change_response::ErrorOptional& T_execution_state_change_response::
  getError () const
  {
    return this->error_;
  }

  T_execution_state_change_response::ErrorOptional& T_execution_state_change_response::
  getError ()
  {
    return this->error_;
  }

  void T_execution_state_change_response::
  setError (const ErrorType& x)
  {
    this->error_.set (x);
  }

  void T_execution_state_change_response::
  setError (const ErrorOptional& x)
  {
    this->error_ = x;
  }

  void T_execution_state_change_response::
  setError (::std::unique_ptr< ErrorType > x)
  {
    this->error_.set (std::move (x));
  }

  const T_execution_state_change_response::TransitionOptional& T_execution_state_change_response::
  getTransition () const
  {
    return this->transition_;
  }

  T_execution_state_change_response::TransitionOptional& T_execution_state_change_response::
  getTransition ()
  {
    return this->transition_;
  }

  void T_execution_state_change_response::
  setTransition (const TransitionType& x)
  {
    this->transition_.set (x);
  }

  void T_execution_state_change_response::
  setTransition (const TransitionOptional& x)
  {
    this->transition_ = x;
  }

  void T_execution_state_change_response::
  setTransition (::std::unique_ptr< TransitionType > x)
  {
    this->transition_.set (std::move (x));
  }

  const T_execution_state_change_response::MessageOptional& T_execution_state_change_response::
  getMessage () const
  {
    return this->message_;
  }

  T_execution_state_change_response::MessageOptional& T_execution_state_change_response::
  getMessage ()
  {
    return this->message_;
  }

  void T_execution_state_change_response::
  setMessage (const MessageType& x)
  {
    this->message_.set (x);
  }

  void T_execution_state_change_response::
  setMessage (const MessageOptional& x)
  {
    this->message_ = x;
  }

  void T_execution_state_change_response::
  setMessage (::std::unique_ptr< MessageType > x)
  {
    this->message_.set (std::move (x));
  }

  const T_execution_state_change_response::StateType& T_execution_state_change_response::
  getState () const
  {
    return this->state_.get ();
  }

  T_execution_state_change_response::StateType& T_execution_state_change_response::
  getState ()
  {
    return this->state_.get ();
  }

  void T_execution_state_change_response::
  setState (const StateType& x)
  {
    this->state_.set (x);
  }

  void T_execution_state_change_response::
  setState (::std::unique_ptr< StateType > x)
  {
    this->state_.set (std::move (x));
  }

  const T_execution_state_change_response::TimeType& T_execution_state_change_response::
  getTime () const
  {
    return this->time_.get ();
  }

  T_execution_state_change_response::TimeType& T_execution_state_change_response::
  getTime ()
  {
    return this->time_.get ();
  }

  void T_execution_state_change_response::
  setTime (const TimeType& x)
  {
    this->time_.set (x);
  }

  const T_execution_state_change_response::Minimal_time_stepType& T_execution_state_change_response::
  getMinimal_time_step () const
  {
    return this->minimal_time_step_.get ();
  }

  T_execution_state_change_response::Minimal_time_stepType& T_execution_state_change_response::
  getMinimal_time_step ()
  {
    return this->minimal_time_step_.get ();
  }

  void T_execution_state_change_response::
  setMinimal_time_step (const Minimal_time_stepType& x)
  {
    this->minimal_time_step_.set (x);
  }


  // T_eengine_event_setup_response
  // 

  const T_eengine_event_setup_response::ResultType& T_eengine_event_setup_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_eengine_event_setup_response::ResultType& T_eengine_event_setup_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_eengine_event_setup_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_eengine_event_setup_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }


  // T_communication_event
  // 

  const T_communication_event::Simulation_timeType& T_communication_event::
  getSimulation_time () const
  {
    return this->simulation_time_.get ();
  }

  T_communication_event::Simulation_timeType& T_communication_event::
  getSimulation_time ()
  {
    return this->simulation_time_.get ();
  }

  void T_communication_event::
  setSimulation_time (const Simulation_timeType& x)
  {
    this->simulation_time_.set (x);
  }

  const T_communication_event::SenderType& T_communication_event::
  getSender () const
  {
    return this->sender_.get ();
  }

  T_communication_event::SenderType& T_communication_event::
  getSender ()
  {
    return this->sender_.get ();
  }

  void T_communication_event::
  setSender (const SenderType& x)
  {
    this->sender_.set (x);
  }

  void T_communication_event::
  setSender (::std::unique_ptr< SenderType > x)
  {
    this->sender_.set (std::move (x));
  }

  const T_communication_event::ReceiverType& T_communication_event::
  getReceiver () const
  {
    return this->receiver_.get ();
  }

  T_communication_event::ReceiverType& T_communication_event::
  getReceiver ()
  {
    return this->receiver_.get ();
  }

  void T_communication_event::
  setReceiver (const ReceiverType& x)
  {
    this->receiver_.set (x);
  }

  void T_communication_event::
  setReceiver (::std::unique_ptr< ReceiverType > x)
  {
    this->receiver_.set (std::move (x));
  }

  const T_communication_event::MessageType& T_communication_event::
  getMessage () const
  {
    return this->message_.get ();
  }

  T_communication_event::MessageType& T_communication_event::
  getMessage ()
  {
    return this->message_.get ();
  }

  void T_communication_event::
  setMessage (const MessageType& x)
  {
    this->message_.set (x);
  }

  void T_communication_event::
  setMessage (::std::unique_ptr< MessageType > x)
  {
    this->message_.set (std::move (x));
  }


  // T_eengine_event_error_response
  // 

  const T_eengine_event_error_response::ErrorType& T_eengine_event_error_response::
  getError () const
  {
    return this->error_.get ();
  }

  T_eengine_event_error_response::ErrorType& T_eengine_event_error_response::
  getError ()
  {
    return this->error_.get ();
  }

  void T_eengine_event_error_response::
  setError (const ErrorType& x)
  {
    this->error_.set (x);
  }

  void T_eengine_event_error_response::
  setError (::std::unique_ptr< ErrorType > x)
  {
    this->error_.set (std::move (x));
  }

  const T_eengine_event_error_response::Stmt_handleType& T_eengine_event_error_response::
  getStmt_handle () const
  {
    return this->stmt_handle_.get ();
  }

  T_eengine_event_error_response::Stmt_handleType& T_eengine_event_error_response::
  getStmt_handle ()
  {
    return this->stmt_handle_.get ();
  }

  void T_eengine_event_error_response::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  const T_eengine_event_error_response::Process_pathType& T_eengine_event_error_response::
  getProcess_path () const
  {
    return this->process_path_.get ();
  }

  T_eengine_event_error_response::Process_pathType& T_eengine_event_error_response::
  getProcess_path ()
  {
    return this->process_path_.get ();
  }

  void T_eengine_event_error_response::
  setProcess_path (const Process_pathType& x)
  {
    this->process_path_.set (x);
  }

  void T_eengine_event_error_response::
  setProcess_path (::std::unique_ptr< Process_pathType > x)
  {
    this->process_path_.set (std::move (x));
  }

  const T_eengine_event_error_response::StacktraceType& T_eengine_event_error_response::
  getStacktrace () const
  {
    return this->stacktrace_.get ();
  }

  T_eengine_event_error_response::StacktraceType& T_eengine_event_error_response::
  getStacktrace ()
  {
    return this->stacktrace_.get ();
  }

  void T_eengine_event_error_response::
  setStacktrace (const StacktraceType& x)
  {
    this->stacktrace_.set (x);
  }

  void T_eengine_event_error_response::
  setStacktrace (::std::unique_ptr< StacktraceType > x)
  {
    this->stacktrace_.set (std::move (x));
  }


  // T_communcation_event_node
  // 

  const T_communcation_event_node::Process_pathType& T_communcation_event_node::
  getProcess_path () const
  {
    return this->process_path_.get ();
  }

  T_communcation_event_node::Process_pathType& T_communcation_event_node::
  getProcess_path ()
  {
    return this->process_path_.get ();
  }

  void T_communcation_event_node::
  setProcess_path (const Process_pathType& x)
  {
    this->process_path_.set (x);
  }

  void T_communcation_event_node::
  setProcess_path (::std::unique_ptr< Process_pathType > x)
  {
    this->process_path_.set (std::move (x));
  }

  const T_communcation_event_node::Stmt_handleType& T_communcation_event_node::
  getStmt_handle () const
  {
    return this->stmt_handle_.get ();
  }

  T_communcation_event_node::Stmt_handleType& T_communcation_event_node::
  getStmt_handle ()
  {
    return this->stmt_handle_.get ();
  }

  void T_communcation_event_node::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  const T_communcation_event_node::Port_nameType& T_communcation_event_node::
  getPort_name () const
  {
    return this->port_name_.get ();
  }

  T_communcation_event_node::Port_nameType& T_communcation_event_node::
  getPort_name ()
  {
    return this->port_name_.get ();
  }

  void T_communcation_event_node::
  setPort_name (const Port_nameType& x)
  {
    this->port_name_.set (x);
  }

  void T_communcation_event_node::
  setPort_name (::std::unique_ptr< Port_nameType > x)
  {
    this->port_name_.set (std::move (x));
  }


  // T_error_stacktrace
  // 

  const T_error_stacktrace::StackframeSequence& T_error_stacktrace::
  getStackframe () const
  {
    return this->stackframe_;
  }

  T_error_stacktrace::StackframeSequence& T_error_stacktrace::
  getStackframe ()
  {
    return this->stackframe_;
  }

  void T_error_stacktrace::
  setStackframe (const StackframeSequence& s)
  {
    this->stackframe_ = s;
  }


  // T_error_stackframe
  // 

  const T_error_stackframe::MethodType& T_error_stackframe::
  getMethod () const
  {
    return this->method_.get ();
  }

  T_error_stackframe::MethodType& T_error_stackframe::
  getMethod ()
  {
    return this->method_.get ();
  }

  void T_error_stackframe::
  setMethod (const MethodType& x)
  {
    this->method_.set (x);
  }

  void T_error_stackframe::
  setMethod (::std::unique_ptr< MethodType > x)
  {
    this->method_.set (std::move (x));
  }

  const T_error_stackframe::Stmt_handleType& T_error_stackframe::
  getStmt_handle () const
  {
    return this->stmt_handle_.get ();
  }

  T_error_stackframe::Stmt_handleType& T_error_stackframe::
  getStmt_handle ()
  {
    return this->stmt_handle_.get ();
  }

  void T_error_stackframe::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_error_stackframe::
  setStmt_handle (::std::unique_ptr< Stmt_handleType > x)
  {
    this->stmt_handle_.set (std::move (x));
  }

  const T_error_stackframe::Variable_context_globalType& T_error_stackframe::
  getVariable_context_global () const
  {
    return this->variable_context_global_.get ();
  }

  T_error_stackframe::Variable_context_globalType& T_error_stackframe::
  getVariable_context_global ()
  {
    return this->variable_context_global_.get ();
  }

  void T_error_stackframe::
  setVariable_context_global (const Variable_context_globalType& x)
  {
    this->variable_context_global_.set (x);
  }

  void T_error_stackframe::
  setVariable_context_global (::std::unique_ptr< Variable_context_globalType > x)
  {
    this->variable_context_global_.set (std::move (x));
  }

  const T_error_stackframe::Variable_context_localType& T_error_stackframe::
  getVariable_context_local () const
  {
    return this->variable_context_local_.get ();
  }

  T_error_stackframe::Variable_context_localType& T_error_stackframe::
  getVariable_context_local ()
  {
    return this->variable_context_local_.get ();
  }

  void T_error_stackframe::
  setVariable_context_local (const Variable_context_localType& x)
  {
    this->variable_context_local_.set (x);
  }

  void T_error_stackframe::
  setVariable_context_local (::std::unique_ptr< Variable_context_localType > x)
  {
    this->variable_context_local_.set (std::move (x));
  }

  const T_error_stackframe::IdOptional& T_error_stackframe::
  getId () const
  {
    return this->id_;
  }

  T_error_stackframe::IdOptional& T_error_stackframe::
  getId ()
  {
    return this->id_;
  }

  void T_error_stackframe::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void T_error_stackframe::
  setId (const IdOptional& x)
  {
    this->id_ = x;
  }


  // T_communication_event_message
  // 

  const T_communication_event_message::NameType& T_communication_event_message::
  getName () const
  {
    return this->name_.get ();
  }

  T_communication_event_message::NameType& T_communication_event_message::
  getName ()
  {
    return this->name_.get ();
  }

  void T_communication_event_message::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_communication_event_message::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_communication_event_message::ParametersType& T_communication_event_message::
  getParameters () const
  {
    return this->parameters_.get ();
  }

  T_communication_event_message::ParametersType& T_communication_event_message::
  getParameters ()
  {
    return this->parameters_.get ();
  }

  void T_communication_event_message::
  setParameters (const ParametersType& x)
  {
    this->parameters_.set (x);
  }

  void T_communication_event_message::
  setParameters (::std::unique_ptr< ParametersType > x)
  {
    this->parameters_.set (std::move (x));
  }


  // T_communication_event_parameter
  // 

  const T_communication_event_parameter::ParameterSequence& T_communication_event_parameter::
  getParameter () const
  {
    return this->parameter_;
  }

  T_communication_event_parameter::ParameterSequence& T_communication_event_parameter::
  getParameter ()
  {
    return this->parameter_;
  }

  void T_communication_event_parameter::
  setParameter (const ParameterSequence& s)
  {
    this->parameter_ = s;
  }


  // T_breakpoint
  // 

  const T_breakpoint::BreakpointSequence& T_breakpoint::
  getBreakpoint () const
  {
    return this->breakpoint_;
  }

  T_breakpoint::BreakpointSequence& T_breakpoint::
  getBreakpoint ()
  {
    return this->breakpoint_;
  }

  void T_breakpoint::
  setBreakpoint (const BreakpointSequence& s)
  {
    this->breakpoint_ = s;
  }


  // T_breakpoint_info
  // 

  const T_breakpoint_info::NameType& T_breakpoint_info::
  getName () const
  {
    return this->name_.get ();
  }

  T_breakpoint_info::NameType& T_breakpoint_info::
  getName ()
  {
    return this->name_.get ();
  }

  void T_breakpoint_info::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_breakpoint_info::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_breakpoint_info::Breakpoint_idType& T_breakpoint_info::
  getBreakpoint_id () const
  {
    return this->breakpoint_id_.get ();
  }

  T_breakpoint_info::Breakpoint_idType& T_breakpoint_info::
  getBreakpoint_id ()
  {
    return this->breakpoint_id_.get ();
  }

  void T_breakpoint_info::
  setBreakpoint_id (const Breakpoint_idType& x)
  {
    this->breakpoint_id_.set (x);
  }

  const T_breakpoint_info::Control_pointType& T_breakpoint_info::
  getControl_point () const
  {
    return this->control_point_.get ();
  }

  T_breakpoint_info::Control_pointType& T_breakpoint_info::
  getControl_point ()
  {
    return this->control_point_.get ();
  }

  void T_breakpoint_info::
  setControl_point (const Control_pointType& x)
  {
    this->control_point_.set (x);
  }

  const T_breakpoint_info::Stmt_handleType& T_breakpoint_info::
  getStmt_handle () const
  {
    return this->stmt_handle_.get ();
  }

  T_breakpoint_info::Stmt_handleType& T_breakpoint_info::
  getStmt_handle ()
  {
    return this->stmt_handle_.get ();
  }

  void T_breakpoint_info::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  const T_breakpoint_info::Is_activeType& T_breakpoint_info::
  getIs_active () const
  {
    return this->is_active_.get ();
  }

  T_breakpoint_info::Is_activeType& T_breakpoint_info::
  getIs_active ()
  {
    return this->is_active_.get ();
  }

  void T_breakpoint_info::
  setIs_active (const Is_activeType& x)
  {
    this->is_active_.set (x);
  }

  const T_breakpoint_info::Hit_countType& T_breakpoint_info::
  getHit_count () const
  {
    return this->hit_count_.get ();
  }

  T_breakpoint_info::Hit_countType& T_breakpoint_info::
  getHit_count ()
  {
    return this->hit_count_.get ();
  }

  void T_breakpoint_info::
  setHit_count (const Hit_countType& x)
  {
    this->hit_count_.set (x);
  }


  // T_error_info
  // 

  const T_error_info::Stmt_handleType& T_error_info::
  getStmt_handle () const
  {
    return this->stmt_handle_.get ();
  }

  T_error_info::Stmt_handleType& T_error_info::
  getStmt_handle ()
  {
    return this->stmt_handle_.get ();
  }

  void T_error_info::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  const T_error_info::MessageType& T_error_info::
  getMessage () const
  {
    return this->message_.get ();
  }

  T_error_info::MessageType& T_error_info::
  getMessage ()
  {
    return this->message_.get ();
  }

  void T_error_info::
  setMessage (const MessageType& x)
  {
    this->message_.set (x);
  }

  void T_error_info::
  setMessage (::std::unique_ptr< MessageType > x)
  {
    this->message_.set (std::move (x));
  }

  const T_error_info::Process_pathOptional& T_error_info::
  getProcess_path () const
  {
    return this->process_path_;
  }

  T_error_info::Process_pathOptional& T_error_info::
  getProcess_path ()
  {
    return this->process_path_;
  }

  void T_error_info::
  setProcess_path (const Process_pathType& x)
  {
    this->process_path_.set (x);
  }

  void T_error_info::
  setProcess_path (const Process_pathOptional& x)
  {
    this->process_path_ = x;
  }

  void T_error_info::
  setProcess_path (::std::unique_ptr< Process_pathType > x)
  {
    this->process_path_.set (std::move (x));
  }

  const T_error_info::NodeType& T_error_info::
  getNode () const
  {
    return this->node_.get ();
  }

  T_error_info::NodeType& T_error_info::
  getNode ()
  {
    return this->node_.get ();
  }

  void T_error_info::
  setNode (const NodeType& x)
  {
    this->node_.set (x);
  }


  // T_create_breakpoint_response
  // 

  const T_create_breakpoint_response::NameType& T_create_breakpoint_response::
  getName () const
  {
    return this->name_.get ();
  }

  T_create_breakpoint_response::NameType& T_create_breakpoint_response::
  getName ()
  {
    return this->name_.get ();
  }

  void T_create_breakpoint_response::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_create_breakpoint_response::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_create_breakpoint_response::Breakpoint_idType& T_create_breakpoint_response::
  getBreakpoint_id () const
  {
    return this->breakpoint_id_.get ();
  }

  T_create_breakpoint_response::Breakpoint_idType& T_create_breakpoint_response::
  getBreakpoint_id ()
  {
    return this->breakpoint_id_.get ();
  }

  void T_create_breakpoint_response::
  setBreakpoint_id (const Breakpoint_idType& x)
  {
    this->breakpoint_id_.set (x);
  }

  const T_create_breakpoint_response::ResultType& T_create_breakpoint_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_create_breakpoint_response::ResultType& T_create_breakpoint_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_create_breakpoint_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_create_breakpoint_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }

  const T_create_breakpoint_response::Control_pointType& T_create_breakpoint_response::
  getControl_point () const
  {
    return this->control_point_.get ();
  }

  T_create_breakpoint_response::Control_pointType& T_create_breakpoint_response::
  getControl_point ()
  {
    return this->control_point_.get ();
  }

  void T_create_breakpoint_response::
  setControl_point (const Control_pointType& x)
  {
    this->control_point_.set (x);
  }

  const T_create_breakpoint_response::Stmt_handleType& T_create_breakpoint_response::
  getStmt_handle () const
  {
    return this->stmt_handle_.get ();
  }

  T_create_breakpoint_response::Stmt_handleType& T_create_breakpoint_response::
  getStmt_handle ()
  {
    return this->stmt_handle_.get ();
  }

  void T_create_breakpoint_response::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  const T_create_breakpoint_response::PositionOptional& T_create_breakpoint_response::
  getPosition () const
  {
    return this->position_;
  }

  T_create_breakpoint_response::PositionOptional& T_create_breakpoint_response::
  getPosition ()
  {
    return this->position_;
  }

  void T_create_breakpoint_response::
  setPosition (const PositionType& x)
  {
    this->position_.set (x);
  }

  void T_create_breakpoint_response::
  setPosition (const PositionOptional& x)
  {
    this->position_ = x;
  }

  void T_create_breakpoint_response::
  setPosition (::std::unique_ptr< PositionType > x)
  {
    this->position_.set (std::move (x));
  }


  // T_create_breakpoint_response_result
  // 

  T_create_breakpoint_response_result::
  T_create_breakpoint_response_result ()
  : ::xml_schema::String ()
  {
  }

  T_create_breakpoint_response_result::
  T_create_breakpoint_response_result (Value v)
  : ::xml_schema::String (_xsd_T_create_breakpoint_response_result_literals_[v])
  {
  }

  T_create_breakpoint_response_result::
  T_create_breakpoint_response_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_create_breakpoint_response_result::
  T_create_breakpoint_response_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_create_breakpoint_response_result::
  T_create_breakpoint_response_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_create_breakpoint_response_result::
  T_create_breakpoint_response_result (const T_create_breakpoint_response_result& v,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_create_breakpoint_response_result& T_create_breakpoint_response_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_create_breakpoint_response_result_literals_[v]);

    return *this;
  }


  // T_set_breakpoint_condition_response
  // 

  const T_set_breakpoint_condition_response::ResultType& T_set_breakpoint_condition_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_set_breakpoint_condition_response::ResultType& T_set_breakpoint_condition_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_set_breakpoint_condition_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_set_breakpoint_condition_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }

  const T_set_breakpoint_condition_response::ErrorType& T_set_breakpoint_condition_response::
  getError () const
  {
    return this->error_.get ();
  }

  T_set_breakpoint_condition_response::ErrorType& T_set_breakpoint_condition_response::
  getError ()
  {
    return this->error_.get ();
  }

  void T_set_breakpoint_condition_response::
  setError (const ErrorType& x)
  {
    this->error_.set (x);
  }

  void T_set_breakpoint_condition_response::
  setError (::std::unique_ptr< ErrorType > x)
  {
    this->error_.set (std::move (x));
  }


  // T_set_breakpoint_condition_response_result
  // 

  T_set_breakpoint_condition_response_result::
  T_set_breakpoint_condition_response_result ()
  : ::xml_schema::String ()
  {
  }

  T_set_breakpoint_condition_response_result::
  T_set_breakpoint_condition_response_result (Value v)
  : ::xml_schema::String (_xsd_T_set_breakpoint_condition_response_result_literals_[v])
  {
  }

  T_set_breakpoint_condition_response_result::
  T_set_breakpoint_condition_response_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_set_breakpoint_condition_response_result::
  T_set_breakpoint_condition_response_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_set_breakpoint_condition_response_result::
  T_set_breakpoint_condition_response_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_set_breakpoint_condition_response_result::
  T_set_breakpoint_condition_response_result (const T_set_breakpoint_condition_response_result& v,
                                              ::xml_schema::Flags f,
                                              ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_set_breakpoint_condition_response_result& T_set_breakpoint_condition_response_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_set_breakpoint_condition_response_result_literals_[v]);

    return *this;
  }


  // T_enable_breakpoint_response
  // 

  const T_enable_breakpoint_response::ResultType& T_enable_breakpoint_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_enable_breakpoint_response::ResultType& T_enable_breakpoint_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_enable_breakpoint_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_enable_breakpoint_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }


  // T_disable_breakpoint_response
  // 

  const T_disable_breakpoint_response::ResultType& T_disable_breakpoint_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_disable_breakpoint_response::ResultType& T_disable_breakpoint_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_disable_breakpoint_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_disable_breakpoint_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }


  // T_delete_breakpoint_response
  // 

  const T_delete_breakpoint_response::ResultType& T_delete_breakpoint_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_delete_breakpoint_response::ResultType& T_delete_breakpoint_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_delete_breakpoint_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_delete_breakpoint_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }


  // T_breakpoint_result
  // 

  const T_breakpoint_result::ResultType& T_breakpoint_result::
  getResult () const
  {
    return this->result_.get ();
  }

  T_breakpoint_result::ResultType& T_breakpoint_result::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_breakpoint_result::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_breakpoint_result::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }


  // T_breakpoint_result_result
  // 

  T_breakpoint_result_result::
  T_breakpoint_result_result ()
  : ::xml_schema::String ()
  {
  }

  T_breakpoint_result_result::
  T_breakpoint_result_result (Value v)
  : ::xml_schema::String (_xsd_T_breakpoint_result_result_literals_[v])
  {
  }

  T_breakpoint_result_result::
  T_breakpoint_result_result (const char* v)
  : ::xml_schema::String (v)
  {
  }

  T_breakpoint_result_result::
  T_breakpoint_result_result (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  T_breakpoint_result_result::
  T_breakpoint_result_result (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  T_breakpoint_result_result::
  T_breakpoint_result_result (const T_breakpoint_result_result& v,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  T_breakpoint_result_result& T_breakpoint_result_result::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_T_breakpoint_result_result_literals_[v]);

    return *this;
  }


  // T_var_list
  // 

  const T_var_list::VariableSequence& T_var_list::
  getVariable () const
  {
    return this->variable_;
  }

  T_var_list::VariableSequence& T_var_list::
  getVariable ()
  {
    return this->variable_;
  }

  void T_var_list::
  setVariable (const VariableSequence& s)
  {
    this->variable_ = s;
  }


  // T_variable
  // 

  const T_variable::NameType& T_variable::
  getName () const
  {
    return this->name_.get ();
  }

  T_variable::NameType& T_variable::
  getName ()
  {
    return this->name_.get ();
  }

  void T_variable::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_variable::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_variable::ClassOptional& T_variable::
  getClass () const
  {
    return this->class__;
  }

  T_variable::ClassOptional& T_variable::
  getClass ()
  {
    return this->class__;
  }

  void T_variable::
  setClass (const ClassType& x)
  {
    this->class__.set (x);
  }

  void T_variable::
  setClass (const ClassOptional& x)
  {
    this->class__ = x;
  }

  void T_variable::
  setClass (::std::unique_ptr< ClassType > x)
  {
    this->class__.set (std::move (x));
  }

  const T_variable::HandleType& T_variable::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_variable::HandleType& T_variable::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_variable::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  const T_variable::TypeType& T_variable::
  getType () const
  {
    return this->type_.get ();
  }

  T_variable::TypeType& T_variable::
  getType ()
  {
    return this->type_.get ();
  }

  void T_variable::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void T_variable::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }

  const T_variable::LiteralType& T_variable::
  getLiteral () const
  {
    return this->literal_.get ();
  }

  T_variable::LiteralType& T_variable::
  getLiteral ()
  {
    return this->literal_.get ();
  }

  void T_variable::
  setLiteral (const LiteralType& x)
  {
    this->literal_.set (x);
  }

  void T_variable::
  setLiteral (::std::unique_ptr< LiteralType > x)
  {
    this->literal_.set (std::move (x));
  }

  const T_variable::ObjectType& T_variable::
  getObject () const
  {
    return this->object_.get ();
  }

  T_variable::ObjectType& T_variable::
  getObject ()
  {
    return this->object_.get ();
  }

  void T_variable::
  setObject (const ObjectType& x)
  {
    this->object_.set (x);
  }


  // T_method_list
  // 

  const T_method_list::MethodSequence& T_method_list::
  getMethod () const
  {
    return this->method_;
  }

  T_method_list::MethodSequence& T_method_list::
  getMethod ()
  {
    return this->method_;
  }

  void T_method_list::
  setMethod (const MethodSequence& s)
  {
    this->method_ = s;
  }


  // T_method
  // 

  const T_method::NameType& T_method::
  getName () const
  {
    return this->name_.get ();
  }

  T_method::NameType& T_method::
  getName ()
  {
    return this->name_.get ();
  }

  void T_method::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_method::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_method::HandleType& T_method::
  getHandle () const
  {
    return this->handle_.get ();
  }

  T_method::HandleType& T_method::
  getHandle ()
  {
    return this->handle_.get ();
  }

  void T_method::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }


  // T_executiontree
  // 

  const T_executiontree::SequentialSequence& T_executiontree::
  getSequential () const
  {
    return this->sequential_;
  }

  T_executiontree::SequentialSequence& T_executiontree::
  getSequential ()
  {
    return this->sequential_;
  }

  void T_executiontree::
  setSequential (const SequentialSequence& s)
  {
    this->sequential_ = s;
  }

  const T_executiontree::Method_callSequence& T_executiontree::
  getMethod_call () const
  {
    return this->method_call_;
  }

  T_executiontree::Method_callSequence& T_executiontree::
  getMethod_call ()
  {
    return this->method_call_;
  }

  void T_executiontree::
  setMethod_call (const Method_callSequence& s)
  {
    this->method_call_ = s;
  }

  const T_executiontree::ParallelSequence& T_executiontree::
  getParallel () const
  {
    return this->parallel_;
  }

  T_executiontree::ParallelSequence& T_executiontree::
  getParallel ()
  {
    return this->parallel_;
  }

  void T_executiontree::
  setParallel (const ParallelSequence& s)
  {
    this->parallel_ = s;
  }

  const T_executiontree::SelectSequence& T_executiontree::
  getSelect () const
  {
    return this->select_;
  }

  T_executiontree::SelectSequence& T_executiontree::
  getSelect ()
  {
    return this->select_;
  }

  void T_executiontree::
  setSelect (const SelectSequence& s)
  {
    this->select_ = s;
  }

  const T_executiontree::StatementSequence& T_executiontree::
  getStatement () const
  {
    return this->statement_;
  }

  T_executiontree::StatementSequence& T_executiontree::
  getStatement ()
  {
    return this->statement_;
  }

  void T_executiontree::
  setStatement (const StatementSequence& s)
  {
    this->statement_ = s;
  }

  const T_executiontree::ExpressionSequence& T_executiontree::
  getExpression () const
  {
    return this->expression_;
  }

  T_executiontree::ExpressionSequence& T_executiontree::
  getExpression ()
  {
    return this->expression_;
  }

  void T_executiontree::
  setExpression (const ExpressionSequence& s)
  {
    this->expression_ = s;
  }

  const T_executiontree::Process_method_callSequence& T_executiontree::
  getProcess_method_call () const
  {
    return this->process_method_call_;
  }

  T_executiontree::Process_method_callSequence& T_executiontree::
  getProcess_method_call ()
  {
    return this->process_method_call_;
  }

  void T_executiontree::
  setProcess_method_call (const Process_method_callSequence& s)
  {
    this->process_method_call_ = s;
  }

  const T_executiontree::Message_sendSequence& T_executiontree::
  getMessage_send () const
  {
    return this->message_send_;
  }

  T_executiontree::Message_sendSequence& T_executiontree::
  getMessage_send ()
  {
    return this->message_send_;
  }

  void T_executiontree::
  setMessage_send (const Message_sendSequence& s)
  {
    this->message_send_ = s;
  }

  const T_executiontree::Message_receiveSequence& T_executiontree::
  getMessage_receive () const
  {
    return this->message_receive_;
  }

  T_executiontree::Message_receiveSequence& T_executiontree::
  getMessage_receive ()
  {
    return this->message_receive_;
  }

  void T_executiontree::
  setMessage_receive (const Message_receiveSequence& s)
  {
    this->message_receive_ = s;
  }

  const T_executiontree::GuardSequence& T_executiontree::
  getGuard () const
  {
    return this->guard_;
  }

  T_executiontree::GuardSequence& T_executiontree::
  getGuard ()
  {
    return this->guard_;
  }

  void T_executiontree::
  setGuard (const GuardSequence& s)
  {
    this->guard_ = s;
  }

  const T_executiontree::WhileSequence& T_executiontree::
  getWhile () const
  {
    return this->while__;
  }

  T_executiontree::WhileSequence& T_executiontree::
  getWhile ()
  {
    return this->while__;
  }

  void T_executiontree::
  setWhile (const WhileSequence& s)
  {
    this->while__ = s;
  }

  const T_executiontree::AbortSequence& T_executiontree::
  getAbort () const
  {
    return this->abort_;
  }

  T_executiontree::AbortSequence& T_executiontree::
  getAbort ()
  {
    return this->abort_;
  }

  void T_executiontree::
  setAbort (const AbortSequence& s)
  {
    this->abort_ = s;
  }

  const T_executiontree::InterruptSequence& T_executiontree::
  getInterrupt () const
  {
    return this->interrupt_;
  }

  T_executiontree::InterruptSequence& T_executiontree::
  getInterrupt ()
  {
    return this->interrupt_;
  }

  void T_executiontree::
  setInterrupt (const InterruptSequence& s)
  {
    this->interrupt_ = s;
  }

  const T_executiontree::SkipSequence& T_executiontree::
  getSkip () const
  {
    return this->skip_;
  }

  T_executiontree::SkipSequence& T_executiontree::
  getSkip ()
  {
    return this->skip_;
  }

  void T_executiontree::
  setSkip (const SkipSequence& s)
  {
    this->skip_ = s;
  }

  const T_executiontree::DelaySequence& T_executiontree::
  getDelay () const
  {
    return this->delay_;
  }

  T_executiontree::DelaySequence& T_executiontree::
  getDelay ()
  {
    return this->delay_;
  }

  void T_executiontree::
  setDelay (const DelaySequence& s)
  {
    this->delay_ = s;
  }

  const T_executiontree::Sequence_of_expressionsSequence& T_executiontree::
  getSequence_of_expressions () const
  {
    return this->sequence_of_expressions_;
  }

  T_executiontree::Sequence_of_expressionsSequence& T_executiontree::
  getSequence_of_expressions ()
  {
    return this->sequence_of_expressions_;
  }

  void T_executiontree::
  setSequence_of_expressions (const Sequence_of_expressionsSequence& s)
  {
    this->sequence_of_expressions_ = s;
  }

  const T_executiontree::AssignmentSequence& T_executiontree::
  getAssignment () const
  {
    return this->assignment_;
  }

  T_executiontree::AssignmentSequence& T_executiontree::
  getAssignment ()
  {
    return this->assignment_;
  }

  void T_executiontree::
  setAssignment (const AssignmentSequence& s)
  {
    this->assignment_ = s;
  }

  const T_executiontree::Data_method_callSequence& T_executiontree::
  getData_method_call () const
  {
    return this->data_method_call_;
  }

  T_executiontree::Data_method_callSequence& T_executiontree::
  getData_method_call ()
  {
    return this->data_method_call_;
  }

  void T_executiontree::
  setData_method_call (const Data_method_callSequence& s)
  {
    this->data_method_call_ = s;
  }

  const T_executiontree::ConstantSequence& T_executiontree::
  getConstant () const
  {
    return this->constant_;
  }

  T_executiontree::ConstantSequence& T_executiontree::
  getConstant ()
  {
    return this->constant_;
  }

  void T_executiontree::
  setConstant (const ConstantSequence& s)
  {
    this->constant_ = s;
  }

  const T_executiontree::VariableSequence& T_executiontree::
  getVariable () const
  {
    return this->variable_;
  }

  T_executiontree::VariableSequence& T_executiontree::
  getVariable ()
  {
    return this->variable_;
  }

  void T_executiontree::
  setVariable (const VariableSequence& s)
  {
    this->variable_ = s;
  }

  const T_executiontree::Binary_operationSequence& T_executiontree::
  getBinary_operation () const
  {
    return this->binary_operation_;
  }

  T_executiontree::Binary_operationSequence& T_executiontree::
  getBinary_operation ()
  {
    return this->binary_operation_;
  }

  void T_executiontree::
  setBinary_operation (const Binary_operationSequence& s)
  {
    this->binary_operation_ = s;
  }

  const T_executiontree::Unary_operationSequence& T_executiontree::
  getUnary_operation () const
  {
    return this->unary_operation_;
  }

  T_executiontree::Unary_operationSequence& T_executiontree::
  getUnary_operation ()
  {
    return this->unary_operation_;
  }

  void T_executiontree::
  setUnary_operation (const Unary_operationSequence& s)
  {
    this->unary_operation_ = s;
  }

  const T_executiontree::SelfSequence& T_executiontree::
  getSelf () const
  {
    return this->self_;
  }

  T_executiontree::SelfSequence& T_executiontree::
  getSelf ()
  {
    return this->self_;
  }

  void T_executiontree::
  setSelf (const SelfSequence& s)
  {
    this->self_ = s;
  }

  const T_executiontree::NilSequence& T_executiontree::
  getNil () const
  {
    return this->nil_;
  }

  T_executiontree::NilSequence& T_executiontree::
  getNil ()
  {
    return this->nil_;
  }

  void T_executiontree::
  setNil (const NilSequence& s)
  {
    this->nil_ = s;
  }

  const T_executiontree::Current_timeSequence& T_executiontree::
  getCurrent_time () const
  {
    return this->current_time_;
  }

  T_executiontree::Current_timeSequence& T_executiontree::
  getCurrent_time ()
  {
    return this->current_time_;
  }

  void T_executiontree::
  setCurrent_time (const Current_timeSequence& s)
  {
    this->current_time_ = s;
  }

  const T_executiontree::IfSequence& T_executiontree::
  getIf () const
  {
    return this->if__;
  }

  T_executiontree::IfSequence& T_executiontree::
  getIf ()
  {
    return this->if__;
  }

  void T_executiontree::
  setIf (const IfSequence& s)
  {
    this->if__ = s;
  }

  const T_executiontree::SwitchSequence& T_executiontree::
  getSwitch () const
  {
    return this->switch__;
  }

  T_executiontree::SwitchSequence& T_executiontree::
  getSwitch ()
  {
    return this->switch__;
  }

  void T_executiontree::
  setSwitch (const SwitchSequence& s)
  {
    this->switch__ = s;
  }

  const T_executiontree::NewSequence& T_executiontree::
  getNew () const
  {
    return this->new__;
  }

  T_executiontree::NewSequence& T_executiontree::
  getNew ()
  {
    return this->new__;
  }

  void T_executiontree::
  setNew (const NewSequence& s)
  {
    this->new__ = s;
  }

  const T_executiontree::ReturnSequence& T_executiontree::
  getReturn () const
  {
    return this->return__;
  }

  T_executiontree::ReturnSequence& T_executiontree::
  getReturn ()
  {
    return this->return__;
  }

  void T_executiontree::
  setReturn (const ReturnSequence& s)
  {
    this->return__ = s;
  }

  const T_executiontree::Execution_treeSequence& T_executiontree::
  getExecution_tree () const
  {
    return this->execution_tree_;
  }

  T_executiontree::Execution_treeSequence& T_executiontree::
  getExecution_tree ()
  {
    return this->execution_tree_;
  }

  void T_executiontree::
  setExecution_tree (const Execution_treeSequence& s)
  {
    this->execution_tree_ = s;
  }


  // T_executiontree_base
  // 

  const T_executiontree_base::ProcessOptional& T_executiontree_base::
  getProcess () const
  {
    return this->process_;
  }

  T_executiontree_base::ProcessOptional& T_executiontree_base::
  getProcess ()
  {
    return this->process_;
  }

  void T_executiontree_base::
  setProcess (const ProcessType& x)
  {
    this->process_.set (x);
  }

  void T_executiontree_base::
  setProcess (const ProcessOptional& x)
  {
    this->process_ = x;
  }

  const T_executiontree_base::ParentOptional& T_executiontree_base::
  getParent () const
  {
    return this->parent_;
  }

  T_executiontree_base::ParentOptional& T_executiontree_base::
  getParent ()
  {
    return this->parent_;
  }

  void T_executiontree_base::
  setParent (const ParentType& x)
  {
    this->parent_.set (x);
  }

  void T_executiontree_base::
  setParent (const ParentOptional& x)
  {
    this->parent_ = x;
  }

  const T_executiontree_base::HandleOptional& T_executiontree_base::
  getHandle () const
  {
    return this->handle_;
  }

  T_executiontree_base::HandleOptional& T_executiontree_base::
  getHandle ()
  {
    return this->handle_;
  }

  void T_executiontree_base::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  void T_executiontree_base::
  setHandle (const HandleOptional& x)
  {
    this->handle_ = x;
  }

  const T_executiontree_base::GlobalOptional& T_executiontree_base::
  getGlobal () const
  {
    return this->global_;
  }

  T_executiontree_base::GlobalOptional& T_executiontree_base::
  getGlobal ()
  {
    return this->global_;
  }

  void T_executiontree_base::
  setGlobal (const GlobalType& x)
  {
    this->global_.set (x);
  }

  void T_executiontree_base::
  setGlobal (const GlobalOptional& x)
  {
    this->global_ = x;
  }

  const T_executiontree_base::LocalOptional& T_executiontree_base::
  getLocal () const
  {
    return this->local_;
  }

  T_executiontree_base::LocalOptional& T_executiontree_base::
  getLocal ()
  {
    return this->local_;
  }

  void T_executiontree_base::
  setLocal (const LocalType& x)
  {
    this->local_.set (x);
  }

  void T_executiontree_base::
  setLocal (const LocalOptional& x)
  {
    this->local_ = x;
  }

  const T_executiontree_base::Stmt_handleOptional& T_executiontree_base::
  getStmt_handle () const
  {
    return this->stmt_handle_;
  }

  T_executiontree_base::Stmt_handleOptional& T_executiontree_base::
  getStmt_handle ()
  {
    return this->stmt_handle_;
  }

  void T_executiontree_base::
  setStmt_handle (const Stmt_handleType& x)
  {
    this->stmt_handle_.set (x);
  }

  void T_executiontree_base::
  setStmt_handle (const Stmt_handleOptional& x)
  {
    this->stmt_handle_ = x;
  }


  // T_executiontree_statements
  // 

  const T_executiontree_statements::StatementSequence& T_executiontree_statements::
  getStatement () const
  {
    return this->statement_;
  }

  T_executiontree_statements::StatementSequence& T_executiontree_statements::
  getStatement ()
  {
    return this->statement_;
  }

  void T_executiontree_statements::
  setStatement (const StatementSequence& s)
  {
    this->statement_ = s;
  }


  // T_executiontree_method_call
  // 

  const T_executiontree_method_call::NameType& T_executiontree_method_call::
  getName () const
  {
    return this->name_.get ();
  }

  T_executiontree_method_call::NameType& T_executiontree_method_call::
  getName ()
  {
    return this->name_.get ();
  }

  void T_executiontree_method_call::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_executiontree_method_call::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const T_executiontree_method_call::StateOptional& T_executiontree_method_call::
  getState () const
  {
    return this->state_;
  }

  T_executiontree_method_call::StateOptional& T_executiontree_method_call::
  getState ()
  {
    return this->state_;
  }

  void T_executiontree_method_call::
  setState (const StateType& x)
  {
    this->state_.set (x);
  }

  void T_executiontree_method_call::
  setState (const StateOptional& x)
  {
    this->state_ = x;
  }

  void T_executiontree_method_call::
  setState (::std::unique_ptr< StateType > x)
  {
    this->state_.set (std::move (x));
  }


  // T_executiontree_message_receive
  // 

  const T_executiontree_message_receive::PortOptional& T_executiontree_message_receive::
  getPort () const
  {
    return this->port_;
  }

  T_executiontree_message_receive::PortOptional& T_executiontree_message_receive::
  getPort ()
  {
    return this->port_;
  }

  void T_executiontree_message_receive::
  setPort (const PortType& x)
  {
    this->port_.set (x);
  }

  void T_executiontree_message_receive::
  setPort (const PortOptional& x)
  {
    this->port_ = x;
  }

  void T_executiontree_message_receive::
  setPort (::std::unique_ptr< PortType > x)
  {
    this->port_.set (std::move (x));
  }

  const T_executiontree_message_receive::MessageOptional& T_executiontree_message_receive::
  getMessage () const
  {
    return this->message_;
  }

  T_executiontree_message_receive::MessageOptional& T_executiontree_message_receive::
  getMessage ()
  {
    return this->message_;
  }

  void T_executiontree_message_receive::
  setMessage (const MessageType& x)
  {
    this->message_.set (x);
  }

  void T_executiontree_message_receive::
  setMessage (const MessageOptional& x)
  {
    this->message_ = x;
  }

  void T_executiontree_message_receive::
  setMessage (::std::unique_ptr< MessageType > x)
  {
    this->message_.set (std::move (x));
  }

  const T_executiontree_message_receive::Parameter_countOptional& T_executiontree_message_receive::
  getParameter_count () const
  {
    return this->parameter_count_;
  }

  T_executiontree_message_receive::Parameter_countOptional& T_executiontree_message_receive::
  getParameter_count ()
  {
    return this->parameter_count_;
  }

  void T_executiontree_message_receive::
  setParameter_count (const Parameter_countType& x)
  {
    this->parameter_count_.set (x);
  }

  void T_executiontree_message_receive::
  setParameter_count (const Parameter_countOptional& x)
  {
    this->parameter_count_ = x;
  }


  // T_executiontree_expression
  // 


  // T_cluster_instance_interface
  // 

  const T_cluster_instance_interface::PortSequence& T_cluster_instance_interface::
  getPort () const
  {
    return this->port_;
  }

  T_cluster_instance_interface::PortSequence& T_cluster_instance_interface::
  getPort ()
  {
    return this->port_;
  }

  void T_cluster_instance_interface::
  setPort (const PortSequence& s)
  {
    this->port_ = s;
  }


  // T_cluster_instance_port
  // 

  const T_cluster_instance_port::GraphicsOptional& T_cluster_instance_port::
  getGraphics () const
  {
    return this->graphics_;
  }

  T_cluster_instance_port::GraphicsOptional& T_cluster_instance_port::
  getGraphics ()
  {
    return this->graphics_;
  }

  void T_cluster_instance_port::
  setGraphics (const GraphicsType& x)
  {
    this->graphics_.set (x);
  }

  void T_cluster_instance_port::
  setGraphics (const GraphicsOptional& x)
  {
    this->graphics_ = x;
  }

  void T_cluster_instance_port::
  setGraphics (::std::unique_ptr< GraphicsType > x)
  {
    this->graphics_.set (std::move (x));
  }

  const T_cluster_instance_port::NameOptional& T_cluster_instance_port::
  getName () const
  {
    return this->name_;
  }

  T_cluster_instance_port::NameOptional& T_cluster_instance_port::
  getName ()
  {
    return this->name_;
  }

  void T_cluster_instance_port::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_cluster_instance_port::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void T_cluster_instance_port::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // T_graphics_port
  // 

  const T_graphics_port::LocationType& T_graphics_port::
  getLocation () const
  {
    return this->location_.get ();
  }

  T_graphics_port::LocationType& T_graphics_port::
  getLocation ()
  {
    return this->location_.get ();
  }

  void T_graphics_port::
  setLocation (const LocationType& x)
  {
    this->location_.set (x);
  }

  void T_graphics_port::
  setLocation (::std::unique_ptr< LocationType > x)
  {
    this->location_.set (std::move (x));
  }

  const T_graphics_port::Name_locationType& T_graphics_port::
  getName_location () const
  {
    return this->name_location_.get ();
  }

  T_graphics_port::Name_locationType& T_graphics_port::
  getName_location ()
  {
    return this->name_location_.get ();
  }

  void T_graphics_port::
  setName_location (const Name_locationType& x)
  {
    this->name_location_.set (x);
  }

  void T_graphics_port::
  setName_location (::std::unique_ptr< Name_locationType > x)
  {
    this->name_location_.set (std::move (x));
  }


  // T_graphics_channel
  // 

  const T_graphics_channel::NodeSequence& T_graphics_channel::
  getNode () const
  {
    return this->node_;
  }

  T_graphics_channel::NodeSequence& T_graphics_channel::
  getNode ()
  {
    return this->node_;
  }

  void T_graphics_channel::
  setNode (const NodeSequence& s)
  {
    this->node_ = s;
  }

  const T_graphics_channel::SegmentSequence& T_graphics_channel::
  getSegment () const
  {
    return this->segment_;
  }

  T_graphics_channel::SegmentSequence& T_graphics_channel::
  getSegment ()
  {
    return this->segment_;
  }

  void T_graphics_channel::
  setSegment (const SegmentSequence& s)
  {
    this->segment_ = s;
  }

  const T_graphics_channel::Name_locationType& T_graphics_channel::
  getName_location () const
  {
    return this->name_location_.get ();
  }

  T_graphics_channel::Name_locationType& T_graphics_channel::
  getName_location ()
  {
    return this->name_location_.get ();
  }

  void T_graphics_channel::
  setName_location (const Name_locationType& x)
  {
    this->name_location_.set (x);
  }

  void T_graphics_channel::
  setName_location (::std::unique_ptr< Name_locationType > x)
  {
    this->name_location_.set (std::move (x));
  }

  const T_graphics_channel::Message_locationType& T_graphics_channel::
  getMessage_location () const
  {
    return this->message_location_.get ();
  }

  T_graphics_channel::Message_locationType& T_graphics_channel::
  getMessage_location ()
  {
    return this->message_location_.get ();
  }

  void T_graphics_channel::
  setMessage_location (const Message_locationType& x)
  {
    this->message_location_.set (x);
  }

  void T_graphics_channel::
  setMessage_location (::std::unique_ptr< Message_locationType > x)
  {
    this->message_location_.set (std::move (x));
  }

  const T_graphics_channel::ScenarioSequence& T_graphics_channel::
  getScenario () const
  {
    return this->scenario_;
  }

  T_graphics_channel::ScenarioSequence& T_graphics_channel::
  getScenario ()
  {
    return this->scenario_;
  }

  void T_graphics_channel::
  setScenario (const ScenarioSequence& s)
  {
    this->scenario_ = s;
  }


  // T_channel_node
  // 

  const T_channel_node::NodeSequence& T_channel_node::
  getNode () const
  {
    return this->node_;
  }

  T_channel_node::NodeSequence& T_channel_node::
  getNode ()
  {
    return this->node_;
  }

  void T_channel_node::
  setNode (const NodeSequence& s)
  {
    this->node_ = s;
  }

  const T_channel_node::Instance_portSequence& T_channel_node::
  getInstance_port () const
  {
    return this->instance_port_;
  }

  T_channel_node::Instance_portSequence& T_channel_node::
  getInstance_port ()
  {
    return this->instance_port_;
  }

  void T_channel_node::
  setInstance_port (const Instance_portSequence& s)
  {
    this->instance_port_ = s;
  }

  const T_channel_node::Cluster_portSequence& T_channel_node::
  getCluster_port () const
  {
    return this->cluster_port_;
  }

  T_channel_node::Cluster_portSequence& T_channel_node::
  getCluster_port ()
  {
    return this->cluster_port_;
  }

  void T_channel_node::
  setCluster_port (const Cluster_portSequence& s)
  {
    this->cluster_port_ = s;
  }


  // T_message_location
  // 

  const T_message_location::WidthOptional& T_message_location::
  getWidth () const
  {
    return this->width_;
  }

  T_message_location::WidthOptional& T_message_location::
  getWidth ()
  {
    return this->width_;
  }

  void T_message_location::
  setWidth (const WidthType& x)
  {
    this->width_.set (x);
  }

  void T_message_location::
  setWidth (const WidthOptional& x)
  {
    this->width_ = x;
  }


  // T_scenario
  // 


  // T_inspector_instance
  // 

  const T_inspector_instance::ConnectionSequence& T_inspector_instance::
  getConnection () const
  {
    return this->connection_;
  }

  T_inspector_instance::ConnectionSequence& T_inspector_instance::
  getConnection ()
  {
    return this->connection_;
  }

  void T_inspector_instance::
  setConnection (const ConnectionSequence& s)
  {
    this->connection_ = s;
  }

  const T_inspector_instance::GraphicsOptional& T_inspector_instance::
  getGraphics () const
  {
    return this->graphics_;
  }

  T_inspector_instance::GraphicsOptional& T_inspector_instance::
  getGraphics ()
  {
    return this->graphics_;
  }

  void T_inspector_instance::
  setGraphics (const GraphicsType& x)
  {
    this->graphics_.set (x);
  }

  void T_inspector_instance::
  setGraphics (const GraphicsOptional& x)
  {
    this->graphics_ = x;
  }

  void T_inspector_instance::
  setGraphics (::std::unique_ptr< GraphicsType > x)
  {
    this->graphics_.set (std::move (x));
  }

  const T_inspector_instance::TypeOptional& T_inspector_instance::
  getType () const
  {
    return this->type_;
  }

  T_inspector_instance::TypeOptional& T_inspector_instance::
  getType ()
  {
    return this->type_;
  }

  void T_inspector_instance::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void T_inspector_instance::
  setType (const TypeOptional& x)
  {
    this->type_ = x;
  }

  void T_inspector_instance::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }

  const T_inspector_instance::ClassOptional& T_inspector_instance::
  getClass () const
  {
    return this->class__;
  }

  T_inspector_instance::ClassOptional& T_inspector_instance::
  getClass ()
  {
    return this->class__;
  }

  void T_inspector_instance::
  setClass (const ClassType& x)
  {
    this->class__.set (x);
  }

  void T_inspector_instance::
  setClass (const ClassOptional& x)
  {
    this->class__ = x;
  }

  void T_inspector_instance::
  setClass (::std::unique_ptr< ClassType > x)
  {
    this->class__.set (std::move (x));
  }

  const T_inspector_instance::NameOptional& T_inspector_instance::
  getName () const
  {
    return this->name_;
  }

  T_inspector_instance::NameOptional& T_inspector_instance::
  getName ()
  {
    return this->name_;
  }

  void T_inspector_instance::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void T_inspector_instance::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void T_inspector_instance::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // T_box_name_scenarios
  // 

  const T_box_name_scenarios::BoxType& T_box_name_scenarios::
  getBox () const
  {
    return this->box_.get ();
  }

  T_box_name_scenarios::BoxType& T_box_name_scenarios::
  getBox ()
  {
    return this->box_.get ();
  }

  void T_box_name_scenarios::
  setBox (const BoxType& x)
  {
    this->box_.set (x);
  }

  void T_box_name_scenarios::
  setBox (::std::unique_ptr< BoxType > x)
  {
    this->box_.set (std::move (x));
  }

  const T_box_name_scenarios::Name_locationType& T_box_name_scenarios::
  getName_location () const
  {
    return this->name_location_.get ();
  }

  T_box_name_scenarios::Name_locationType& T_box_name_scenarios::
  getName_location ()
  {
    return this->name_location_.get ();
  }

  void T_box_name_scenarios::
  setName_location (const Name_locationType& x)
  {
    this->name_location_.set (x);
  }

  void T_box_name_scenarios::
  setName_location (::std::unique_ptr< Name_locationType > x)
  {
    this->name_location_.set (std::move (x));
  }

  const T_box_name_scenarios::ScenarioSequence& T_box_name_scenarios::
  getScenario () const
  {
    return this->scenario_;
  }

  T_box_name_scenarios::ScenarioSequence& T_box_name_scenarios::
  getScenario ()
  {
    return this->scenario_;
  }

  void T_box_name_scenarios::
  setScenario (const ScenarioSequence& s)
  {
    this->scenario_ = s;
  }


  // T_set_variable_response
  // 

  const T_set_variable_response::ResultType& T_set_variable_response::
  getResult () const
  {
    return this->result_.get ();
  }

  T_set_variable_response::ResultType& T_set_variable_response::
  getResult ()
  {
    return this->result_.get ();
  }

  void T_set_variable_response::
  setResult (const ResultType& x)
  {
    this->result_.set (x);
  }

  void T_set_variable_response::
  setResult (::std::unique_ptr< ResultType > x)
  {
    this->result_.set (std::move (x));
  }

  const T_set_variable_response::Var_handleType& T_set_variable_response::
  getVar_handle () const
  {
    return this->var_handle_.get ();
  }

  T_set_variable_response::Var_handleType& T_set_variable_response::
  getVar_handle ()
  {
    return this->var_handle_.get ();
  }

  void T_set_variable_response::
  setVar_handle (const Var_handleType& x)
  {
    this->var_handle_.set (x);
  }

  void T_set_variable_response::
  setVar_handle (::std::unique_ptr< Var_handleType > x)
  {
    this->var_handle_.set (std::move (x));
  }

  const T_set_variable_response::List_handleType& T_set_variable_response::
  getList_handle () const
  {
    return this->list_handle_.get ();
  }

  T_set_variable_response::List_handleType& T_set_variable_response::
  getList_handle ()
  {
    return this->list_handle_.get ();
  }

  void T_set_variable_response::
  setList_handle (const List_handleType& x)
  {
    this->list_handle_.set (x);
  }

  void T_set_variable_response::
  setList_handle (::std::unique_ptr< List_handleType > x)
  {
    this->list_handle_.set (std::move (x));
  }

  const T_set_variable_response::ErrorType& T_set_variable_response::
  getError () const
  {
    return this->error_.get ();
  }

  T_set_variable_response::ErrorType& T_set_variable_response::
  getError ()
  {
    return this->error_.get ();
  }

  void T_set_variable_response::
  setError (const ErrorType& x)
  {
    this->error_.set (x);
  }

  void T_set_variable_response::
  setError (::std::unique_ptr< ErrorType > x)
  {
    this->error_.set (std::move (x));
  }


  // Response
  // 

  const Response::LoadOptional& Response::
  getLoad () const
  {
    return this->load_;
  }

  Response::LoadOptional& Response::
  getLoad ()
  {
    return this->load_;
  }

  void Response::
  setLoad (const LoadType& x)
  {
    this->load_.set (x);
  }

  void Response::
  setLoad (const LoadOptional& x)
  {
    this->load_ = x;
  }

  void Response::
  setLoad (::std::unique_ptr< LoadType > x)
  {
    this->load_.set (std::move (x));
  }

  const Response::SaveOptional& Response::
  getSave () const
  {
    return this->save_;
  }

  Response::SaveOptional& Response::
  getSave ()
  {
    return this->save_;
  }

  void Response::
  setSave (const SaveType& x)
  {
    this->save_.set (x);
  }

  void Response::
  setSave (const SaveOptional& x)
  {
    this->save_ = x;
  }

  void Response::
  setSave (::std::unique_ptr< SaveType > x)
  {
    this->save_.set (std::move (x));
  }

  const Response::SerializeOptional& Response::
  getSerialize () const
  {
    return this->serialize_;
  }

  Response::SerializeOptional& Response::
  getSerialize ()
  {
    return this->serialize_;
  }

  void Response::
  setSerialize (const SerializeType& x)
  {
    this->serialize_.set (x);
  }

  void Response::
  setSerialize (const SerializeOptional& x)
  {
    this->serialize_ = x;
  }

  void Response::
  setSerialize (::std::unique_ptr< SerializeType > x)
  {
    this->serialize_.set (std::move (x));
  }

  const Response::DeserializeOptional& Response::
  getDeserialize () const
  {
    return this->deserialize_;
  }

  Response::DeserializeOptional& Response::
  getDeserialize ()
  {
    return this->deserialize_;
  }

  void Response::
  setDeserialize (const DeserializeType& x)
  {
    this->deserialize_.set (x);
  }

  void Response::
  setDeserialize (const DeserializeOptional& x)
  {
    this->deserialize_ = x;
  }

  void Response::
  setDeserialize (::std::unique_ptr< DeserializeType > x)
  {
    this->deserialize_.set (std::move (x));
  }

  const Response::CompileOptional& Response::
  getCompile () const
  {
    return this->compile_;
  }

  Response::CompileOptional& Response::
  getCompile ()
  {
    return this->compile_;
  }

  void Response::
  setCompile (const CompileType& x)
  {
    this->compile_.set (x);
  }

  void Response::
  setCompile (const CompileOptional& x)
  {
    this->compile_ = x;
  }

  void Response::
  setCompile (::std::unique_ptr< CompileType > x)
  {
    this->compile_.set (std::move (x));
  }

  const Response::List_filesOptional& Response::
  getList_files () const
  {
    return this->list_files_;
  }

  Response::List_filesOptional& Response::
  getList_files ()
  {
    return this->list_files_;
  }

  void Response::
  setList_files (const List_filesType& x)
  {
    this->list_files_.set (x);
  }

  void Response::
  setList_files (const List_filesOptional& x)
  {
    this->list_files_ = x;
  }

  void Response::
  setList_files (::std::unique_ptr< List_filesType > x)
  {
    this->list_files_.set (std::move (x));
  }

  const Response::Get_positionOptional& Response::
  getGet_position () const
  {
    return this->get_position_;
  }

  Response::Get_positionOptional& Response::
  getGet_position ()
  {
    return this->get_position_;
  }

  void Response::
  setGet_position (const Get_positionType& x)
  {
    this->get_position_.set (x);
  }

  void Response::
  setGet_position (const Get_positionOptional& x)
  {
    this->get_position_ = x;
  }

  void Response::
  setGet_position (::std::unique_ptr< Get_positionType > x)
  {
    this->get_position_.set (std::move (x));
  }

  const Response::List_classesOptional& Response::
  getList_classes () const
  {
    return this->list_classes_;
  }

  Response::List_classesOptional& Response::
  getList_classes ()
  {
    return this->list_classes_;
  }

  void Response::
  setList_classes (const List_classesType& x)
  {
    this->list_classes_.set (x);
  }

  void Response::
  setList_classes (const List_classesOptional& x)
  {
    this->list_classes_ = x;
  }

  void Response::
  setList_classes (::std::unique_ptr< List_classesType > x)
  {
    this->list_classes_.set (std::move (x));
  }

  const Response::Get_top_level_specificationOptional& Response::
  getGet_top_level_specification () const
  {
    return this->get_top_level_specification_;
  }

  Response::Get_top_level_specificationOptional& Response::
  getGet_top_level_specification ()
  {
    return this->get_top_level_specification_;
  }

  void Response::
  setGet_top_level_specification (const Get_top_level_specificationType& x)
  {
    this->get_top_level_specification_.set (x);
  }

  void Response::
  setGet_top_level_specification (const Get_top_level_specificationOptional& x)
  {
    this->get_top_level_specification_ = x;
  }

  void Response::
  setGet_top_level_specification (::std::unique_ptr< Get_top_level_specificationType > x)
  {
    this->get_top_level_specification_.set (std::move (x));
  }

  const Response::Get_class_definitionOptional& Response::
  getGet_class_definition () const
  {
    return this->get_class_definition_;
  }

  Response::Get_class_definitionOptional& Response::
  getGet_class_definition ()
  {
    return this->get_class_definition_;
  }

  void Response::
  setGet_class_definition (const Get_class_definitionType& x)
  {
    this->get_class_definition_.set (x);
  }

  void Response::
  setGet_class_definition (const Get_class_definitionOptional& x)
  {
    this->get_class_definition_ = x;
  }

  void Response::
  setGet_class_definition (::std::unique_ptr< Get_class_definitionType > x)
  {
    this->get_class_definition_.set (std::move (x));
  }

  const Response::Get_method_definitionOptional& Response::
  getGet_method_definition () const
  {
    return this->get_method_definition_;
  }

  Response::Get_method_definitionOptional& Response::
  getGet_method_definition ()
  {
    return this->get_method_definition_;
  }

  void Response::
  setGet_method_definition (const Get_method_definitionType& x)
  {
    this->get_method_definition_.set (x);
  }

  void Response::
  setGet_method_definition (const Get_method_definitionOptional& x)
  {
    this->get_method_definition_ = x;
  }

  void Response::
  setGet_method_definition (::std::unique_ptr< Get_method_definitionType > x)
  {
    this->get_method_definition_.set (std::move (x));
  }

  const Response::Get_object_handleOptional& Response::
  getGet_object_handle () const
  {
    return this->get_object_handle_;
  }

  Response::Get_object_handleOptional& Response::
  getGet_object_handle ()
  {
    return this->get_object_handle_;
  }

  void Response::
  setGet_object_handle (const Get_object_handleType& x)
  {
    this->get_object_handle_.set (x);
  }

  void Response::
  setGet_object_handle (const Get_object_handleOptional& x)
  {
    this->get_object_handle_ = x;
  }

  void Response::
  setGet_object_handle (::std::unique_ptr< Get_object_handleType > x)
  {
    this->get_object_handle_.set (std::move (x));
  }

  const Response::Rename_object_responseOptional& Response::
  getRename_object_response () const
  {
    return this->rename_object_response_;
  }

  Response::Rename_object_responseOptional& Response::
  getRename_object_response ()
  {
    return this->rename_object_response_;
  }

  void Response::
  setRename_object_response (const Rename_object_responseType& x)
  {
    this->rename_object_response_.set (x);
  }

  void Response::
  setRename_object_response (const Rename_object_responseOptional& x)
  {
    this->rename_object_response_ = x;
  }

  void Response::
  setRename_object_response (::std::unique_ptr< Rename_object_responseType > x)
  {
    this->rename_object_response_.set (std::move (x));
  }

  const Response::Insert_object_responseOptional& Response::
  getInsert_object_response () const
  {
    return this->insert_object_response_;
  }

  Response::Insert_object_responseOptional& Response::
  getInsert_object_response ()
  {
    return this->insert_object_response_;
  }

  void Response::
  setInsert_object_response (const Insert_object_responseType& x)
  {
    this->insert_object_response_.set (x);
  }

  void Response::
  setInsert_object_response (const Insert_object_responseOptional& x)
  {
    this->insert_object_response_ = x;
  }

  void Response::
  setInsert_object_response (::std::unique_ptr< Insert_object_responseType > x)
  {
    this->insert_object_response_.set (std::move (x));
  }

  const Response::Delete_object_responseOptional& Response::
  getDelete_object_response () const
  {
    return this->delete_object_response_;
  }

  Response::Delete_object_responseOptional& Response::
  getDelete_object_response ()
  {
    return this->delete_object_response_;
  }

  void Response::
  setDelete_object_response (const Delete_object_responseType& x)
  {
    this->delete_object_response_.set (x);
  }

  void Response::
  setDelete_object_response (const Delete_object_responseOptional& x)
  {
    this->delete_object_response_ = x;
  }

  void Response::
  setDelete_object_response (::std::unique_ptr< Delete_object_responseType > x)
  {
    this->delete_object_response_.set (std::move (x));
  }

  const Response::InstantiateOptional& Response::
  getInstantiate () const
  {
    return this->instantiate_;
  }

  Response::InstantiateOptional& Response::
  getInstantiate ()
  {
    return this->instantiate_;
  }

  void Response::
  setInstantiate (const InstantiateType& x)
  {
    this->instantiate_.set (x);
  }

  void Response::
  setInstantiate (const InstantiateOptional& x)
  {
    this->instantiate_ = x;
  }

  void Response::
  setInstantiate (::std::unique_ptr< InstantiateType > x)
  {
    this->instantiate_.set (std::move (x));
  }

  const Response::CommandOptional& Response::
  getCommand () const
  {
    return this->command_;
  }

  Response::CommandOptional& Response::
  getCommand ()
  {
    return this->command_;
  }

  void Response::
  setCommand (const CommandType& x)
  {
    this->command_.set (x);
  }

  void Response::
  setCommand (const CommandOptional& x)
  {
    this->command_ = x;
  }

  void Response::
  setCommand (::std::unique_ptr< CommandType > x)
  {
    this->command_.set (std::move (x));
  }

  const Response::Execution_stateOptional& Response::
  getExecution_state () const
  {
    return this->execution_state_;
  }

  Response::Execution_stateOptional& Response::
  getExecution_state ()
  {
    return this->execution_state_;
  }

  void Response::
  setExecution_state (const Execution_stateType& x)
  {
    this->execution_state_.set (x);
  }

  void Response::
  setExecution_state (const Execution_stateOptional& x)
  {
    this->execution_state_ = x;
  }

  void Response::
  setExecution_state (::std::unique_ptr< Execution_stateType > x)
  {
    this->execution_state_.set (std::move (x));
  }

  const Response::Get_transitionsOptional& Response::
  getGet_transitions () const
  {
    return this->get_transitions_;
  }

  Response::Get_transitionsOptional& Response::
  getGet_transitions ()
  {
    return this->get_transitions_;
  }

  void Response::
  setGet_transitions (const Get_transitionsType& x)
  {
    this->get_transitions_.set (x);
  }

  void Response::
  setGet_transitions (const Get_transitionsOptional& x)
  {
    this->get_transitions_ = x;
  }

  void Response::
  setGet_transitions (::std::unique_ptr< Get_transitionsType > x)
  {
    this->get_transitions_.set (std::move (x));
  }

  const Response::Perform_transitionOptional& Response::
  getPerform_transition () const
  {
    return this->perform_transition_;
  }

  Response::Perform_transitionOptional& Response::
  getPerform_transition ()
  {
    return this->perform_transition_;
  }

  void Response::
  setPerform_transition (const Perform_transitionType& x)
  {
    this->perform_transition_.set (x);
  }

  void Response::
  setPerform_transition (const Perform_transitionOptional& x)
  {
    this->perform_transition_ = x;
  }

  void Response::
  setPerform_transition (::std::unique_ptr< Perform_transitionType > x)
  {
    this->perform_transition_.set (std::move (x));
  }

  const Response::InspectOptional& Response::
  getInspect () const
  {
    return this->inspect_;
  }

  Response::InspectOptional& Response::
  getInspect ()
  {
    return this->inspect_;
  }

  void Response::
  setInspect (const InspectType& x)
  {
    this->inspect_.set (x);
  }

  void Response::
  setInspect (const InspectOptional& x)
  {
    this->inspect_ = x;
  }

  void Response::
  setInspect (::std::unique_ptr< InspectType > x)
  {
    this->inspect_.set (std::move (x));
  }

  const Response::ObserveOptional& Response::
  getObserve () const
  {
    return this->observe_;
  }

  Response::ObserveOptional& Response::
  getObserve ()
  {
    return this->observe_;
  }

  void Response::
  setObserve (const ObserveType& x)
  {
    this->observe_.set (x);
  }

  void Response::
  setObserve (const ObserveOptional& x)
  {
    this->observe_ = x;
  }

  void Response::
  setObserve (::std::unique_ptr< ObserveType > x)
  {
    this->observe_.set (std::move (x));
  }

  const Response::Create_breakpointOptional& Response::
  getCreate_breakpoint () const
  {
    return this->create_breakpoint_;
  }

  Response::Create_breakpointOptional& Response::
  getCreate_breakpoint ()
  {
    return this->create_breakpoint_;
  }

  void Response::
  setCreate_breakpoint (const Create_breakpointType& x)
  {
    this->create_breakpoint_.set (x);
  }

  void Response::
  setCreate_breakpoint (const Create_breakpointOptional& x)
  {
    this->create_breakpoint_ = x;
  }

  void Response::
  setCreate_breakpoint (::std::unique_ptr< Create_breakpointType > x)
  {
    this->create_breakpoint_.set (std::move (x));
  }

  const Response::Set_breakpoint_conditionOptional& Response::
  getSet_breakpoint_condition () const
  {
    return this->set_breakpoint_condition_;
  }

  Response::Set_breakpoint_conditionOptional& Response::
  getSet_breakpoint_condition ()
  {
    return this->set_breakpoint_condition_;
  }

  void Response::
  setSet_breakpoint_condition (const Set_breakpoint_conditionType& x)
  {
    this->set_breakpoint_condition_.set (x);
  }

  void Response::
  setSet_breakpoint_condition (const Set_breakpoint_conditionOptional& x)
  {
    this->set_breakpoint_condition_ = x;
  }

  void Response::
  setSet_breakpoint_condition (::std::unique_ptr< Set_breakpoint_conditionType > x)
  {
    this->set_breakpoint_condition_.set (std::move (x));
  }

  const Response::Enable_breakpointOptional& Response::
  getEnable_breakpoint () const
  {
    return this->enable_breakpoint_;
  }

  Response::Enable_breakpointOptional& Response::
  getEnable_breakpoint ()
  {
    return this->enable_breakpoint_;
  }

  void Response::
  setEnable_breakpoint (const Enable_breakpointType& x)
  {
    this->enable_breakpoint_.set (x);
  }

  void Response::
  setEnable_breakpoint (const Enable_breakpointOptional& x)
  {
    this->enable_breakpoint_ = x;
  }

  void Response::
  setEnable_breakpoint (::std::unique_ptr< Enable_breakpointType > x)
  {
    this->enable_breakpoint_.set (std::move (x));
  }

  const Response::Disable_breakpointOptional& Response::
  getDisable_breakpoint () const
  {
    return this->disable_breakpoint_;
  }

  Response::Disable_breakpointOptional& Response::
  getDisable_breakpoint ()
  {
    return this->disable_breakpoint_;
  }

  void Response::
  setDisable_breakpoint (const Disable_breakpointType& x)
  {
    this->disable_breakpoint_.set (x);
  }

  void Response::
  setDisable_breakpoint (const Disable_breakpointOptional& x)
  {
    this->disable_breakpoint_ = x;
  }

  void Response::
  setDisable_breakpoint (::std::unique_ptr< Disable_breakpointType > x)
  {
    this->disable_breakpoint_.set (std::move (x));
  }

  const Response::Delete_breakpointOptional& Response::
  getDelete_breakpoint () const
  {
    return this->delete_breakpoint_;
  }

  Response::Delete_breakpointOptional& Response::
  getDelete_breakpoint ()
  {
    return this->delete_breakpoint_;
  }

  void Response::
  setDelete_breakpoint (const Delete_breakpointType& x)
  {
    this->delete_breakpoint_.set (x);
  }

  void Response::
  setDelete_breakpoint (const Delete_breakpointOptional& x)
  {
    this->delete_breakpoint_ = x;
  }

  void Response::
  setDelete_breakpoint (::std::unique_ptr< Delete_breakpointType > x)
  {
    this->delete_breakpoint_.set (std::move (x));
  }

  const Response::Eengine_event_setupOptional& Response::
  getEengine_event_setup () const
  {
    return this->eengine_event_setup_;
  }

  Response::Eengine_event_setupOptional& Response::
  getEengine_event_setup ()
  {
    return this->eengine_event_setup_;
  }

  void Response::
  setEengine_event_setup (const Eengine_event_setupType& x)
  {
    this->eengine_event_setup_.set (x);
  }

  void Response::
  setEengine_event_setup (const Eengine_event_setupOptional& x)
  {
    this->eengine_event_setup_ = x;
  }

  void Response::
  setEengine_event_setup (::std::unique_ptr< Eengine_event_setupType > x)
  {
    this->eengine_event_setup_.set (std::move (x));
  }

  const Response::Communication_eventOptional& Response::
  getCommunication_event () const
  {
    return this->communication_event_;
  }

  Response::Communication_eventOptional& Response::
  getCommunication_event ()
  {
    return this->communication_event_;
  }

  void Response::
  setCommunication_event (const Communication_eventType& x)
  {
    this->communication_event_.set (x);
  }

  void Response::
  setCommunication_event (const Communication_eventOptional& x)
  {
    this->communication_event_ = x;
  }

  void Response::
  setCommunication_event (::std::unique_ptr< Communication_eventType > x)
  {
    this->communication_event_.set (std::move (x));
  }

  const Response::Eengine_event_errorOptional& Response::
  getEengine_event_error () const
  {
    return this->eengine_event_error_;
  }

  Response::Eengine_event_errorOptional& Response::
  getEengine_event_error ()
  {
    return this->eengine_event_error_;
  }

  void Response::
  setEengine_event_error (const Eengine_event_errorType& x)
  {
    this->eengine_event_error_.set (x);
  }

  void Response::
  setEengine_event_error (const Eengine_event_errorOptional& x)
  {
    this->eengine_event_error_ = x;
  }

  void Response::
  setEengine_event_error (::std::unique_ptr< Eengine_event_errorType > x)
  {
    this->eengine_event_error_.set (std::move (x));
  }

  const Response::Set_variableOptional& Response::
  getSet_variable () const
  {
    return this->set_variable_;
  }

  Response::Set_variableOptional& Response::
  getSet_variable ()
  {
    return this->set_variable_;
  }

  void Response::
  setSet_variable (const Set_variableType& x)
  {
    this->set_variable_.set (x);
  }

  void Response::
  setSet_variable (const Set_variableOptional& x)
  {
    this->set_variable_ = x;
  }

  void Response::
  setSet_variable (::std::unique_ptr< Set_variableType > x)
  {
    this->set_variable_.set (std::move (x));
  }


  // File
  // 

  const File::HandleOptional& File::
  getHandle () const
  {
    return this->handle_;
  }

  File::HandleOptional& File::
  getHandle ()
  {
    return this->handle_;
  }

  void File::
  setHandle (const HandleType& x)
  {
    this->handle_.set (x);
  }

  void File::
  setHandle (const HandleOptional& x)
  {
    this->handle_ = x;
  }


  // Channel
  // 

  const Channel::NameType& Channel::
  getName () const
  {
    return this->name_.get ();
  }

  Channel::NameType& Channel::
  getName ()
  {
    return this->name_.get ();
  }

  void Channel::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Channel::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const Channel::Output_portOptional& Channel::
  getOutput_port () const
  {
    return this->output_port_;
  }

  Channel::Output_portOptional& Channel::
  getOutput_port ()
  {
    return this->output_port_;
  }

  void Channel::
  setOutput_port (const Output_portType& x)
  {
    this->output_port_.set (x);
  }

  void Channel::
  setOutput_port (const Output_portOptional& x)
  {
    this->output_port_ = x;
  }

  void Channel::
  setOutput_port (::std::unique_ptr< Output_portType > x)
  {
    this->output_port_.set (std::move (x));
  }


  // Aspect
  // 

  const Aspect::TypeType& Aspect::
  getType () const
  {
    return this->type_.get ();
  }

  Aspect::TypeType& Aspect::
  getType ()
  {
    return this->type_.get ();
  }

  void Aspect::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void Aspect::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }


  // Parameter
  // 

  const Parameter::ValueOptional& Parameter::
  getValue () const
  {
    return this->value_;
  }

  Parameter::ValueOptional& Parameter::
  getValue ()
  {
    return this->value_;
  }

  void Parameter::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }

  void Parameter::
  setValue (const ValueOptional& x)
  {
    this->value_ = x;
  }

  void Parameter::
  setValue (::std::unique_ptr< ValueType > x)
  {
    this->value_.set (std::move (x));
  }

  const Parameter::TypeOptional& Parameter::
  getType () const
  {
    return this->type_;
  }

  Parameter::TypeOptional& Parameter::
  getType ()
  {
    return this->type_;
  }

  void Parameter::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void Parameter::
  setType (const TypeOptional& x)
  {
    this->type_ = x;
  }

  void Parameter::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }


  // Node
  // 

  const Node::NumberType& Node::
  getNumber () const
  {
    return this->number_.get ();
  }

  Node::NumberType& Node::
  getNumber ()
  {
    return this->number_.get ();
  }

  void Node::
  setNumber (const NumberType& x)
  {
    this->number_.set (x);
  }


  // Instance_port
  // 

  const Instance_port::Instance_nameType& Instance_port::
  getInstance_name () const
  {
    return this->instance_name_.get ();
  }

  Instance_port::Instance_nameType& Instance_port::
  getInstance_name ()
  {
    return this->instance_name_.get ();
  }

  void Instance_port::
  setInstance_name (const Instance_nameType& x)
  {
    this->instance_name_.set (x);
  }

  void Instance_port::
  setInstance_name (::std::unique_ptr< Instance_nameType > x)
  {
    this->instance_name_.set (std::move (x));
  }

  const Instance_port::Port_nameType& Instance_port::
  getPort_name () const
  {
    return this->port_name_.get ();
  }

  Instance_port::Port_nameType& Instance_port::
  getPort_name ()
  {
    return this->port_name_.get ();
  }

  void Instance_port::
  setPort_name (const Port_nameType& x)
  {
    this->port_name_.set (x);
  }

  void Instance_port::
  setPort_name (::std::unique_ptr< Port_nameType > x)
  {
    this->port_name_.set (std::move (x));
  }


  // Cluster_port
  // 

  const Cluster_port::Port_nameType& Cluster_port::
  getPort_name () const
  {
    return this->port_name_.get ();
  }

  Cluster_port::Port_nameType& Cluster_port::
  getPort_name ()
  {
    return this->port_name_.get ();
  }

  void Cluster_port::
  setPort_name (const Port_nameType& x)
  {
    this->port_name_.set (x);
  }

  void Cluster_port::
  setPort_name (::std::unique_ptr< Port_nameType > x)
  {
    this->port_name_.set (std::move (x));
  }


  // Connection
  // 

  const Connection::GraphicsOptional& Connection::
  getGraphics () const
  {
    return this->graphics_;
  }

  Connection::GraphicsOptional& Connection::
  getGraphics ()
  {
    return this->graphics_;
  }

  void Connection::
  setGraphics (const GraphicsType& x)
  {
    this->graphics_.set (x);
  }

  void Connection::
  setGraphics (const GraphicsOptional& x)
  {
    this->graphics_ = x;
  }

  void Connection::
  setGraphics (::std::unique_ptr< GraphicsType > x)
  {
    this->graphics_.set (std::move (x));
  }

  const Connection::PortType& Connection::
  getPort () const
  {
    return this->port_.get ();
  }

  Connection::PortType& Connection::
  getPort ()
  {
    return this->port_.get ();
  }

  void Connection::
  setPort (const PortType& x)
  {
    this->port_.set (x);
  }

  void Connection::
  setPort (::std::unique_ptr< PortType > x)
  {
    this->port_.set (std::move (x));
  }

  const Connection::ChannelType& Connection::
  getChannel () const
  {
    return this->channel_.get ();
  }

  Connection::ChannelType& Connection::
  getChannel ()
  {
    return this->channel_.get ();
  }

  void Connection::
  setChannel (const ChannelType& x)
  {
    this->channel_.set (x);
  }

  void Connection::
  setChannel (::std::unique_ptr< ChannelType > x)
  {
    this->channel_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace poosl
{
  // T_load_response
  //

  T_load_response::
  T_load_response ()
  : ::xml_schema::Type (),
    result_ (this),
    error_ (this),
    contents_ (this)
  {
  }

  T_load_response::
  T_load_response (const ResultType& result,
                   const ErrorType& error,
                   const ContentsType& contents)
  : ::xml_schema::Type (),
    result_ (result, this),
    error_ (error, this),
    contents_ (contents, this)
  {
  }

  T_load_response::
  T_load_response (const T_load_response& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this),
    error_ (x.error_, f, this),
    contents_ (x.contents_, f, this)
  {
  }

  T_load_response::
  T_load_response (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this),
    error_ (this),
    contents_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_load_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ErrorType > r (
          ErrorTraits::create (i, f, this));

        if (!error_.present ())
        {
          this->error_.set (::std::move (r));
          continue;
        }
      }

      // contents
      //
      if (n.name () == "contents" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ContentsType > r (
          ContentsTraits::create (i, f, this));

        if (!contents_.present ())
        {
          this->contents_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }

    if (!error_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "error",
        "uri:poosl");
    }

    if (!contents_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "contents",
        "uri:poosl");
    }
  }

  T_load_response* T_load_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_load_response (*this, f, c);
  }

  T_load_response& T_load_response::
  operator= (const T_load_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
      this->error_ = x.error_;
      this->contents_ = x.contents_;
    }

    return *this;
  }

  T_load_response::
  ~T_load_response ()
  {
  }

  // T_save_response
  //

  T_save_response::
  T_save_response ()
  : ::xml_schema::Type (),
    result_ (this),
    error_ (this)
  {
  }

  T_save_response::
  T_save_response (const ResultType& result,
                   const ErrorType& error)
  : ::xml_schema::Type (),
    result_ (result, this),
    error_ (error, this)
  {
  }

  T_save_response::
  T_save_response (const T_save_response& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this),
    error_ (x.error_, f, this)
  {
  }

  T_save_response::
  T_save_response (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this),
    error_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_save_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ErrorType > r (
          ErrorTraits::create (i, f, this));

        if (!error_.present ())
        {
          this->error_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }

    if (!error_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "error",
        "uri:poosl");
    }
  }

  T_save_response* T_save_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_save_response (*this, f, c);
  }

  T_save_response& T_save_response::
  operator= (const T_save_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
      this->error_ = x.error_;
    }

    return *this;
  }

  T_save_response::
  ~T_save_response ()
  {
  }

  // T_file_io_result
  //

  T_file_io_result::
  T_file_io_result (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_file_io_result_convert ();
  }

  T_file_io_result::
  T_file_io_result (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_file_io_result_convert ();
  }

  T_file_io_result::
  T_file_io_result (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_file_io_result_convert ();
  }

  T_file_io_result* T_file_io_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_file_io_result (*this, f, c);
  }

  T_file_io_result::Value T_file_io_result::
  _xsd_T_file_io_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_file_io_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_file_io_result_indexes_,
                      _xsd_T_file_io_result_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_T_file_io_result_indexes_ + 5 || _xsd_T_file_io_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_file_io_result::
  _xsd_T_file_io_result_literals_[5] =
  {
    "OK",
    "file does not exist",
    "cannot create file",
    "disk full",
    "timed out"
  };

  const T_file_io_result::Value T_file_io_result::
  _xsd_T_file_io_result_indexes_[5] =
  {
    ::poosl::T_file_io_result::OK,
    ::poosl::T_file_io_result::cannot_create_file,
    ::poosl::T_file_io_result::disk_full,
    ::poosl::T_file_io_result::file_does_not_exist,
    ::poosl::T_file_io_result::timed_out
  };

  // T_serialize_response
  //

  T_serialize_response::
  T_serialize_response ()
  : ::xml_schema::Type (),
    result_ (this),
    contents_ (this)
  {
  }

  T_serialize_response::
  T_serialize_response (const ResultType& result,
                        const ContentsType& contents)
  : ::xml_schema::Type (),
    result_ (result, this),
    contents_ (contents, this)
  {
  }

  T_serialize_response::
  T_serialize_response (const T_serialize_response& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this),
    contents_ (x.contents_, f, this)
  {
  }

  T_serialize_response::
  T_serialize_response (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this),
    contents_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_serialize_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      // contents
      //
      if (n.name () == "contents" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ContentsType > r (
          ContentsTraits::create (i, f, this));

        if (!contents_.present ())
        {
          this->contents_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }

    if (!contents_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "contents",
        "uri:poosl");
    }
  }

  T_serialize_response* T_serialize_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_serialize_response (*this, f, c);
  }

  T_serialize_response& T_serialize_response::
  operator= (const T_serialize_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
      this->contents_ = x.contents_;
    }

    return *this;
  }

  T_serialize_response::
  ~T_serialize_response ()
  {
  }

  // T_deserialize_response
  //

  T_deserialize_response::
  T_deserialize_response ()
  : ::xml_schema::Type (),
    error_ (this),
    handle_ (this)
  {
  }

  T_deserialize_response::
  T_deserialize_response (const ErrorType& error,
                          const HandleType& handle)
  : ::xml_schema::Type (),
    error_ (error, this),
    handle_ (handle, this)
  {
  }

  T_deserialize_response::
  T_deserialize_response (const T_deserialize_response& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    error_ (x.error_, f, this),
    handle_ (x.handle_, f, this)
  {
  }

  T_deserialize_response::
  T_deserialize_response (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    error_ (this),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_deserialize_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ErrorType > r (
          ErrorTraits::create (i, f, this));

        if (!error_.present ())
        {
          this->error_.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!error_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "error",
        "uri:poosl");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }
  }

  T_deserialize_response* T_deserialize_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_deserialize_response (*this, f, c);
  }

  T_deserialize_response& T_deserialize_response::
  operator= (const T_deserialize_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->error_ = x.error_;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  T_deserialize_response::
  ~T_deserialize_response ()
  {
  }

  // T_compile_response
  //

  T_compile_response::
  T_compile_response ()
  : ::xml_schema::Type (),
    error_ (this),
    handle_ (this)
  {
  }

  T_compile_response::
  T_compile_response (const ErrorType& error,
                      const HandleType& handle)
  : ::xml_schema::Type (),
    error_ (error, this),
    handle_ (handle, this)
  {
  }

  T_compile_response::
  T_compile_response (const T_compile_response& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    error_ (x.error_, f, this),
    handle_ (x.handle_, f, this)
  {
  }

  T_compile_response::
  T_compile_response (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    error_ (this),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_compile_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ErrorType > r (
          ErrorTraits::create (i, f, this));

        if (!error_.present ())
        {
          this->error_.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!error_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "error",
        "uri:poosl");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }
  }

  T_compile_response* T_compile_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_compile_response (*this, f, c);
  }

  T_compile_response& T_compile_response::
  operator= (const T_compile_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->error_ = x.error_;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  T_compile_response::
  ~T_compile_response ()
  {
  }

  // T_serialize_result
  //

  T_serialize_result::
  T_serialize_result (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_serialize_result_convert ();
  }

  T_serialize_result::
  T_serialize_result (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_serialize_result_convert ();
  }

  T_serialize_result::
  T_serialize_result (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_serialize_result_convert ();
  }

  T_serialize_result* T_serialize_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_serialize_result (*this, f, c);
  }

  T_serialize_result::Value T_serialize_result::
  _xsd_T_serialize_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_serialize_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_serialize_result_indexes_,
                      _xsd_T_serialize_result_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_T_serialize_result_indexes_ + 2 || _xsd_T_serialize_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_serialize_result::
  _xsd_T_serialize_result_literals_[2] =
  {
    "ok",
    "unknown handle"
  };

  const T_serialize_result::Value T_serialize_result::
  _xsd_T_serialize_result_indexes_[2] =
  {
    ::poosl::T_serialize_result::ok,
    ::poosl::T_serialize_result::unknown_handle
  };

  // T_parse_result
  //

  T_parse_result::
  T_parse_result (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_parse_result_convert ();
  }

  T_parse_result::
  T_parse_result (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_parse_result_convert ();
  }

  T_parse_result::
  T_parse_result (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_parse_result_convert ();
  }

  T_parse_result* T_parse_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_parse_result (*this, f, c);
  }

  T_parse_result::Value T_parse_result::
  _xsd_T_parse_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_parse_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_parse_result_indexes_,
                      _xsd_T_parse_result_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_T_parse_result_indexes_ + 2 || _xsd_T_parse_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_parse_result::
  _xsd_T_parse_result_literals_[2] =
  {
    "ok",
    "failed to parse"
  };

  const T_parse_result::Value T_parse_result::
  _xsd_T_parse_result_indexes_[2] =
  {
    ::poosl::T_parse_result::failed_to_parse,
    ::poosl::T_parse_result::ok
  };

  // T_list_classes_response
  //

  T_list_classes_response::
  T_list_classes_response ()
  : ::xml_schema::Type (),
    class_name_ (this),
    handle_ (this)
  {
  }

  T_list_classes_response::
  T_list_classes_response (const T_list_classes_response& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    class_name_ (x.class_name_, f, this),
    handle_ (x.handle_, f, this)
  {
  }

  T_list_classes_response::
  T_list_classes_response (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    class_name_ (this),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_list_classes_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // class_name
      //
      if (n.name () == "class_name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Class_nameType > r (
          Class_nameTraits::create (i, f, this));

        this->class_name_.push_back (::std::move (r));
        continue;
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        this->handle_.push_back (HandleTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  T_list_classes_response* T_list_classes_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_list_classes_response (*this, f, c);
  }

  T_list_classes_response& T_list_classes_response::
  operator= (const T_list_classes_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->class_name_ = x.class_name_;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  T_list_classes_response::
  ~T_list_classes_response ()
  {
  }

  // T_list_files_response
  //

  T_list_files_response::
  T_list_files_response ()
  : ::xml_schema::Type (),
    file_ (this)
  {
  }

  T_list_files_response::
  T_list_files_response (const T_list_files_response& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    file_ (x.file_, f, this)
  {
  }

  T_list_files_response::
  T_list_files_response (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    file_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_list_files_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // file
      //
      if (n.name () == "file" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< FileType > r (
          FileTraits::create (i, f, this));

        this->file_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_list_files_response* T_list_files_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_list_files_response (*this, f, c);
  }

  T_list_files_response& T_list_files_response::
  operator= (const T_list_files_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->file_ = x.file_;
    }

    return *this;
  }

  T_list_files_response::
  ~T_list_files_response ()
  {
  }

  // T_get_position_response
  //

  T_get_position_response::
  T_get_position_response ()
  : ::xml_schema::Type (),
    stmt_handle_ (this),
    begin_ (this),
    end_ (this)
  {
  }

  T_get_position_response::
  T_get_position_response (const Stmt_handleType& stmt_handle,
                           const BeginType& begin,
                           const EndType& end)
  : ::xml_schema::Type (),
    stmt_handle_ (stmt_handle, this),
    begin_ (begin, this),
    end_ (end, this)
  {
  }

  T_get_position_response::
  T_get_position_response (const Stmt_handleType& stmt_handle,
                           ::std::unique_ptr< BeginType > begin,
                           ::std::unique_ptr< EndType > end)
  : ::xml_schema::Type (),
    stmt_handle_ (stmt_handle, this),
    begin_ (std::move (begin), this),
    end_ (std::move (end), this)
  {
  }

  T_get_position_response::
  T_get_position_response (const T_get_position_response& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    stmt_handle_ (x.stmt_handle_, f, this),
    begin_ (x.begin_, f, this),
    end_ (x.end_, f, this)
  {
  }

  T_get_position_response::
  T_get_position_response (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    stmt_handle_ (this),
    begin_ (this),
    end_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_get_position_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // stmt_handle
      //
      if (n.name () == "stmt_handle" && n.namespace_ () == "uri:poosl")
      {
        if (!stmt_handle_.present ())
        {
          this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
          continue;
        }
      }

      // begin
      //
      if (n.name () == "begin" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< BeginType > r (
          BeginTraits::create (i, f, this));

        if (!begin_.present ())
        {
          this->begin_.set (::std::move (r));
          continue;
        }
      }

      // end
      //
      if (n.name () == "end" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< EndType > r (
          EndTraits::create (i, f, this));

        if (!end_.present ())
        {
          this->end_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!stmt_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stmt_handle",
        "uri:poosl");
    }

    if (!begin_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "begin",
        "uri:poosl");
    }

    if (!end_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "end",
        "uri:poosl");
    }
  }

  T_get_position_response* T_get_position_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_get_position_response (*this, f, c);
  }

  T_get_position_response& T_get_position_response::
  operator= (const T_get_position_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->stmt_handle_ = x.stmt_handle_;
      this->begin_ = x.begin_;
      this->end_ = x.end_;
    }

    return *this;
  }

  T_get_position_response::
  ~T_get_position_response ()
  {
  }

  // T_get_top_level_specification_response
  //

  T_get_top_level_specification_response::
  T_get_top_level_specification_response ()
  : ::xml_schema::Type (),
    result_ (this),
    class_name_ (this),
    handle_ (this)
  {
  }

  T_get_top_level_specification_response::
  T_get_top_level_specification_response (const ResultType& result,
                                          const Class_nameType& class_name,
                                          const HandleType& handle)
  : ::xml_schema::Type (),
    result_ (result, this),
    class_name_ (class_name, this),
    handle_ (handle, this)
  {
  }

  T_get_top_level_specification_response::
  T_get_top_level_specification_response (const T_get_top_level_specification_response& x,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this),
    class_name_ (x.class_name_, f, this),
    handle_ (x.handle_, f, this)
  {
  }

  T_get_top_level_specification_response::
  T_get_top_level_specification_response (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this),
    class_name_ (this),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_get_top_level_specification_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      // class_name
      //
      if (n.name () == "class_name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Class_nameType > r (
          Class_nameTraits::create (i, f, this));

        if (!class_name_.present ())
        {
          this->class_name_.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }

    if (!class_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "class_name",
        "uri:poosl");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }
  }

  T_get_top_level_specification_response* T_get_top_level_specification_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_get_top_level_specification_response (*this, f, c);
  }

  T_get_top_level_specification_response& T_get_top_level_specification_response::
  operator= (const T_get_top_level_specification_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
      this->class_name_ = x.class_name_;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  T_get_top_level_specification_response::
  ~T_get_top_level_specification_response ()
  {
  }

  // T_get_class_definition_response
  //

  T_get_class_definition_response::
  T_get_class_definition_response ()
  : ::xml_schema::Type (),
    result_ (this),
    cluster_class_ (this),
    process_class_ (this),
    data_class_ (this)
  {
  }

  T_get_class_definition_response::
  T_get_class_definition_response (const ResultType& result)
  : ::xml_schema::Type (),
    result_ (result, this),
    cluster_class_ (this),
    process_class_ (this),
    data_class_ (this)
  {
  }

  T_get_class_definition_response::
  T_get_class_definition_response (const T_get_class_definition_response& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this),
    cluster_class_ (x.cluster_class_, f, this),
    process_class_ (x.process_class_, f, this),
    data_class_ (x.data_class_, f, this)
  {
  }

  T_get_class_definition_response::
  T_get_class_definition_response (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this),
    cluster_class_ (this),
    process_class_ (this),
    data_class_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_get_class_definition_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      // cluster_class
      //
      if (n.name () == "cluster_class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Cluster_classType > r (
          Cluster_classTraits::create (i, f, this));

        if (!this->cluster_class_)
        {
          this->cluster_class_.set (::std::move (r));
          continue;
        }
      }

      // process_class
      //
      if (n.name () == "process_class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_classType > r (
          Process_classTraits::create (i, f, this));

        if (!this->process_class_)
        {
          this->process_class_.set (::std::move (r));
          continue;
        }
      }

      // data_class
      //
      if (n.name () == "data_class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Data_classType > r (
          Data_classTraits::create (i, f, this));

        if (!this->data_class_)
        {
          this->data_class_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_get_class_definition_response* T_get_class_definition_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_get_class_definition_response (*this, f, c);
  }

  T_get_class_definition_response& T_get_class_definition_response::
  operator= (const T_get_class_definition_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
      this->cluster_class_ = x.cluster_class_;
      this->process_class_ = x.process_class_;
      this->data_class_ = x.data_class_;
    }

    return *this;
  }

  T_get_class_definition_response::
  ~T_get_class_definition_response ()
  {
  }

  // T_cluster_class_def
  //

  T_cluster_class_def::
  T_cluster_class_def ()
  : ::xml_schema::Type (),
    class__ (this),
    handle_ (this),
    instatiation_parameters_ (this),
    instance_ (this)
  {
  }

  T_cluster_class_def::
  T_cluster_class_def (const ClassType& class_,
                       const HandleType& handle,
                       const Instatiation_parametersType& instatiation_parameters)
  : ::xml_schema::Type (),
    class__ (class_, this),
    handle_ (handle, this),
    instatiation_parameters_ (instatiation_parameters, this),
    instance_ (this)
  {
  }

  T_cluster_class_def::
  T_cluster_class_def (const ClassType& class_,
                       const HandleType& handle,
                       ::std::unique_ptr< Instatiation_parametersType > instatiation_parameters)
  : ::xml_schema::Type (),
    class__ (class_, this),
    handle_ (handle, this),
    instatiation_parameters_ (std::move (instatiation_parameters), this),
    instance_ (this)
  {
  }

  T_cluster_class_def::
  T_cluster_class_def (const T_cluster_class_def& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    class__ (x.class__, f, this),
    handle_ (x.handle_, f, this),
    instatiation_parameters_ (x.instatiation_parameters_, f, this),
    instance_ (x.instance_, f, this)
  {
  }

  T_cluster_class_def::
  T_cluster_class_def (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    class__ (this),
    handle_ (this),
    instatiation_parameters_ (this),
    instance_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_cluster_class_def::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // class
      //
      if (n.name () == "class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ClassType > r (
          ClassTraits::create (i, f, this));

        if (!class__.present ())
        {
          this->class__.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      // instatiation_parameters
      //
      if (n.name () == "instatiation_parameters" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Instatiation_parametersType > r (
          Instatiation_parametersTraits::create (i, f, this));

        if (!instatiation_parameters_.present ())
        {
          this->instatiation_parameters_.set (::std::move (r));
          continue;
        }
      }

      // instance
      //
      if (n.name () == "instance" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InstanceType > r (
          InstanceTraits::create (i, f, this));

        this->instance_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!class__.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "class",
        "uri:poosl");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }

    if (!instatiation_parameters_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "instatiation_parameters",
        "uri:poosl");
    }
  }

  T_cluster_class_def* T_cluster_class_def::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_cluster_class_def (*this, f, c);
  }

  T_cluster_class_def& T_cluster_class_def::
  operator= (const T_cluster_class_def& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->class__ = x.class__;
      this->handle_ = x.handle_;
      this->instatiation_parameters_ = x.instatiation_parameters_;
      this->instance_ = x.instance_;
    }

    return *this;
  }

  T_cluster_class_def::
  ~T_cluster_class_def ()
  {
  }

  // T_process_class_def
  //

  T_process_class_def::
  T_process_class_def ()
  : ::xml_schema::Type (),
    class__ (this),
    handle_ (this),
    instatiation_parameters_ (this),
    interface_ (this),
    instance_variables_ (this),
    initial_method_call_ (this),
    methods_ (this)
  {
  }

  T_process_class_def::
  T_process_class_def (const ClassType& class_,
                       const HandleType& handle,
                       const Instatiation_parametersType& instatiation_parameters,
                       const InterfaceType& interface,
                       const Instance_variablesType& instance_variables,
                       const Initial_method_callType& initial_method_call,
                       const MethodsType& methods)
  : ::xml_schema::Type (),
    class__ (class_, this),
    handle_ (handle, this),
    instatiation_parameters_ (instatiation_parameters, this),
    interface_ (interface, this),
    instance_variables_ (instance_variables, this),
    initial_method_call_ (initial_method_call, this),
    methods_ (methods, this)
  {
  }

  T_process_class_def::
  T_process_class_def (const ClassType& class_,
                       const HandleType& handle,
                       ::std::unique_ptr< Instatiation_parametersType > instatiation_parameters,
                       ::std::unique_ptr< InterfaceType > interface,
                       ::std::unique_ptr< Instance_variablesType > instance_variables,
                       ::std::unique_ptr< Initial_method_callType > initial_method_call,
                       ::std::unique_ptr< MethodsType > methods)
  : ::xml_schema::Type (),
    class__ (class_, this),
    handle_ (handle, this),
    instatiation_parameters_ (std::move (instatiation_parameters), this),
    interface_ (std::move (interface), this),
    instance_variables_ (std::move (instance_variables), this),
    initial_method_call_ (std::move (initial_method_call), this),
    methods_ (std::move (methods), this)
  {
  }

  T_process_class_def::
  T_process_class_def (const T_process_class_def& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    class__ (x.class__, f, this),
    handle_ (x.handle_, f, this),
    instatiation_parameters_ (x.instatiation_parameters_, f, this),
    interface_ (x.interface_, f, this),
    instance_variables_ (x.instance_variables_, f, this),
    initial_method_call_ (x.initial_method_call_, f, this),
    methods_ (x.methods_, f, this)
  {
  }

  T_process_class_def::
  T_process_class_def (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    class__ (this),
    handle_ (this),
    instatiation_parameters_ (this),
    interface_ (this),
    instance_variables_ (this),
    initial_method_call_ (this),
    methods_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_process_class_def::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // class
      //
      if (n.name () == "class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ClassType > r (
          ClassTraits::create (i, f, this));

        if (!class__.present ())
        {
          this->class__.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      // instatiation_parameters
      //
      if (n.name () == "instatiation_parameters" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Instatiation_parametersType > r (
          Instatiation_parametersTraits::create (i, f, this));

        if (!instatiation_parameters_.present ())
        {
          this->instatiation_parameters_.set (::std::move (r));
          continue;
        }
      }

      // interface
      //
      if (n.name () == "interface" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InterfaceType > r (
          InterfaceTraits::create (i, f, this));

        if (!interface_.present ())
        {
          this->interface_.set (::std::move (r));
          continue;
        }
      }

      // instance_variables
      //
      if (n.name () == "instance_variables" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Instance_variablesType > r (
          Instance_variablesTraits::create (i, f, this));

        if (!instance_variables_.present ())
        {
          this->instance_variables_.set (::std::move (r));
          continue;
        }
      }

      // initial_method_call
      //
      if (n.name () == "initial_method_call" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Initial_method_callType > r (
          Initial_method_callTraits::create (i, f, this));

        if (!initial_method_call_.present ())
        {
          this->initial_method_call_.set (::std::move (r));
          continue;
        }
      }

      // methods
      //
      if (n.name () == "methods" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< MethodsType > r (
          MethodsTraits::create (i, f, this));

        if (!methods_.present ())
        {
          this->methods_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!class__.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "class",
        "uri:poosl");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }

    if (!instatiation_parameters_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "instatiation_parameters",
        "uri:poosl");
    }

    if (!interface_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "interface",
        "uri:poosl");
    }

    if (!instance_variables_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "instance_variables",
        "uri:poosl");
    }

    if (!initial_method_call_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "initial_method_call",
        "uri:poosl");
    }

    if (!methods_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "methods",
        "uri:poosl");
    }
  }

  T_process_class_def* T_process_class_def::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_process_class_def (*this, f, c);
  }

  T_process_class_def& T_process_class_def::
  operator= (const T_process_class_def& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->class__ = x.class__;
      this->handle_ = x.handle_;
      this->instatiation_parameters_ = x.instatiation_parameters_;
      this->interface_ = x.interface_;
      this->instance_variables_ = x.instance_variables_;
      this->initial_method_call_ = x.initial_method_call_;
      this->methods_ = x.methods_;
    }

    return *this;
  }

  T_process_class_def::
  ~T_process_class_def ()
  {
  }

  // T_data_class_def
  //

  T_data_class_def::
  T_data_class_def ()
  : ::xml_schema::Type (),
    class__ (this),
    handle_ (this),
    instance_variables_ (this),
    methods_ (this)
  {
  }

  T_data_class_def::
  T_data_class_def (const ClassType& class_,
                    const HandleType& handle,
                    const Instance_variablesType& instance_variables,
                    const MethodsType& methods)
  : ::xml_schema::Type (),
    class__ (class_, this),
    handle_ (handle, this),
    instance_variables_ (instance_variables, this),
    methods_ (methods, this)
  {
  }

  T_data_class_def::
  T_data_class_def (const ClassType& class_,
                    const HandleType& handle,
                    ::std::unique_ptr< Instance_variablesType > instance_variables,
                    ::std::unique_ptr< MethodsType > methods)
  : ::xml_schema::Type (),
    class__ (class_, this),
    handle_ (handle, this),
    instance_variables_ (std::move (instance_variables), this),
    methods_ (std::move (methods), this)
  {
  }

  T_data_class_def::
  T_data_class_def (const T_data_class_def& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    class__ (x.class__, f, this),
    handle_ (x.handle_, f, this),
    instance_variables_ (x.instance_variables_, f, this),
    methods_ (x.methods_, f, this)
  {
  }

  T_data_class_def::
  T_data_class_def (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    class__ (this),
    handle_ (this),
    instance_variables_ (this),
    methods_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_data_class_def::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // class
      //
      if (n.name () == "class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ClassType > r (
          ClassTraits::create (i, f, this));

        if (!class__.present ())
        {
          this->class__.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      // instance_variables
      //
      if (n.name () == "instance_variables" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Instance_variablesType > r (
          Instance_variablesTraits::create (i, f, this));

        if (!instance_variables_.present ())
        {
          this->instance_variables_.set (::std::move (r));
          continue;
        }
      }

      // methods
      //
      if (n.name () == "methods" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< MethodsType > r (
          MethodsTraits::create (i, f, this));

        if (!methods_.present ())
        {
          this->methods_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!class__.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "class",
        "uri:poosl");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }

    if (!instance_variables_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "instance_variables",
        "uri:poosl");
    }

    if (!methods_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "methods",
        "uri:poosl");
    }
  }

  T_data_class_def* T_data_class_def::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_data_class_def (*this, f, c);
  }

  T_data_class_def& T_data_class_def::
  operator= (const T_data_class_def& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->class__ = x.class__;
      this->handle_ = x.handle_;
      this->instance_variables_ = x.instance_variables_;
      this->methods_ = x.methods_;
    }

    return *this;
  }

  T_data_class_def::
  ~T_data_class_def ()
  {
  }

  // T_get_method_definition_response
  //

  T_get_method_definition_response::
  T_get_method_definition_response ()
  : ::xml_schema::Type (),
    result_ (this),
    process_method_ (this),
    data_method_ (this)
  {
  }

  T_get_method_definition_response::
  T_get_method_definition_response (const ResultType& result)
  : ::xml_schema::Type (),
    result_ (result, this),
    process_method_ (this),
    data_method_ (this)
  {
  }

  T_get_method_definition_response::
  T_get_method_definition_response (const T_get_method_definition_response& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this),
    process_method_ (x.process_method_, f, this),
    data_method_ (x.data_method_, f, this)
  {
  }

  T_get_method_definition_response::
  T_get_method_definition_response (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this),
    process_method_ (this),
    data_method_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_get_method_definition_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      // process_method
      //
      if (n.name () == "process_method" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_methodType > r (
          Process_methodTraits::create (i, f, this));

        if (!this->process_method_)
        {
          this->process_method_.set (::std::move (r));
          continue;
        }
      }

      // data_method
      //
      if (n.name () == "data_method" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Data_methodType > r (
          Data_methodTraits::create (i, f, this));

        if (!this->data_method_)
        {
          this->data_method_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_get_method_definition_response* T_get_method_definition_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_get_method_definition_response (*this, f, c);
  }

  T_get_method_definition_response& T_get_method_definition_response::
  operator= (const T_get_method_definition_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
      this->process_method_ = x.process_method_;
      this->data_method_ = x.data_method_;
    }

    return *this;
  }

  T_get_method_definition_response::
  ~T_get_method_definition_response ()
  {
  }

  // T_process_method_def
  //

  T_process_method_def::
  T_process_method_def ()
  : ::xml_schema::Type (),
    name_ (this),
    input_parameter_ (this),
    output_parameter_ (this),
    local_variable_ (this),
    body_text_ (this),
    body_statements_ (this)
  {
  }

  T_process_method_def::
  T_process_method_def (const Body_textType& body_text)
  : ::xml_schema::Type (),
    name_ (this),
    input_parameter_ (this),
    output_parameter_ (this),
    local_variable_ (this),
    body_text_ (body_text, this),
    body_statements_ (this)
  {
  }

  T_process_method_def::
  T_process_method_def (const T_process_method_def& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    input_parameter_ (x.input_parameter_, f, this),
    output_parameter_ (x.output_parameter_, f, this),
    local_variable_ (x.local_variable_, f, this),
    body_text_ (x.body_text_, f, this),
    body_statements_ (x.body_statements_, f, this)
  {
  }

  T_process_method_def::
  T_process_method_def (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    input_parameter_ (this),
    output_parameter_ (this),
    local_variable_ (this),
    body_text_ (this),
    body_statements_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_process_method_def::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // input_parameter
      //
      if (n.name () == "input_parameter" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Input_parameterType > r (
          Input_parameterTraits::create (i, f, this));

        this->input_parameter_.push_back (::std::move (r));
        continue;
      }

      // output_parameter
      //
      if (n.name () == "output_parameter" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Output_parameterType > r (
          Output_parameterTraits::create (i, f, this));

        this->output_parameter_.push_back (::std::move (r));
        continue;
      }

      // local_variable
      //
      if (n.name () == "local_variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Local_variableType > r (
          Local_variableTraits::create (i, f, this));

        this->local_variable_.push_back (::std::move (r));
        continue;
      }

      // body_text
      //
      if (n.name () == "body_text" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Body_textType > r (
          Body_textTraits::create (i, f, this));

        if (!body_text_.present ())
        {
          this->body_text_.set (::std::move (r));
          continue;
        }
      }

      // body_statements
      //
      if (n.name () == "body_statements" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Body_statementsType > r (
          Body_statementsTraits::create (i, f, this));

        if (!this->body_statements_)
        {
          this->body_statements_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!body_text_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "body_text",
        "uri:poosl");
    }
  }

  T_process_method_def* T_process_method_def::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_process_method_def (*this, f, c);
  }

  T_process_method_def& T_process_method_def::
  operator= (const T_process_method_def& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->input_parameter_ = x.input_parameter_;
      this->output_parameter_ = x.output_parameter_;
      this->local_variable_ = x.local_variable_;
      this->body_text_ = x.body_text_;
      this->body_statements_ = x.body_statements_;
    }

    return *this;
  }

  T_process_method_def::
  ~T_process_method_def ()
  {
  }

  // T_data_method_def
  //

  T_data_method_def::
  T_data_method_def ()
  : ::xml_schema::Type (),
    name_ (this),
    argument_ (this),
    local_variable_ (this),
    body_text_ (this),
    body_expression_ (this),
    return_type_ (this)
  {
  }

  T_data_method_def::
  T_data_method_def (const NameType& name,
                     const Body_textType& body_text,
                     const Return_typeType& return_type)
  : ::xml_schema::Type (),
    name_ (name, this),
    argument_ (this),
    local_variable_ (this),
    body_text_ (body_text, this),
    body_expression_ (this),
    return_type_ (return_type, this)
  {
  }

  T_data_method_def::
  T_data_method_def (const T_data_method_def& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    argument_ (x.argument_, f, this),
    local_variable_ (x.local_variable_, f, this),
    body_text_ (x.body_text_, f, this),
    body_expression_ (x.body_expression_, f, this),
    return_type_ (x.return_type_, f, this)
  {
  }

  T_data_method_def::
  T_data_method_def (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    argument_ (this),
    local_variable_ (this),
    body_text_ (this),
    body_expression_ (this),
    return_type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_data_method_def::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // argument
      //
      if (n.name () == "argument" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ArgumentType > r (
          ArgumentTraits::create (i, f, this));

        this->argument_.push_back (::std::move (r));
        continue;
      }

      // local_variable
      //
      if (n.name () == "local_variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Local_variableType > r (
          Local_variableTraits::create (i, f, this));

        this->local_variable_.push_back (::std::move (r));
        continue;
      }

      // body_text
      //
      if (n.name () == "body_text" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Body_textType > r (
          Body_textTraits::create (i, f, this));

        if (!body_text_.present ())
        {
          this->body_text_.set (::std::move (r));
          continue;
        }
      }

      // body_expression
      //
      if (n.name () == "body_expression" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Body_expressionType > r (
          Body_expressionTraits::create (i, f, this));

        if (!this->body_expression_)
        {
          this->body_expression_.set (::std::move (r));
          continue;
        }
      }

      // return_type
      //
      if (n.name () == "return_type" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Return_typeType > r (
          Return_typeTraits::create (i, f, this));

        if (!return_type_.present ())
        {
          this->return_type_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "uri:poosl");
    }

    if (!body_text_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "body_text",
        "uri:poosl");
    }

    if (!return_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "return_type",
        "uri:poosl");
    }
  }

  T_data_method_def* T_data_method_def::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_data_method_def (*this, f, c);
  }

  T_data_method_def& T_data_method_def::
  operator= (const T_data_method_def& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->argument_ = x.argument_;
      this->local_variable_ = x.local_variable_;
      this->body_text_ = x.body_text_;
      this->body_expression_ = x.body_expression_;
      this->return_type_ = x.return_type_;
    }

    return *this;
  }

  T_data_method_def::
  ~T_data_method_def ()
  {
  }

  // T_get_object_handle_response
  //

  T_get_object_handle_response::
  T_get_object_handle_response ()
  : ::xml_schema::Type (),
    result_ (this),
    handle_ (this)
  {
  }

  T_get_object_handle_response::
  T_get_object_handle_response (const ResultType& result,
                                const HandleType& handle)
  : ::xml_schema::Type (),
    result_ (result, this),
    handle_ (handle, this)
  {
  }

  T_get_object_handle_response::
  T_get_object_handle_response (const T_get_object_handle_response& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this),
    handle_ (x.handle_, f, this)
  {
  }

  T_get_object_handle_response::
  T_get_object_handle_response (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_get_object_handle_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }
  }

  T_get_object_handle_response* T_get_object_handle_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_get_object_handle_response (*this, f, c);
  }

  T_get_object_handle_response& T_get_object_handle_response::
  operator= (const T_get_object_handle_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  T_get_object_handle_response::
  ~T_get_object_handle_response ()
  {
  }

  // T_rename_object_response
  //

  T_rename_object_response::
  T_rename_object_response ()
  : ::xml_schema::Type (),
    result_ (this)
  {
  }

  T_rename_object_response::
  T_rename_object_response (const ResultType& result)
  : ::xml_schema::Type (),
    result_ (result, this)
  {
  }

  T_rename_object_response::
  T_rename_object_response (const T_rename_object_response& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this)
  {
  }

  T_rename_object_response::
  T_rename_object_response (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_rename_object_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_rename_object_response* T_rename_object_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_rename_object_response (*this, f, c);
  }

  T_rename_object_response& T_rename_object_response::
  operator= (const T_rename_object_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
    }

    return *this;
  }

  T_rename_object_response::
  ~T_rename_object_response ()
  {
  }

  // T_rename_object_response_result
  //

  T_rename_object_response_result::
  T_rename_object_response_result (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_rename_object_response_result_convert ();
  }

  T_rename_object_response_result::
  T_rename_object_response_result (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_rename_object_response_result_convert ();
  }

  T_rename_object_response_result::
  T_rename_object_response_result (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_rename_object_response_result_convert ();
  }

  T_rename_object_response_result* T_rename_object_response_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_rename_object_response_result (*this, f, c);
  }

  T_rename_object_response_result::Value T_rename_object_response_result::
  _xsd_T_rename_object_response_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_rename_object_response_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_rename_object_response_result_indexes_,
                      _xsd_T_rename_object_response_result_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_T_rename_object_response_result_indexes_ + 3 || _xsd_T_rename_object_response_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_rename_object_response_result::
  _xsd_T_rename_object_response_result_literals_[3] =
  {
    "ok",
    "name clash",
    "unknown handle"
  };

  const T_rename_object_response_result::Value T_rename_object_response_result::
  _xsd_T_rename_object_response_result_indexes_[3] =
  {
    ::poosl::T_rename_object_response_result::name_clash,
    ::poosl::T_rename_object_response_result::ok,
    ::poosl::T_rename_object_response_result::unknown_handle
  };

  // T_insert_object_response
  //

  T_insert_object_response::
  T_insert_object_response ()
  : ::xml_schema::Type (),
    result_ (this)
  {
  }

  T_insert_object_response::
  T_insert_object_response (const ResultType& result)
  : ::xml_schema::Type (),
    result_ (result, this)
  {
  }

  T_insert_object_response::
  T_insert_object_response (const T_insert_object_response& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this)
  {
  }

  T_insert_object_response::
  T_insert_object_response (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_insert_object_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_insert_object_response* T_insert_object_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_insert_object_response (*this, f, c);
  }

  T_insert_object_response& T_insert_object_response::
  operator= (const T_insert_object_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
    }

    return *this;
  }

  T_insert_object_response::
  ~T_insert_object_response ()
  {
  }

  // T_insert_object_response_result
  //

  T_insert_object_response_result::
  T_insert_object_response_result (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_insert_object_response_result_convert ();
  }

  T_insert_object_response_result::
  T_insert_object_response_result (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_insert_object_response_result_convert ();
  }

  T_insert_object_response_result::
  T_insert_object_response_result (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_insert_object_response_result_convert ();
  }

  T_insert_object_response_result* T_insert_object_response_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_insert_object_response_result (*this, f, c);
  }

  T_insert_object_response_result::Value T_insert_object_response_result::
  _xsd_T_insert_object_response_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_insert_object_response_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_insert_object_response_result_indexes_,
                      _xsd_T_insert_object_response_result_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_T_insert_object_response_result_indexes_ + 4 || _xsd_T_insert_object_response_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_insert_object_response_result::
  _xsd_T_insert_object_response_result_literals_[4] =
  {
    "ok",
    "unknown property",
    "invalid owner handle",
    "invalid value handle"
  };

  const T_insert_object_response_result::Value T_insert_object_response_result::
  _xsd_T_insert_object_response_result_indexes_[4] =
  {
    ::poosl::T_insert_object_response_result::invalid_owner_handle,
    ::poosl::T_insert_object_response_result::invalid_value_handle,
    ::poosl::T_insert_object_response_result::ok,
    ::poosl::T_insert_object_response_result::unknown_property
  };

  // T_delete_object_response
  //

  T_delete_object_response::
  T_delete_object_response ()
  : ::xml_schema::Type (),
    object_ (this),
    result_ (this)
  {
  }

  T_delete_object_response::
  T_delete_object_response (const T_delete_object_response& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    object_ (x.object_, f, this),
    result_ (x.result_, f, this)
  {
  }

  T_delete_object_response::
  T_delete_object_response (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    object_ (this),
    result_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_delete_object_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // object
      //
      if (n.name () == "object" && n.namespace_ () == "uri:poosl")
      {
        this->object_.push_back (ObjectTraits::create (i, f, this));
        continue;
      }

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        this->result_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_delete_object_response* T_delete_object_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_delete_object_response (*this, f, c);
  }

  T_delete_object_response& T_delete_object_response::
  operator= (const T_delete_object_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->object_ = x.object_;
      this->result_ = x.result_;
    }

    return *this;
  }

  T_delete_object_response::
  ~T_delete_object_response ()
  {
  }

  // T_object_query_result
  //

  T_object_query_result::
  T_object_query_result (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_object_query_result_convert ();
  }

  T_object_query_result::
  T_object_query_result (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_object_query_result_convert ();
  }

  T_object_query_result::
  T_object_query_result (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_object_query_result_convert ();
  }

  T_object_query_result* T_object_query_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_object_query_result (*this, f, c);
  }

  T_object_query_result::Value T_object_query_result::
  _xsd_T_object_query_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_object_query_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_object_query_result_indexes_,
                      _xsd_T_object_query_result_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_T_object_query_result_indexes_ + 3 || _xsd_T_object_query_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_object_query_result::
  _xsd_T_object_query_result_literals_[3] =
  {
    "ok",
    "unknown object",
    "unknown handle"
  };

  const T_object_query_result::Value T_object_query_result::
  _xsd_T_object_query_result_indexes_[3] =
  {
    ::poosl::T_object_query_result::ok,
    ::poosl::T_object_query_result::unknown_handle,
    ::poosl::T_object_query_result::unknown_object
  };

  // T_instantiate_response
  //

  T_instantiate_response::
  T_instantiate_response ()
  : ::xml_schema::Type (),
    result_ (this)
  {
  }

  T_instantiate_response::
  T_instantiate_response (const ResultType& result)
  : ::xml_schema::Type (),
    result_ (result, this)
  {
  }

  T_instantiate_response::
  T_instantiate_response (const T_instantiate_response& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this)
  {
  }

  T_instantiate_response::
  T_instantiate_response (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_instantiate_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_instantiate_response* T_instantiate_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_instantiate_response (*this, f, c);
  }

  T_instantiate_response& T_instantiate_response::
  operator= (const T_instantiate_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
    }

    return *this;
  }

  T_instantiate_response::
  ~T_instantiate_response ()
  {
  }

  // T_instantiate_result
  //

  T_instantiate_result::
  T_instantiate_result (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_instantiate_result_convert ();
  }

  T_instantiate_result::
  T_instantiate_result (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_instantiate_result_convert ();
  }

  T_instantiate_result::
  T_instantiate_result (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_instantiate_result_convert ();
  }

  T_instantiate_result* T_instantiate_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_instantiate_result (*this, f, c);
  }

  T_instantiate_result::Value T_instantiate_result::
  _xsd_T_instantiate_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_instantiate_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_instantiate_result_indexes_,
                      _xsd_T_instantiate_result_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_T_instantiate_result_indexes_ + 3 || _xsd_T_instantiate_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_instantiate_result::
  _xsd_T_instantiate_result_literals_[3] =
  {
    "ok",
    "invalid specification",
    "unknown handle"
  };

  const T_instantiate_result::Value T_instantiate_result::
  _xsd_T_instantiate_result_indexes_[3] =
  {
    ::poosl::T_instantiate_result::invalid_specification,
    ::poosl::T_instantiate_result::ok,
    ::poosl::T_instantiate_result::unknown_handle
  };

  // T_command_response
  //

  T_command_response::
  T_command_response ()
  : ::xml_schema::Type (),
    type_ (this),
    result_ (this)
  {
  }

  T_command_response::
  T_command_response (const T_command_response& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    type_ (x.type_, f, this),
    result_ (x.result_, f, this)
  {
  }

  T_command_response::
  T_command_response (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    type_ (this),
    result_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void T_command_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "result" && n.namespace_ ().empty ())
      {
        this->result_.set (ResultTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_command_response* T_command_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_command_response (*this, f, c);
  }

  T_command_response& T_command_response::
  operator= (const T_command_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->type_ = x.type_;
      this->result_ = x.result_;
    }

    return *this;
  }

  T_command_response::
  ~T_command_response ()
  {
  }

  // T_get_transitions_response
  //

  T_get_transitions_response::
  T_get_transitions_response ()
  : ::xml_schema::Type (),
    transitions_ (this)
  {
  }

  T_get_transitions_response::
  T_get_transitions_response (const TransitionsType& transitions)
  : ::xml_schema::Type (),
    transitions_ (transitions, this)
  {
  }

  T_get_transitions_response::
  T_get_transitions_response (::std::unique_ptr< TransitionsType > transitions)
  : ::xml_schema::Type (),
    transitions_ (std::move (transitions), this)
  {
  }

  T_get_transitions_response::
  T_get_transitions_response (const T_get_transitions_response& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    transitions_ (x.transitions_, f, this)
  {
  }

  T_get_transitions_response::
  T_get_transitions_response (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    transitions_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_get_transitions_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // transitions
      //
      if (n.name () == "transitions" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< TransitionsType > r (
          TransitionsTraits::create (i, f, this));

        if (!transitions_.present ())
        {
          this->transitions_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!transitions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "transitions",
        "uri:poosl");
    }
  }

  T_get_transitions_response* T_get_transitions_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_get_transitions_response (*this, f, c);
  }

  T_get_transitions_response& T_get_transitions_response::
  operator= (const T_get_transitions_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->transitions_ = x.transitions_;
    }

    return *this;
  }

  T_get_transitions_response::
  ~T_get_transitions_response ()
  {
  }

  // T_perform_transition_response
  //

  T_perform_transition_response::
  T_perform_transition_response ()
  : ::xml_schema::Type (),
    result_ (this)
  {
  }

  T_perform_transition_response::
  T_perform_transition_response (const ResultType& result)
  : ::xml_schema::Type (),
    result_ (result, this)
  {
  }

  T_perform_transition_response::
  T_perform_transition_response (const T_perform_transition_response& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this)
  {
  }

  T_perform_transition_response::
  T_perform_transition_response (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_perform_transition_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_perform_transition_response* T_perform_transition_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_perform_transition_response (*this, f, c);
  }

  T_perform_transition_response& T_perform_transition_response::
  operator= (const T_perform_transition_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
    }

    return *this;
  }

  T_perform_transition_response::
  ~T_perform_transition_response ()
  {
  }

  // T_perform_transition_response_result
  //

  T_perform_transition_response_result::
  T_perform_transition_response_result (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_perform_transition_response_result_convert ();
  }

  T_perform_transition_response_result::
  T_perform_transition_response_result (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_perform_transition_response_result_convert ();
  }

  T_perform_transition_response_result::
  T_perform_transition_response_result (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_perform_transition_response_result_convert ();
  }

  T_perform_transition_response_result* T_perform_transition_response_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_perform_transition_response_result (*this, f, c);
  }

  T_perform_transition_response_result::Value T_perform_transition_response_result::
  _xsd_T_perform_transition_response_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_perform_transition_response_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_perform_transition_response_result_indexes_,
                      _xsd_T_perform_transition_response_result_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_T_perform_transition_response_result_indexes_ + 4 || _xsd_T_perform_transition_response_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_perform_transition_response_result::
  _xsd_T_perform_transition_response_result_literals_[4] =
  {
    "ok",
    "inexecutable",
    "invalid transition",
    "invalid handle"
  };

  const T_perform_transition_response_result::Value T_perform_transition_response_result::
  _xsd_T_perform_transition_response_result_indexes_[4] =
  {
    ::poosl::T_perform_transition_response_result::inexecutable,
    ::poosl::T_perform_transition_response_result::invalid_handle,
    ::poosl::T_perform_transition_response_result::invalid_transition,
    ::poosl::T_perform_transition_response_result::ok
  };

  // T_inspect_response
  //

  T_inspect_response::
  T_inspect_response ()
  : ::xml_schema::Type (),
    name_ (this),
    handle_ (this),
    result_ (this),
    process_ (this),
    data_ (this),
    system_ (this),
    channel_ (this),
    stackframe_ (this),
    variable_ (this),
    variable_context_ (this),
    transition_ (this)
  {
  }

  T_inspect_response::
  T_inspect_response (const HandleType& handle,
                      const ResultType& result)
  : ::xml_schema::Type (),
    name_ (this),
    handle_ (handle, this),
    result_ (result, this),
    process_ (this),
    data_ (this),
    system_ (this),
    channel_ (this),
    stackframe_ (this),
    variable_ (this),
    variable_context_ (this),
    transition_ (this)
  {
  }

  T_inspect_response::
  T_inspect_response (const T_inspect_response& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    handle_ (x.handle_, f, this),
    result_ (x.result_, f, this),
    process_ (x.process_, f, this),
    data_ (x.data_, f, this),
    system_ (x.system_, f, this),
    channel_ (x.channel_, f, this),
    stackframe_ (x.stackframe_, f, this),
    variable_ (x.variable_, f, this),
    variable_context_ (x.variable_context_, f, this),
    transition_ (x.transition_, f, this)
  {
  }

  T_inspect_response::
  T_inspect_response (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    handle_ (this),
    result_ (this),
    process_ (this),
    data_ (this),
    system_ (this),
    channel_ (this),
    stackframe_ (this),
    variable_ (this),
    variable_context_ (this),
    transition_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_inspect_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!this->name_)
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      // process
      //
      if (n.name () == "process" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ProcessType > r (
          ProcessTraits::create (i, f, this));

        if (!this->process_)
        {
          this->process_.set (::std::move (r));
          continue;
        }
      }

      // data
      //
      if (n.name () == "data" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< DataType > r (
          DataTraits::create (i, f, this));

        if (!this->data_)
        {
          this->data_.set (::std::move (r));
          continue;
        }
      }

      // system
      //
      if (n.name () == "system" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SystemType > r (
          SystemTraits::create (i, f, this));

        if (!this->system_)
        {
          this->system_.set (::std::move (r));
          continue;
        }
      }

      // channel
      //
      if (n.name () == "channel" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ChannelType > r (
          ChannelTraits::create (i, f, this));

        if (!this->channel_)
        {
          this->channel_.set (::std::move (r));
          continue;
        }
      }

      // stackframe
      //
      if (n.name () == "stackframe" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< StackframeType > r (
          StackframeTraits::create (i, f, this));

        if (!this->stackframe_)
        {
          this->stackframe_.set (::std::move (r));
          continue;
        }
      }

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        if (!this->variable_)
        {
          this->variable_.set (::std::move (r));
          continue;
        }
      }

      // variable_context
      //
      if (n.name () == "variable_context" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Variable_contextType > r (
          Variable_contextTraits::create (i, f, this));

        if (!this->variable_context_)
        {
          this->variable_context_.set (::std::move (r));
          continue;
        }
      }

      // transition
      //
      if (n.name () == "transition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< TransitionType > r (
          TransitionTraits::create (i, f, this));

        if (!this->transition_)
        {
          this->transition_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_inspect_response* T_inspect_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_response (*this, f, c);
  }

  T_inspect_response& T_inspect_response::
  operator= (const T_inspect_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->handle_ = x.handle_;
      this->result_ = x.result_;
      this->process_ = x.process_;
      this->data_ = x.data_;
      this->system_ = x.system_;
      this->channel_ = x.channel_;
      this->stackframe_ = x.stackframe_;
      this->variable_ = x.variable_;
      this->variable_context_ = x.variable_context_;
      this->transition_ = x.transition_;
    }

    return *this;
  }

  T_inspect_response::
  ~T_inspect_response ()
  {
  }

  // T_inspect_process
  //

  T_inspect_process::
  T_inspect_process ()
  : ::xml_schema::Type (),
    instance_variables_ (this),
    execution_tree_ (this)
  {
  }

  T_inspect_process::
  T_inspect_process (const Instance_variablesType& instance_variables,
                     const Execution_treeType& execution_tree)
  : ::xml_schema::Type (),
    instance_variables_ (instance_variables, this),
    execution_tree_ (execution_tree, this)
  {
  }

  T_inspect_process::
  T_inspect_process (::std::unique_ptr< Instance_variablesType > instance_variables,
                     ::std::unique_ptr< Execution_treeType > execution_tree)
  : ::xml_schema::Type (),
    instance_variables_ (std::move (instance_variables), this),
    execution_tree_ (std::move (execution_tree), this)
  {
  }

  T_inspect_process::
  T_inspect_process (const T_inspect_process& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    instance_variables_ (x.instance_variables_, f, this),
    execution_tree_ (x.execution_tree_, f, this)
  {
  }

  T_inspect_process::
  T_inspect_process (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    instance_variables_ (this),
    execution_tree_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_inspect_process::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // instance_variables
      //
      if (n.name () == "instance_variables" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Instance_variablesType > r (
          Instance_variablesTraits::create (i, f, this));

        if (!instance_variables_.present ())
        {
          this->instance_variables_.set (::std::move (r));
          continue;
        }
      }

      // execution_tree
      //
      if (n.name () == "execution_tree" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Execution_treeType > r (
          Execution_treeTraits::create (i, f, this));

        if (!execution_tree_.present ())
        {
          this->execution_tree_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!instance_variables_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "instance_variables",
        "uri:poosl");
    }

    if (!execution_tree_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "execution_tree",
        "uri:poosl");
    }
  }

  T_inspect_process* T_inspect_process::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_process (*this, f, c);
  }

  T_inspect_process& T_inspect_process::
  operator= (const T_inspect_process& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->instance_variables_ = x.instance_variables_;
      this->execution_tree_ = x.execution_tree_;
    }

    return *this;
  }

  T_inspect_process::
  ~T_inspect_process ()
  {
  }

  // T_inspect_port
  //

  T_inspect_port::
  T_inspect_port ()
  : ::xml_schema::Type (),
    name_ (this),
    up_channel_ (this),
    down_channel_ (this)
  {
  }

  T_inspect_port::
  T_inspect_port (const NameType& name)
  : ::xml_schema::Type (),
    name_ (name, this),
    up_channel_ (this),
    down_channel_ (this)
  {
  }

  T_inspect_port::
  T_inspect_port (const T_inspect_port& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    up_channel_ (x.up_channel_, f, this),
    down_channel_ (x.down_channel_, f, this)
  {
  }

  T_inspect_port::
  T_inspect_port (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    up_channel_ (this),
    down_channel_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_inspect_port::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // up_channel
      //
      if (n.name () == "up_channel" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Up_channelType > r (
          Up_channelTraits::create (i, f, this));

        if (!this->up_channel_)
        {
          this->up_channel_.set (::std::move (r));
          continue;
        }
      }

      // down_channel
      //
      if (n.name () == "down_channel" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Down_channelType > r (
          Down_channelTraits::create (i, f, this));

        if (!this->down_channel_)
        {
          this->down_channel_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "uri:poosl");
    }
  }

  T_inspect_port* T_inspect_port::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_port (*this, f, c);
  }

  T_inspect_port& T_inspect_port::
  operator= (const T_inspect_port& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->up_channel_ = x.up_channel_;
      this->down_channel_ = x.down_channel_;
    }

    return *this;
  }

  T_inspect_port::
  ~T_inspect_port ()
  {
  }

  // T_inspect_instance
  //

  T_inspect_instance::
  T_inspect_instance ()
  : ::xml_schema::Type (),
    name_ (this),
    type_ (this),
    process_path_ (this),
    cluster_ (this),
    port_ (this)
  {
  }

  T_inspect_instance::
  T_inspect_instance (const NameType& name,
                      const TypeType& type,
                      const Process_pathType& process_path)
  : ::xml_schema::Type (),
    name_ (name, this),
    type_ (type, this),
    process_path_ (process_path, this),
    cluster_ (this),
    port_ (this)
  {
  }

  T_inspect_instance::
  T_inspect_instance (const T_inspect_instance& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    type_ (x.type_, f, this),
    process_path_ (x.process_path_, f, this),
    cluster_ (x.cluster_, f, this),
    port_ (x.port_, f, this)
  {
  }

  T_inspect_instance::
  T_inspect_instance (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    type_ (this),
    process_path_ (this),
    cluster_ (this),
    port_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_inspect_instance::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< TypeType > r (
          TypeTraits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (::std::move (r));
          continue;
        }
      }

      // process_path
      //
      if (n.name () == "process_path" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_pathType > r (
          Process_pathTraits::create (i, f, this));

        if (!process_path_.present ())
        {
          this->process_path_.set (::std::move (r));
          continue;
        }
      }

      // cluster
      //
      if (n.name () == "cluster" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ClusterType > r (
          ClusterTraits::create (i, f, this));

        if (!this->cluster_)
        {
          this->cluster_.set (::std::move (r));
          continue;
        }
      }

      // port
      //
      if (n.name () == "port" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< PortType > r (
          PortTraits::create (i, f, this));

        this->port_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "uri:poosl");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "uri:poosl");
    }

    if (!process_path_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "process_path",
        "uri:poosl");
    }
  }

  T_inspect_instance* T_inspect_instance::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_instance (*this, f, c);
  }

  T_inspect_instance& T_inspect_instance::
  operator= (const T_inspect_instance& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->type_ = x.type_;
      this->process_path_ = x.process_path_;
      this->cluster_ = x.cluster_;
      this->port_ = x.port_;
    }

    return *this;
  }

  T_inspect_instance::
  ~T_inspect_instance ()
  {
  }

  // T_inspect_cluster
  //

  T_inspect_cluster::
  T_inspect_cluster ()
  : ::xml_schema::Type (),
    channel_ (this),
    instance_ (this)
  {
  }

  T_inspect_cluster::
  T_inspect_cluster (const T_inspect_cluster& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    channel_ (x.channel_, f, this),
    instance_ (x.instance_, f, this)
  {
  }

  T_inspect_cluster::
  T_inspect_cluster (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    channel_ (this),
    instance_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_inspect_cluster::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // channel
      //
      if (n.name () == "channel" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ChannelType > r (
          ChannelTraits::create (i, f, this));

        this->channel_.push_back (::std::move (r));
        continue;
      }

      // instance
      //
      if (n.name () == "instance" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InstanceType > r (
          InstanceTraits::create (i, f, this));

        this->instance_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_inspect_cluster* T_inspect_cluster::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_cluster (*this, f, c);
  }

  T_inspect_cluster& T_inspect_cluster::
  operator= (const T_inspect_cluster& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->channel_ = x.channel_;
      this->instance_ = x.instance_;
    }

    return *this;
  }

  T_inspect_cluster::
  ~T_inspect_cluster ()
  {
  }

  // T_inspect_system
  //

  T_inspect_system::
  T_inspect_system ()
  : ::xml_schema::Type (),
    channel_ (this),
    instance_ (this)
  {
  }

  T_inspect_system::
  T_inspect_system (const T_inspect_system& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    channel_ (x.channel_, f, this),
    instance_ (x.instance_, f, this)
  {
  }

  T_inspect_system::
  T_inspect_system (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    channel_ (this),
    instance_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_inspect_system::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // channel
      //
      if (n.name () == "channel" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ChannelType > r (
          ChannelTraits::create (i, f, this));

        this->channel_.push_back (::std::move (r));
        continue;
      }

      // instance
      //
      if (n.name () == "instance" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InstanceType > r (
          InstanceTraits::create (i, f, this));

        this->instance_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_inspect_system* T_inspect_system::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_system (*this, f, c);
  }

  T_inspect_system& T_inspect_system::
  operator= (const T_inspect_system& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->channel_ = x.channel_;
      this->instance_ = x.instance_;
    }

    return *this;
  }

  T_inspect_system::
  ~T_inspect_system ()
  {
  }

  // T_inspect_channel
  //

  T_inspect_channel::
  T_inspect_channel ()
  : ::xml_schema::Type (),
    name_ (this),
    is_root_ (this)
  {
  }

  T_inspect_channel::
  T_inspect_channel (const NameType& name,
                     const Is_rootType& is_root)
  : ::xml_schema::Type (),
    name_ (name, this),
    is_root_ (is_root, this)
  {
  }

  T_inspect_channel::
  T_inspect_channel (const T_inspect_channel& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    is_root_ (x.is_root_, f, this)
  {
  }

  T_inspect_channel::
  T_inspect_channel (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    is_root_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_inspect_channel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // is_root
      //
      if (n.name () == "is_root" && n.namespace_ () == "uri:poosl")
      {
        if (!is_root_.present ())
        {
          this->is_root_.set (Is_rootTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "uri:poosl");
    }

    if (!is_root_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "is_root",
        "uri:poosl");
    }
  }

  T_inspect_channel* T_inspect_channel::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_channel (*this, f, c);
  }

  T_inspect_channel& T_inspect_channel::
  operator= (const T_inspect_channel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->is_root_ = x.is_root_;
    }

    return *this;
  }

  T_inspect_channel::
  ~T_inspect_channel ()
  {
  }

  // T_stackframe
  //

  T_stackframe::
  T_stackframe ()
  : ::xml_schema::Type (),
    dataclass_handle_ (this),
    dataclass_name_ (this),
    method_name_ (this),
    local_variables_ (this),
    downframe_ (this),
    upframe_ (this)
  {
  }

  T_stackframe::
  T_stackframe (const Dataclass_handleType& dataclass_handle,
                const Dataclass_nameType& dataclass_name,
                const Method_nameType& method_name,
                const Local_variablesType& local_variables,
                const DownframeType& downframe,
                const UpframeType& upframe)
  : ::xml_schema::Type (),
    dataclass_handle_ (dataclass_handle, this),
    dataclass_name_ (dataclass_name, this),
    method_name_ (method_name, this),
    local_variables_ (local_variables, this),
    downframe_ (downframe, this),
    upframe_ (upframe, this)
  {
  }

  T_stackframe::
  T_stackframe (const Dataclass_handleType& dataclass_handle,
                const Dataclass_nameType& dataclass_name,
                const Method_nameType& method_name,
                ::std::unique_ptr< Local_variablesType > local_variables,
                const DownframeType& downframe,
                const UpframeType& upframe)
  : ::xml_schema::Type (),
    dataclass_handle_ (dataclass_handle, this),
    dataclass_name_ (dataclass_name, this),
    method_name_ (method_name, this),
    local_variables_ (std::move (local_variables), this),
    downframe_ (downframe, this),
    upframe_ (upframe, this)
  {
  }

  T_stackframe::
  T_stackframe (const T_stackframe& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dataclass_handle_ (x.dataclass_handle_, f, this),
    dataclass_name_ (x.dataclass_name_, f, this),
    method_name_ (x.method_name_, f, this),
    local_variables_ (x.local_variables_, f, this),
    downframe_ (x.downframe_, f, this),
    upframe_ (x.upframe_, f, this)
  {
  }

  T_stackframe::
  T_stackframe (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dataclass_handle_ (this),
    dataclass_name_ (this),
    method_name_ (this),
    local_variables_ (this),
    downframe_ (this),
    upframe_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_stackframe::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dataclass_handle
      //
      if (n.name () == "dataclass_handle" && n.namespace_ () == "uri:poosl")
      {
        if (!dataclass_handle_.present ())
        {
          this->dataclass_handle_.set (Dataclass_handleTraits::create (i, f, this));
          continue;
        }
      }

      // dataclass_name
      //
      if (n.name () == "dataclass_name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Dataclass_nameType > r (
          Dataclass_nameTraits::create (i, f, this));

        if (!dataclass_name_.present ())
        {
          this->dataclass_name_.set (::std::move (r));
          continue;
        }
      }

      // method_name
      //
      if (n.name () == "method_name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Method_nameType > r (
          Method_nameTraits::create (i, f, this));

        if (!method_name_.present ())
        {
          this->method_name_.set (::std::move (r));
          continue;
        }
      }

      // local_variables
      //
      if (n.name () == "local_variables" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Local_variablesType > r (
          Local_variablesTraits::create (i, f, this));

        if (!local_variables_.present ())
        {
          this->local_variables_.set (::std::move (r));
          continue;
        }
      }

      // downframe
      //
      if (n.name () == "downframe" && n.namespace_ () == "uri:poosl")
      {
        if (!downframe_.present ())
        {
          this->downframe_.set (DownframeTraits::create (i, f, this));
          continue;
        }
      }

      // upframe
      //
      if (n.name () == "upframe" && n.namespace_ () == "uri:poosl")
      {
        if (!upframe_.present ())
        {
          this->upframe_.set (UpframeTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!dataclass_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dataclass_handle",
        "uri:poosl");
    }

    if (!dataclass_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dataclass_name",
        "uri:poosl");
    }

    if (!method_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "method_name",
        "uri:poosl");
    }

    if (!local_variables_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "local_variables",
        "uri:poosl");
    }

    if (!downframe_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "downframe",
        "uri:poosl");
    }

    if (!upframe_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "upframe",
        "uri:poosl");
    }
  }

  T_stackframe* T_stackframe::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_stackframe (*this, f, c);
  }

  T_stackframe& T_stackframe::
  operator= (const T_stackframe& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->dataclass_handle_ = x.dataclass_handle_;
      this->dataclass_name_ = x.dataclass_name_;
      this->method_name_ = x.method_name_;
      this->local_variables_ = x.local_variables_;
      this->downframe_ = x.downframe_;
      this->upframe_ = x.upframe_;
    }

    return *this;
  }

  T_stackframe::
  ~T_stackframe ()
  {
  }

  // T_inspect_variable_context
  //

  T_inspect_variable_context::
  T_inspect_variable_context ()
  : ::xml_schema::Type (),
    variable_ (this)
  {
  }

  T_inspect_variable_context::
  T_inspect_variable_context (const T_inspect_variable_context& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variable_ (x.variable_, f, this)
  {
  }

  T_inspect_variable_context::
  T_inspect_variable_context (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variable_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_inspect_variable_context::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        this->variable_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_inspect_variable_context* T_inspect_variable_context::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_variable_context (*this, f, c);
  }

  T_inspect_variable_context& T_inspect_variable_context::
  operator= (const T_inspect_variable_context& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->variable_ = x.variable_;
    }

    return *this;
  }

  T_inspect_variable_context::
  ~T_inspect_variable_context ()
  {
  }

  // T_inspect_variable
  //

  T_inspect_variable::
  T_inspect_variable ()
  : ::xml_schema::Type (),
    handle_ (this),
    object_ (this),
    type_ (this),
    literal_ (this)
  {
  }

  T_inspect_variable::
  T_inspect_variable (const HandleType& handle,
                      const ObjectType& object,
                      const TypeType& type)
  : ::xml_schema::Type (),
    handle_ (handle, this),
    object_ (object, this),
    type_ (type, this),
    literal_ (this)
  {
  }

  T_inspect_variable::
  T_inspect_variable (const T_inspect_variable& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    handle_ (x.handle_, f, this),
    object_ (x.object_, f, this),
    type_ (x.type_, f, this),
    literal_ (x.literal_, f, this)
  {
  }

  T_inspect_variable::
  T_inspect_variable (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    handle_ (this),
    object_ (this),
    type_ (this),
    literal_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_inspect_variable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      // object
      //
      if (n.name () == "object" && n.namespace_ () == "uri:poosl")
      {
        if (!object_.present ())
        {
          this->object_.set (ObjectTraits::create (i, f, this));
          continue;
        }
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< TypeType > r (
          TypeTraits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (::std::move (r));
          continue;
        }
      }

      // literal
      //
      if (n.name () == "literal" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< LiteralType > r (
          LiteralTraits::create (i, f, this));

        if (!this->literal_)
        {
          this->literal_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }

    if (!object_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "object",
        "uri:poosl");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "uri:poosl");
    }
  }

  T_inspect_variable* T_inspect_variable::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_variable (*this, f, c);
  }

  T_inspect_variable& T_inspect_variable::
  operator= (const T_inspect_variable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->handle_ = x.handle_;
      this->object_ = x.object_;
      this->type_ = x.type_;
      this->literal_ = x.literal_;
    }

    return *this;
  }

  T_inspect_variable::
  ~T_inspect_variable ()
  {
  }

  // T_inspect_data
  //

  T_inspect_data::
  T_inspect_data ()
  : ::xml_schema::Type (),
    handle_ (this),
    type_ (this),
    literal_ (this),
    variables_ (this)
  {
  }

  T_inspect_data::
  T_inspect_data (const HandleType& handle,
                  const TypeType& type)
  : ::xml_schema::Type (),
    handle_ (handle, this),
    type_ (type, this),
    literal_ (this),
    variables_ (this)
  {
  }

  T_inspect_data::
  T_inspect_data (const T_inspect_data& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    handle_ (x.handle_, f, this),
    type_ (x.type_, f, this),
    literal_ (x.literal_, f, this),
    variables_ (x.variables_, f, this)
  {
  }

  T_inspect_data::
  T_inspect_data (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    handle_ (this),
    type_ (this),
    literal_ (this),
    variables_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_inspect_data::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< TypeType > r (
          TypeTraits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (::std::move (r));
          continue;
        }
      }

      // literal
      //
      if (n.name () == "literal" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< LiteralType > r (
          LiteralTraits::create (i, f, this));

        if (!this->literal_)
        {
          this->literal_.set (::std::move (r));
          continue;
        }
      }

      // variables
      //
      if (n.name () == "variables" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< VariablesType > r (
          VariablesTraits::create (i, f, this));

        if (!this->variables_)
        {
          this->variables_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "uri:poosl");
    }
  }

  T_inspect_data* T_inspect_data::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_data (*this, f, c);
  }

  T_inspect_data& T_inspect_data::
  operator= (const T_inspect_data& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->handle_ = x.handle_;
      this->type_ = x.type_;
      this->literal_ = x.literal_;
      this->variables_ = x.variables_;
    }

    return *this;
  }

  T_inspect_data::
  ~T_inspect_data ()
  {
  }

  // T_inspect_transition
  //

  T_inspect_transition::
  T_inspect_transition ()
  : ::xml_schema::Type (),
    transition_ (this)
  {
  }

  T_inspect_transition::
  T_inspect_transition (const TransitionType& transition)
  : ::xml_schema::Type (),
    transition_ (transition, this)
  {
  }

  T_inspect_transition::
  T_inspect_transition (::std::unique_ptr< TransitionType > transition)
  : ::xml_schema::Type (),
    transition_ (std::move (transition), this)
  {
  }

  T_inspect_transition::
  T_inspect_transition (const T_inspect_transition& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    transition_ (x.transition_, f, this)
  {
  }

  T_inspect_transition::
  T_inspect_transition (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    transition_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_inspect_transition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // transition
      //
      if (n.name () == "transition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< TransitionType > r (
          TransitionTraits::create (i, f, this));

        if (!transition_.present ())
        {
          this->transition_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!transition_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "transition",
        "uri:poosl");
    }
  }

  T_inspect_transition* T_inspect_transition::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspect_transition (*this, f, c);
  }

  T_inspect_transition& T_inspect_transition::
  operator= (const T_inspect_transition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->transition_ = x.transition_;
    }

    return *this;
  }

  T_inspect_transition::
  ~T_inspect_transition ()
  {
  }

  // T_observe_response
  //

  T_observe_response::
  T_observe_response ()
  : ::xml_schema::Type (),
    aspect_ (this),
    type_ (this),
    handle_ (this)
  {
  }

  T_observe_response::
  T_observe_response (const AspectType& aspect,
                      const TypeType& type,
                      const HandleType& handle)
  : ::xml_schema::Type (),
    aspect_ (aspect, this),
    type_ (type, this),
    handle_ (handle, this)
  {
  }

  T_observe_response::
  T_observe_response (::std::unique_ptr< AspectType > aspect,
                      const TypeType& type,
                      const HandleType& handle)
  : ::xml_schema::Type (),
    aspect_ (std::move (aspect), this),
    type_ (type, this),
    handle_ (handle, this)
  {
  }

  T_observe_response::
  T_observe_response (const T_observe_response& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    aspect_ (x.aspect_, f, this),
    type_ (x.type_, f, this),
    handle_ (x.handle_, f, this)
  {
  }

  T_observe_response::
  T_observe_response (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    aspect_ (this),
    type_ (this),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_observe_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // aspect
      //
      if (n.name () == "aspect" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AspectType > r (
          AspectTraits::create (i, f, this));

        if (!aspect_.present ())
        {
          this->aspect_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!aspect_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "aspect",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "handle" && n.namespace_ ().empty ())
      {
        this->handle_.set (HandleTraits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }
  }

  T_observe_response* T_observe_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_observe_response (*this, f, c);
  }

  T_observe_response& T_observe_response::
  operator= (const T_observe_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->aspect_ = x.aspect_;
      this->type_ = x.type_;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  T_observe_response::
  ~T_observe_response ()
  {
  }

  // T_execution_state_change_response
  //

  T_execution_state_change_response::
  T_execution_state_change_response ()
  : ::xml_schema::Type (),
    breakpoints_ (this),
    error_ (this),
    transition_ (this),
    message_ (this),
    state_ (this),
    time_ (this),
    minimal_time_step_ (this)
  {
  }

  T_execution_state_change_response::
  T_execution_state_change_response (const StateType& state,
                                     const TimeType& time,
                                     const Minimal_time_stepType& minimal_time_step)
  : ::xml_schema::Type (),
    breakpoints_ (this),
    error_ (this),
    transition_ (this),
    message_ (this),
    state_ (state, this),
    time_ (time, this),
    minimal_time_step_ (minimal_time_step, this)
  {
  }

  T_execution_state_change_response::
  T_execution_state_change_response (const T_execution_state_change_response& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    breakpoints_ (x.breakpoints_, f, this),
    error_ (x.error_, f, this),
    transition_ (x.transition_, f, this),
    message_ (x.message_, f, this),
    state_ (x.state_, f, this),
    time_ (x.time_, f, this),
    minimal_time_step_ (x.minimal_time_step_, f, this)
  {
  }

  T_execution_state_change_response::
  T_execution_state_change_response (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    breakpoints_ (this),
    error_ (this),
    transition_ (this),
    message_ (this),
    state_ (this),
    time_ (this),
    minimal_time_step_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_execution_state_change_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // breakpoints
      //
      if (n.name () == "breakpoints" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< BreakpointsType > r (
          BreakpointsTraits::create (i, f, this));

        if (!this->breakpoints_)
        {
          this->breakpoints_.set (::std::move (r));
          continue;
        }
      }

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ErrorType > r (
          ErrorTraits::create (i, f, this));

        if (!this->error_)
        {
          this->error_.set (::std::move (r));
          continue;
        }
      }

      // transition
      //
      if (n.name () == "transition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< TransitionType > r (
          TransitionTraits::create (i, f, this));

        if (!this->transition_)
        {
          this->transition_.set (::std::move (r));
          continue;
        }
      }

      // message
      //
      if (n.name () == "message" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< MessageType > r (
          MessageTraits::create (i, f, this));

        if (!this->message_)
        {
          this->message_.set (::std::move (r));
          continue;
        }
      }

      // state
      //
      if (n.name () == "state" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< StateType > r (
          StateTraits::create (i, f, this));

        if (!state_.present ())
        {
          this->state_.set (::std::move (r));
          continue;
        }
      }

      // time
      //
      if (n.name () == "time" && n.namespace_ () == "uri:poosl")
      {
        if (!time_.present ())
        {
          this->time_.set (TimeTraits::create (i, f, this));
          continue;
        }
      }

      // minimal_time_step
      //
      if (n.name () == "minimal_time_step" && n.namespace_ () == "uri:poosl")
      {
        if (!minimal_time_step_.present ())
        {
          this->minimal_time_step_.set (Minimal_time_stepTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!state_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "state",
        "uri:poosl");
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "time",
        "uri:poosl");
    }

    if (!minimal_time_step_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "minimal_time_step",
        "uri:poosl");
    }
  }

  T_execution_state_change_response* T_execution_state_change_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_execution_state_change_response (*this, f, c);
  }

  T_execution_state_change_response& T_execution_state_change_response::
  operator= (const T_execution_state_change_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->breakpoints_ = x.breakpoints_;
      this->error_ = x.error_;
      this->transition_ = x.transition_;
      this->message_ = x.message_;
      this->state_ = x.state_;
      this->time_ = x.time_;
      this->minimal_time_step_ = x.minimal_time_step_;
    }

    return *this;
  }

  T_execution_state_change_response::
  ~T_execution_state_change_response ()
  {
  }

  // T_eengine_event_setup_response
  //

  T_eengine_event_setup_response::
  T_eengine_event_setup_response ()
  : ::xml_schema::Type (),
    result_ (this)
  {
  }

  T_eengine_event_setup_response::
  T_eengine_event_setup_response (const ResultType& result)
  : ::xml_schema::Type (),
    result_ (result, this)
  {
  }

  T_eengine_event_setup_response::
  T_eengine_event_setup_response (const T_eengine_event_setup_response& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this)
  {
  }

  T_eengine_event_setup_response::
  T_eengine_event_setup_response (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_eengine_event_setup_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_eengine_event_setup_response* T_eengine_event_setup_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_eengine_event_setup_response (*this, f, c);
  }

  T_eengine_event_setup_response& T_eengine_event_setup_response::
  operator= (const T_eengine_event_setup_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
    }

    return *this;
  }

  T_eengine_event_setup_response::
  ~T_eengine_event_setup_response ()
  {
  }

  // T_communication_event
  //

  T_communication_event::
  T_communication_event ()
  : ::xml_schema::Type (),
    simulation_time_ (this),
    sender_ (this),
    receiver_ (this),
    message_ (this)
  {
  }

  T_communication_event::
  T_communication_event (const Simulation_timeType& simulation_time,
                         const SenderType& sender,
                         const ReceiverType& receiver,
                         const MessageType& message)
  : ::xml_schema::Type (),
    simulation_time_ (simulation_time, this),
    sender_ (sender, this),
    receiver_ (receiver, this),
    message_ (message, this)
  {
  }

  T_communication_event::
  T_communication_event (const Simulation_timeType& simulation_time,
                         ::std::unique_ptr< SenderType > sender,
                         ::std::unique_ptr< ReceiverType > receiver,
                         ::std::unique_ptr< MessageType > message)
  : ::xml_schema::Type (),
    simulation_time_ (simulation_time, this),
    sender_ (std::move (sender), this),
    receiver_ (std::move (receiver), this),
    message_ (std::move (message), this)
  {
  }

  T_communication_event::
  T_communication_event (const T_communication_event& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    simulation_time_ (x.simulation_time_, f, this),
    sender_ (x.sender_, f, this),
    receiver_ (x.receiver_, f, this),
    message_ (x.message_, f, this)
  {
  }

  T_communication_event::
  T_communication_event (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    simulation_time_ (this),
    sender_ (this),
    receiver_ (this),
    message_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_communication_event::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // simulation_time
      //
      if (n.name () == "simulation_time" && n.namespace_ () == "uri:poosl")
      {
        if (!simulation_time_.present ())
        {
          this->simulation_time_.set (Simulation_timeTraits::create (i, f, this));
          continue;
        }
      }

      // sender
      //
      if (n.name () == "sender" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SenderType > r (
          SenderTraits::create (i, f, this));

        if (!sender_.present ())
        {
          this->sender_.set (::std::move (r));
          continue;
        }
      }

      // receiver
      //
      if (n.name () == "receiver" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ReceiverType > r (
          ReceiverTraits::create (i, f, this));

        if (!receiver_.present ())
        {
          this->receiver_.set (::std::move (r));
          continue;
        }
      }

      // message
      //
      if (n.name () == "message" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< MessageType > r (
          MessageTraits::create (i, f, this));

        if (!message_.present ())
        {
          this->message_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!simulation_time_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "simulation_time",
        "uri:poosl");
    }

    if (!sender_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "sender",
        "uri:poosl");
    }

    if (!receiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "receiver",
        "uri:poosl");
    }

    if (!message_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "message",
        "uri:poosl");
    }
  }

  T_communication_event* T_communication_event::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_communication_event (*this, f, c);
  }

  T_communication_event& T_communication_event::
  operator= (const T_communication_event& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->simulation_time_ = x.simulation_time_;
      this->sender_ = x.sender_;
      this->receiver_ = x.receiver_;
      this->message_ = x.message_;
    }

    return *this;
  }

  T_communication_event::
  ~T_communication_event ()
  {
  }

  // T_eengine_event_error_response
  //

  T_eengine_event_error_response::
  T_eengine_event_error_response ()
  : ::xml_schema::Type (),
    error_ (this),
    stmt_handle_ (this),
    process_path_ (this),
    stacktrace_ (this)
  {
  }

  T_eengine_event_error_response::
  T_eengine_event_error_response (const ErrorType& error,
                                  const Stmt_handleType& stmt_handle,
                                  const Process_pathType& process_path,
                                  const StacktraceType& stacktrace)
  : ::xml_schema::Type (),
    error_ (error, this),
    stmt_handle_ (stmt_handle, this),
    process_path_ (process_path, this),
    stacktrace_ (stacktrace, this)
  {
  }

  T_eengine_event_error_response::
  T_eengine_event_error_response (const ErrorType& error,
                                  const Stmt_handleType& stmt_handle,
                                  const Process_pathType& process_path,
                                  ::std::unique_ptr< StacktraceType > stacktrace)
  : ::xml_schema::Type (),
    error_ (error, this),
    stmt_handle_ (stmt_handle, this),
    process_path_ (process_path, this),
    stacktrace_ (std::move (stacktrace), this)
  {
  }

  T_eengine_event_error_response::
  T_eengine_event_error_response (const T_eengine_event_error_response& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    error_ (x.error_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this),
    process_path_ (x.process_path_, f, this),
    stacktrace_ (x.stacktrace_, f, this)
  {
  }

  T_eengine_event_error_response::
  T_eengine_event_error_response (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    error_ (this),
    stmt_handle_ (this),
    process_path_ (this),
    stacktrace_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_eengine_event_error_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ErrorType > r (
          ErrorTraits::create (i, f, this));

        if (!error_.present ())
        {
          this->error_.set (::std::move (r));
          continue;
        }
      }

      // stmt_handle
      //
      if (n.name () == "stmt_handle" && n.namespace_ () == "uri:poosl")
      {
        if (!stmt_handle_.present ())
        {
          this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
          continue;
        }
      }

      // process_path
      //
      if (n.name () == "process_path" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_pathType > r (
          Process_pathTraits::create (i, f, this));

        if (!process_path_.present ())
        {
          this->process_path_.set (::std::move (r));
          continue;
        }
      }

      // stacktrace
      //
      if (n.name () == "stacktrace" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< StacktraceType > r (
          StacktraceTraits::create (i, f, this));

        if (!stacktrace_.present ())
        {
          this->stacktrace_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!error_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "error",
        "uri:poosl");
    }

    if (!stmt_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stmt_handle",
        "uri:poosl");
    }

    if (!process_path_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "process_path",
        "uri:poosl");
    }

    if (!stacktrace_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stacktrace",
        "uri:poosl");
    }
  }

  T_eengine_event_error_response* T_eengine_event_error_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_eengine_event_error_response (*this, f, c);
  }

  T_eengine_event_error_response& T_eengine_event_error_response::
  operator= (const T_eengine_event_error_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->error_ = x.error_;
      this->stmt_handle_ = x.stmt_handle_;
      this->process_path_ = x.process_path_;
      this->stacktrace_ = x.stacktrace_;
    }

    return *this;
  }

  T_eengine_event_error_response::
  ~T_eengine_event_error_response ()
  {
  }

  // T_communcation_event_node
  //

  T_communcation_event_node::
  T_communcation_event_node ()
  : ::xml_schema::Type (),
    process_path_ (this),
    stmt_handle_ (this),
    port_name_ (this)
  {
  }

  T_communcation_event_node::
  T_communcation_event_node (const Process_pathType& process_path,
                             const Stmt_handleType& stmt_handle,
                             const Port_nameType& port_name)
  : ::xml_schema::Type (),
    process_path_ (process_path, this),
    stmt_handle_ (stmt_handle, this),
    port_name_ (port_name, this)
  {
  }

  T_communcation_event_node::
  T_communcation_event_node (const T_communcation_event_node& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    process_path_ (x.process_path_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this),
    port_name_ (x.port_name_, f, this)
  {
  }

  T_communcation_event_node::
  T_communcation_event_node (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    process_path_ (this),
    stmt_handle_ (this),
    port_name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_communcation_event_node::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // process_path
      //
      if (n.name () == "process_path" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_pathType > r (
          Process_pathTraits::create (i, f, this));

        if (!process_path_.present ())
        {
          this->process_path_.set (::std::move (r));
          continue;
        }
      }

      // stmt_handle
      //
      if (n.name () == "stmt_handle" && n.namespace_ () == "uri:poosl")
      {
        if (!stmt_handle_.present ())
        {
          this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
          continue;
        }
      }

      // port_name
      //
      if (n.name () == "port_name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Port_nameType > r (
          Port_nameTraits::create (i, f, this));

        if (!port_name_.present ())
        {
          this->port_name_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!process_path_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "process_path",
        "uri:poosl");
    }

    if (!stmt_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stmt_handle",
        "uri:poosl");
    }

    if (!port_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "port_name",
        "uri:poosl");
    }
  }

  T_communcation_event_node* T_communcation_event_node::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_communcation_event_node (*this, f, c);
  }

  T_communcation_event_node& T_communcation_event_node::
  operator= (const T_communcation_event_node& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->process_path_ = x.process_path_;
      this->stmt_handle_ = x.stmt_handle_;
      this->port_name_ = x.port_name_;
    }

    return *this;
  }

  T_communcation_event_node::
  ~T_communcation_event_node ()
  {
  }

  // T_error_stacktrace
  //

  T_error_stacktrace::
  T_error_stacktrace ()
  : ::xml_schema::Type (),
    stackframe_ (this)
  {
  }

  T_error_stacktrace::
  T_error_stacktrace (const T_error_stacktrace& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    stackframe_ (x.stackframe_, f, this)
  {
  }

  T_error_stacktrace::
  T_error_stacktrace (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    stackframe_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_error_stacktrace::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // stackframe
      //
      if (n.name () == "stackframe" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< StackframeType > r (
          StackframeTraits::create (i, f, this));

        this->stackframe_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_error_stacktrace* T_error_stacktrace::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_error_stacktrace (*this, f, c);
  }

  T_error_stacktrace& T_error_stacktrace::
  operator= (const T_error_stacktrace& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->stackframe_ = x.stackframe_;
    }

    return *this;
  }

  T_error_stacktrace::
  ~T_error_stacktrace ()
  {
  }

  // T_error_stackframe
  //

  T_error_stackframe::
  T_error_stackframe ()
  : ::xml_schema::Type (),
    method_ (this),
    stmt_handle_ (this),
    variable_context_global_ (this),
    variable_context_local_ (this),
    id_ (this)
  {
  }

  T_error_stackframe::
  T_error_stackframe (const MethodType& method,
                      const Stmt_handleType& stmt_handle,
                      const Variable_context_globalType& variable_context_global,
                      const Variable_context_localType& variable_context_local)
  : ::xml_schema::Type (),
    method_ (method, this),
    stmt_handle_ (stmt_handle, this),
    variable_context_global_ (variable_context_global, this),
    variable_context_local_ (variable_context_local, this),
    id_ (this)
  {
  }

  T_error_stackframe::
  T_error_stackframe (const MethodType& method,
                      const Stmt_handleType& stmt_handle,
                      ::std::unique_ptr< Variable_context_globalType > variable_context_global,
                      ::std::unique_ptr< Variable_context_localType > variable_context_local)
  : ::xml_schema::Type (),
    method_ (method, this),
    stmt_handle_ (stmt_handle, this),
    variable_context_global_ (std::move (variable_context_global), this),
    variable_context_local_ (std::move (variable_context_local), this),
    id_ (this)
  {
  }

  T_error_stackframe::
  T_error_stackframe (const T_error_stackframe& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    method_ (x.method_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this),
    variable_context_global_ (x.variable_context_global_, f, this),
    variable_context_local_ (x.variable_context_local_, f, this),
    id_ (x.id_, f, this)
  {
  }

  T_error_stackframe::
  T_error_stackframe (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    method_ (this),
    stmt_handle_ (this),
    variable_context_global_ (this),
    variable_context_local_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_error_stackframe::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // method
      //
      if (n.name () == "method" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< MethodType > r (
          MethodTraits::create (i, f, this));

        if (!method_.present ())
        {
          this->method_.set (::std::move (r));
          continue;
        }
      }

      // stmt_handle
      //
      if (n.name () == "stmt_handle" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Stmt_handleType > r (
          Stmt_handleTraits::create (i, f, this));

        if (!stmt_handle_.present ())
        {
          this->stmt_handle_.set (::std::move (r));
          continue;
        }
      }

      // variable_context_global
      //
      if (n.name () == "variable_context_global" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Variable_context_globalType > r (
          Variable_context_globalTraits::create (i, f, this));

        if (!variable_context_global_.present ())
        {
          this->variable_context_global_.set (::std::move (r));
          continue;
        }
      }

      // variable_context_local
      //
      if (n.name () == "variable_context_local" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Variable_context_localType > r (
          Variable_context_localTraits::create (i, f, this));

        if (!variable_context_local_.present ())
        {
          this->variable_context_local_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!method_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "method",
        "uri:poosl");
    }

    if (!stmt_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stmt_handle",
        "uri:poosl");
    }

    if (!variable_context_global_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "variable_context_global",
        "uri:poosl");
    }

    if (!variable_context_local_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "variable_context_local",
        "uri:poosl");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_error_stackframe* T_error_stackframe::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_error_stackframe (*this, f, c);
  }

  T_error_stackframe& T_error_stackframe::
  operator= (const T_error_stackframe& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->method_ = x.method_;
      this->stmt_handle_ = x.stmt_handle_;
      this->variable_context_global_ = x.variable_context_global_;
      this->variable_context_local_ = x.variable_context_local_;
      this->id_ = x.id_;
    }

    return *this;
  }

  T_error_stackframe::
  ~T_error_stackframe ()
  {
  }

  // T_communication_event_message
  //

  T_communication_event_message::
  T_communication_event_message ()
  : ::xml_schema::Type (),
    name_ (this),
    parameters_ (this)
  {
  }

  T_communication_event_message::
  T_communication_event_message (const NameType& name,
                                 const ParametersType& parameters)
  : ::xml_schema::Type (),
    name_ (name, this),
    parameters_ (parameters, this)
  {
  }

  T_communication_event_message::
  T_communication_event_message (const NameType& name,
                                 ::std::unique_ptr< ParametersType > parameters)
  : ::xml_schema::Type (),
    name_ (name, this),
    parameters_ (std::move (parameters), this)
  {
  }

  T_communication_event_message::
  T_communication_event_message (const T_communication_event_message& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    parameters_ (x.parameters_, f, this)
  {
  }

  T_communication_event_message::
  T_communication_event_message (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    parameters_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_communication_event_message::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // parameters
      //
      if (n.name () == "parameters" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ParametersType > r (
          ParametersTraits::create (i, f, this));

        if (!parameters_.present ())
        {
          this->parameters_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "uri:poosl");
    }

    if (!parameters_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameters",
        "uri:poosl");
    }
  }

  T_communication_event_message* T_communication_event_message::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_communication_event_message (*this, f, c);
  }

  T_communication_event_message& T_communication_event_message::
  operator= (const T_communication_event_message& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->parameters_ = x.parameters_;
    }

    return *this;
  }

  T_communication_event_message::
  ~T_communication_event_message ()
  {
  }

  // T_communication_event_parameter
  //

  T_communication_event_parameter::
  T_communication_event_parameter ()
  : ::xml_schema::Type (),
    parameter_ (this)
  {
  }

  T_communication_event_parameter::
  T_communication_event_parameter (const T_communication_event_parameter& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this)
  {
  }

  T_communication_event_parameter::
  T_communication_event_parameter (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_communication_event_parameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        this->parameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_communication_event_parameter* T_communication_event_parameter::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_communication_event_parameter (*this, f, c);
  }

  T_communication_event_parameter& T_communication_event_parameter::
  operator= (const T_communication_event_parameter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->parameter_ = x.parameter_;
    }

    return *this;
  }

  T_communication_event_parameter::
  ~T_communication_event_parameter ()
  {
  }

  // T_breakpoint
  //

  T_breakpoint::
  T_breakpoint ()
  : ::xml_schema::Type (),
    breakpoint_ (this)
  {
  }

  T_breakpoint::
  T_breakpoint (const T_breakpoint& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    breakpoint_ (x.breakpoint_, f, this)
  {
  }

  T_breakpoint::
  T_breakpoint (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    breakpoint_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_breakpoint::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // breakpoint
      //
      if (n.name () == "breakpoint" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< BreakpointType > r (
          BreakpointTraits::create (i, f, this));

        this->breakpoint_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_breakpoint* T_breakpoint::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_breakpoint (*this, f, c);
  }

  T_breakpoint& T_breakpoint::
  operator= (const T_breakpoint& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->breakpoint_ = x.breakpoint_;
    }

    return *this;
  }

  T_breakpoint::
  ~T_breakpoint ()
  {
  }

  // T_breakpoint_info
  //

  T_breakpoint_info::
  T_breakpoint_info ()
  : ::xml_schema::Type (),
    name_ (this),
    breakpoint_id_ (this),
    control_point_ (this),
    stmt_handle_ (this),
    is_active_ (this),
    hit_count_ (this)
  {
  }

  T_breakpoint_info::
  T_breakpoint_info (const NameType& name,
                     const Breakpoint_idType& breakpoint_id,
                     const Control_pointType& control_point,
                     const Stmt_handleType& stmt_handle,
                     const Is_activeType& is_active,
                     const Hit_countType& hit_count)
  : ::xml_schema::Type (),
    name_ (name, this),
    breakpoint_id_ (breakpoint_id, this),
    control_point_ (control_point, this),
    stmt_handle_ (stmt_handle, this),
    is_active_ (is_active, this),
    hit_count_ (hit_count, this)
  {
  }

  T_breakpoint_info::
  T_breakpoint_info (const T_breakpoint_info& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    breakpoint_id_ (x.breakpoint_id_, f, this),
    control_point_ (x.control_point_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this),
    is_active_ (x.is_active_, f, this),
    hit_count_ (x.hit_count_, f, this)
  {
  }

  T_breakpoint_info::
  T_breakpoint_info (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    breakpoint_id_ (this),
    control_point_ (this),
    stmt_handle_ (this),
    is_active_ (this),
    hit_count_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_breakpoint_info::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // breakpoint_id
      //
      if (n.name () == "breakpoint_id" && n.namespace_ () == "uri:poosl")
      {
        if (!breakpoint_id_.present ())
        {
          this->breakpoint_id_.set (Breakpoint_idTraits::create (i, f, this));
          continue;
        }
      }

      // control_point
      //
      if (n.name () == "control_point" && n.namespace_ () == "uri:poosl")
      {
        if (!control_point_.present ())
        {
          this->control_point_.set (Control_pointTraits::create (i, f, this));
          continue;
        }
      }

      // stmt_handle
      //
      if (n.name () == "stmt_handle" && n.namespace_ () == "uri:poosl")
      {
        if (!stmt_handle_.present ())
        {
          this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
          continue;
        }
      }

      // is_active
      //
      if (n.name () == "is_active" && n.namespace_ () == "uri:poosl")
      {
        if (!is_active_.present ())
        {
          this->is_active_.set (Is_activeTraits::create (i, f, this));
          continue;
        }
      }

      // hit_count
      //
      if (n.name () == "hit_count" && n.namespace_ () == "uri:poosl")
      {
        if (!hit_count_.present ())
        {
          this->hit_count_.set (Hit_countTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "uri:poosl");
    }

    if (!breakpoint_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "breakpoint_id",
        "uri:poosl");
    }

    if (!control_point_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "control_point",
        "uri:poosl");
    }

    if (!stmt_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stmt_handle",
        "uri:poosl");
    }

    if (!is_active_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "is_active",
        "uri:poosl");
    }

    if (!hit_count_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "hit_count",
        "uri:poosl");
    }
  }

  T_breakpoint_info* T_breakpoint_info::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_breakpoint_info (*this, f, c);
  }

  T_breakpoint_info& T_breakpoint_info::
  operator= (const T_breakpoint_info& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->breakpoint_id_ = x.breakpoint_id_;
      this->control_point_ = x.control_point_;
      this->stmt_handle_ = x.stmt_handle_;
      this->is_active_ = x.is_active_;
      this->hit_count_ = x.hit_count_;
    }

    return *this;
  }

  T_breakpoint_info::
  ~T_breakpoint_info ()
  {
  }

  // T_error_info
  //

  T_error_info::
  T_error_info ()
  : ::xml_schema::Type (),
    stmt_handle_ (this),
    message_ (this),
    process_path_ (this),
    node_ (this)
  {
  }

  T_error_info::
  T_error_info (const Stmt_handleType& stmt_handle,
                const MessageType& message,
                const NodeType& node)
  : ::xml_schema::Type (),
    stmt_handle_ (stmt_handle, this),
    message_ (message, this),
    process_path_ (this),
    node_ (node, this)
  {
  }

  T_error_info::
  T_error_info (const T_error_info& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    stmt_handle_ (x.stmt_handle_, f, this),
    message_ (x.message_, f, this),
    process_path_ (x.process_path_, f, this),
    node_ (x.node_, f, this)
  {
  }

  T_error_info::
  T_error_info (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    stmt_handle_ (this),
    message_ (this),
    process_path_ (this),
    node_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_error_info::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // stmt_handle
      //
      if (n.name () == "stmt_handle" && n.namespace_ () == "uri:poosl")
      {
        if (!stmt_handle_.present ())
        {
          this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
          continue;
        }
      }

      // message
      //
      if (n.name () == "message" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< MessageType > r (
          MessageTraits::create (i, f, this));

        if (!message_.present ())
        {
          this->message_.set (::std::move (r));
          continue;
        }
      }

      // process_path
      //
      if (n.name () == "process_path" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_pathType > r (
          Process_pathTraits::create (i, f, this));

        if (!this->process_path_)
        {
          this->process_path_.set (::std::move (r));
          continue;
        }
      }

      // node
      //
      if (n.name () == "node" && n.namespace_ () == "uri:poosl")
      {
        if (!node_.present ())
        {
          this->node_.set (NodeTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!stmt_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stmt_handle",
        "uri:poosl");
    }

    if (!message_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "message",
        "uri:poosl");
    }

    if (!node_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "node",
        "uri:poosl");
    }
  }

  T_error_info* T_error_info::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_error_info (*this, f, c);
  }

  T_error_info& T_error_info::
  operator= (const T_error_info& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->stmt_handle_ = x.stmt_handle_;
      this->message_ = x.message_;
      this->process_path_ = x.process_path_;
      this->node_ = x.node_;
    }

    return *this;
  }

  T_error_info::
  ~T_error_info ()
  {
  }

  // T_create_breakpoint_response
  //

  T_create_breakpoint_response::
  T_create_breakpoint_response ()
  : ::xml_schema::Type (),
    name_ (this),
    breakpoint_id_ (this),
    result_ (this),
    control_point_ (this),
    stmt_handle_ (this),
    position_ (this)
  {
  }

  T_create_breakpoint_response::
  T_create_breakpoint_response (const NameType& name,
                                const Breakpoint_idType& breakpoint_id,
                                const ResultType& result,
                                const Control_pointType& control_point,
                                const Stmt_handleType& stmt_handle)
  : ::xml_schema::Type (),
    name_ (name, this),
    breakpoint_id_ (breakpoint_id, this),
    result_ (result, this),
    control_point_ (control_point, this),
    stmt_handle_ (stmt_handle, this),
    position_ (this)
  {
  }

  T_create_breakpoint_response::
  T_create_breakpoint_response (const T_create_breakpoint_response& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    breakpoint_id_ (x.breakpoint_id_, f, this),
    result_ (x.result_, f, this),
    control_point_ (x.control_point_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this),
    position_ (x.position_, f, this)
  {
  }

  T_create_breakpoint_response::
  T_create_breakpoint_response (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    breakpoint_id_ (this),
    result_ (this),
    control_point_ (this),
    stmt_handle_ (this),
    position_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_create_breakpoint_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // breakpoint_id
      //
      if (n.name () == "breakpoint_id" && n.namespace_ () == "uri:poosl")
      {
        if (!breakpoint_id_.present ())
        {
          this->breakpoint_id_.set (Breakpoint_idTraits::create (i, f, this));
          continue;
        }
      }

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      // control_point
      //
      if (n.name () == "control_point" && n.namespace_ () == "uri:poosl")
      {
        if (!control_point_.present ())
        {
          this->control_point_.set (Control_pointTraits::create (i, f, this));
          continue;
        }
      }

      // stmt_handle
      //
      if (n.name () == "stmt_handle" && n.namespace_ () == "uri:poosl")
      {
        if (!stmt_handle_.present ())
        {
          this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
          continue;
        }
      }

      // position
      //
      if (n.name () == "position" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< PositionType > r (
          PositionTraits::create (i, f, this));

        if (!this->position_)
        {
          this->position_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "uri:poosl");
    }

    if (!breakpoint_id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "breakpoint_id",
        "uri:poosl");
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }

    if (!control_point_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "control_point",
        "uri:poosl");
    }

    if (!stmt_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stmt_handle",
        "uri:poosl");
    }
  }

  T_create_breakpoint_response* T_create_breakpoint_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_create_breakpoint_response (*this, f, c);
  }

  T_create_breakpoint_response& T_create_breakpoint_response::
  operator= (const T_create_breakpoint_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->breakpoint_id_ = x.breakpoint_id_;
      this->result_ = x.result_;
      this->control_point_ = x.control_point_;
      this->stmt_handle_ = x.stmt_handle_;
      this->position_ = x.position_;
    }

    return *this;
  }

  T_create_breakpoint_response::
  ~T_create_breakpoint_response ()
  {
  }

  // T_create_breakpoint_response_result
  //

  T_create_breakpoint_response_result::
  T_create_breakpoint_response_result (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_create_breakpoint_response_result_convert ();
  }

  T_create_breakpoint_response_result::
  T_create_breakpoint_response_result (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_create_breakpoint_response_result_convert ();
  }

  T_create_breakpoint_response_result::
  T_create_breakpoint_response_result (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_create_breakpoint_response_result_convert ();
  }

  T_create_breakpoint_response_result* T_create_breakpoint_response_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_create_breakpoint_response_result (*this, f, c);
  }

  T_create_breakpoint_response_result::Value T_create_breakpoint_response_result::
  _xsd_T_create_breakpoint_response_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_create_breakpoint_response_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_create_breakpoint_response_result_indexes_,
                      _xsd_T_create_breakpoint_response_result_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_T_create_breakpoint_response_result_indexes_ + 2 || _xsd_T_create_breakpoint_response_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_create_breakpoint_response_result::
  _xsd_T_create_breakpoint_response_result_literals_[2] =
  {
    "ok",
    "breakpoint already exists"
  };

  const T_create_breakpoint_response_result::Value T_create_breakpoint_response_result::
  _xsd_T_create_breakpoint_response_result_indexes_[2] =
  {
    ::poosl::T_create_breakpoint_response_result::breakpoint_already_exists,
    ::poosl::T_create_breakpoint_response_result::ok
  };

  // T_set_breakpoint_condition_response
  //

  T_set_breakpoint_condition_response::
  T_set_breakpoint_condition_response ()
  : ::xml_schema::Type (),
    result_ (this),
    error_ (this)
  {
  }

  T_set_breakpoint_condition_response::
  T_set_breakpoint_condition_response (const ResultType& result,
                                       const ErrorType& error)
  : ::xml_schema::Type (),
    result_ (result, this),
    error_ (error, this)
  {
  }

  T_set_breakpoint_condition_response::
  T_set_breakpoint_condition_response (const T_set_breakpoint_condition_response& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this),
    error_ (x.error_, f, this)
  {
  }

  T_set_breakpoint_condition_response::
  T_set_breakpoint_condition_response (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this),
    error_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_set_breakpoint_condition_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ErrorType > r (
          ErrorTraits::create (i, f, this));

        if (!error_.present ())
        {
          this->error_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }

    if (!error_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "error",
        "uri:poosl");
    }
  }

  T_set_breakpoint_condition_response* T_set_breakpoint_condition_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_set_breakpoint_condition_response (*this, f, c);
  }

  T_set_breakpoint_condition_response& T_set_breakpoint_condition_response::
  operator= (const T_set_breakpoint_condition_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
      this->error_ = x.error_;
    }

    return *this;
  }

  T_set_breakpoint_condition_response::
  ~T_set_breakpoint_condition_response ()
  {
  }

  // T_set_breakpoint_condition_response_result
  //

  T_set_breakpoint_condition_response_result::
  T_set_breakpoint_condition_response_result (const ::xercesc::DOMElement& e,
                                              ::xml_schema::Flags f,
                                              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_set_breakpoint_condition_response_result_convert ();
  }

  T_set_breakpoint_condition_response_result::
  T_set_breakpoint_condition_response_result (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::Flags f,
                                              ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_set_breakpoint_condition_response_result_convert ();
  }

  T_set_breakpoint_condition_response_result::
  T_set_breakpoint_condition_response_result (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::Flags f,
                                              ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_set_breakpoint_condition_response_result_convert ();
  }

  T_set_breakpoint_condition_response_result* T_set_breakpoint_condition_response_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_set_breakpoint_condition_response_result (*this, f, c);
  }

  T_set_breakpoint_condition_response_result::Value T_set_breakpoint_condition_response_result::
  _xsd_T_set_breakpoint_condition_response_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_set_breakpoint_condition_response_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_set_breakpoint_condition_response_result_indexes_,
                      _xsd_T_set_breakpoint_condition_response_result_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_T_set_breakpoint_condition_response_result_indexes_ + 2 || _xsd_T_set_breakpoint_condition_response_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_set_breakpoint_condition_response_result::
  _xsd_T_set_breakpoint_condition_response_result_literals_[2] =
  {
    "ok",
    "error"
  };

  const T_set_breakpoint_condition_response_result::Value T_set_breakpoint_condition_response_result::
  _xsd_T_set_breakpoint_condition_response_result_indexes_[2] =
  {
    ::poosl::T_set_breakpoint_condition_response_result::error,
    ::poosl::T_set_breakpoint_condition_response_result::ok
  };

  // T_enable_breakpoint_response
  //

  T_enable_breakpoint_response::
  T_enable_breakpoint_response ()
  : ::xml_schema::Type (),
    result_ (this)
  {
  }

  T_enable_breakpoint_response::
  T_enable_breakpoint_response (const ResultType& result)
  : ::xml_schema::Type (),
    result_ (result, this)
  {
  }

  T_enable_breakpoint_response::
  T_enable_breakpoint_response (const T_enable_breakpoint_response& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this)
  {
  }

  T_enable_breakpoint_response::
  T_enable_breakpoint_response (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_enable_breakpoint_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_enable_breakpoint_response* T_enable_breakpoint_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_enable_breakpoint_response (*this, f, c);
  }

  T_enable_breakpoint_response& T_enable_breakpoint_response::
  operator= (const T_enable_breakpoint_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
    }

    return *this;
  }

  T_enable_breakpoint_response::
  ~T_enable_breakpoint_response ()
  {
  }

  // T_disable_breakpoint_response
  //

  T_disable_breakpoint_response::
  T_disable_breakpoint_response ()
  : ::xml_schema::Type (),
    result_ (this)
  {
  }

  T_disable_breakpoint_response::
  T_disable_breakpoint_response (const ResultType& result)
  : ::xml_schema::Type (),
    result_ (result, this)
  {
  }

  T_disable_breakpoint_response::
  T_disable_breakpoint_response (const T_disable_breakpoint_response& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this)
  {
  }

  T_disable_breakpoint_response::
  T_disable_breakpoint_response (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_disable_breakpoint_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_disable_breakpoint_response* T_disable_breakpoint_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_disable_breakpoint_response (*this, f, c);
  }

  T_disable_breakpoint_response& T_disable_breakpoint_response::
  operator= (const T_disable_breakpoint_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
    }

    return *this;
  }

  T_disable_breakpoint_response::
  ~T_disable_breakpoint_response ()
  {
  }

  // T_delete_breakpoint_response
  //

  T_delete_breakpoint_response::
  T_delete_breakpoint_response ()
  : ::xml_schema::Type (),
    result_ (this)
  {
  }

  T_delete_breakpoint_response::
  T_delete_breakpoint_response (const ResultType& result)
  : ::xml_schema::Type (),
    result_ (result, this)
  {
  }

  T_delete_breakpoint_response::
  T_delete_breakpoint_response (const T_delete_breakpoint_response& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this)
  {
  }

  T_delete_breakpoint_response::
  T_delete_breakpoint_response (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_delete_breakpoint_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_delete_breakpoint_response* T_delete_breakpoint_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_delete_breakpoint_response (*this, f, c);
  }

  T_delete_breakpoint_response& T_delete_breakpoint_response::
  operator= (const T_delete_breakpoint_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
    }

    return *this;
  }

  T_delete_breakpoint_response::
  ~T_delete_breakpoint_response ()
  {
  }

  // T_breakpoint_result
  //

  T_breakpoint_result::
  T_breakpoint_result ()
  : ::xml_schema::Type (),
    result_ (this)
  {
  }

  T_breakpoint_result::
  T_breakpoint_result (const ResultType& result)
  : ::xml_schema::Type (),
    result_ (result, this)
  {
  }

  T_breakpoint_result::
  T_breakpoint_result (const T_breakpoint_result& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this)
  {
  }

  T_breakpoint_result::
  T_breakpoint_result (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_breakpoint_result::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }
  }

  T_breakpoint_result* T_breakpoint_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_breakpoint_result (*this, f, c);
  }

  T_breakpoint_result& T_breakpoint_result::
  operator= (const T_breakpoint_result& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
    }

    return *this;
  }

  T_breakpoint_result::
  ~T_breakpoint_result ()
  {
  }

  // T_breakpoint_result_result
  //

  T_breakpoint_result_result::
  T_breakpoint_result_result (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_T_breakpoint_result_result_convert ();
  }

  T_breakpoint_result_result::
  T_breakpoint_result_result (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_T_breakpoint_result_result_convert ();
  }

  T_breakpoint_result_result::
  T_breakpoint_result_result (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_T_breakpoint_result_result_convert ();
  }

  T_breakpoint_result_result* T_breakpoint_result_result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_breakpoint_result_result (*this, f, c);
  }

  T_breakpoint_result_result::Value T_breakpoint_result_result::
  _xsd_T_breakpoint_result_result_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_T_breakpoint_result_result_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_T_breakpoint_result_result_indexes_,
                      _xsd_T_breakpoint_result_result_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_T_breakpoint_result_result_indexes_ + 2 || _xsd_T_breakpoint_result_result_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const T_breakpoint_result_result::
  _xsd_T_breakpoint_result_result_literals_[2] =
  {
    "ok",
    "invalid breakpoint"
  };

  const T_breakpoint_result_result::Value T_breakpoint_result_result::
  _xsd_T_breakpoint_result_result_indexes_[2] =
  {
    ::poosl::T_breakpoint_result_result::invalid_breakpoint,
    ::poosl::T_breakpoint_result_result::ok
  };

  // T_var_list
  //

  T_var_list::
  T_var_list ()
  : ::xml_schema::Type (),
    variable_ (this)
  {
  }

  T_var_list::
  T_var_list (const T_var_list& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variable_ (x.variable_, f, this)
  {
  }

  T_var_list::
  T_var_list (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variable_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_var_list::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        this->variable_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_var_list* T_var_list::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_var_list (*this, f, c);
  }

  T_var_list& T_var_list::
  operator= (const T_var_list& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->variable_ = x.variable_;
    }

    return *this;
  }

  T_var_list::
  ~T_var_list ()
  {
  }

  // T_variable
  //

  T_variable::
  T_variable ()
  : ::xml_schema::Type (),
    name_ (this),
    class__ (this),
    handle_ (this),
    type_ (this),
    literal_ (this),
    object_ (this)
  {
  }

  T_variable::
  T_variable (const NameType& name,
              const HandleType& handle,
              const TypeType& type,
              const LiteralType& literal,
              const ObjectType& object)
  : ::xml_schema::Type (),
    name_ (name, this),
    class__ (this),
    handle_ (handle, this),
    type_ (type, this),
    literal_ (literal, this),
    object_ (object, this)
  {
  }

  T_variable::
  T_variable (const T_variable& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    class__ (x.class__, f, this),
    handle_ (x.handle_, f, this),
    type_ (x.type_, f, this),
    literal_ (x.literal_, f, this),
    object_ (x.object_, f, this)
  {
  }

  T_variable::
  T_variable (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    class__ (this),
    handle_ (this),
    type_ (this),
    literal_ (this),
    object_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_variable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // class
      //
      if (n.name () == "class" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ClassType > r (
          ClassTraits::create (i, f, this));

        if (!this->class__)
        {
          this->class__.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< TypeType > r (
          TypeTraits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (::std::move (r));
          continue;
        }
      }

      // literal
      //
      if (n.name () == "literal" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< LiteralType > r (
          LiteralTraits::create (i, f, this));

        if (!literal_.present ())
        {
          this->literal_.set (::std::move (r));
          continue;
        }
      }

      // object
      //
      if (n.name () == "object" && n.namespace_ () == "uri:poosl")
      {
        if (!object_.present ())
        {
          this->object_.set (ObjectTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "uri:poosl");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "uri:poosl");
    }

    if (!literal_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "literal",
        "uri:poosl");
    }

    if (!object_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "object",
        "uri:poosl");
    }
  }

  T_variable* T_variable::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_variable (*this, f, c);
  }

  T_variable& T_variable::
  operator= (const T_variable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->class__ = x.class__;
      this->handle_ = x.handle_;
      this->type_ = x.type_;
      this->literal_ = x.literal_;
      this->object_ = x.object_;
    }

    return *this;
  }

  T_variable::
  ~T_variable ()
  {
  }

  // T_method_list
  //

  T_method_list::
  T_method_list ()
  : ::xml_schema::Type (),
    method_ (this)
  {
  }

  T_method_list::
  T_method_list (const T_method_list& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    method_ (x.method_, f, this)
  {
  }

  T_method_list::
  T_method_list (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    method_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_method_list::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // method
      //
      if (n.name () == "method" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< MethodType > r (
          MethodTraits::create (i, f, this));

        this->method_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_method_list* T_method_list::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_method_list (*this, f, c);
  }

  T_method_list& T_method_list::
  operator= (const T_method_list& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->method_ = x.method_;
    }

    return *this;
  }

  T_method_list::
  ~T_method_list ()
  {
  }

  // T_method
  //

  T_method::
  T_method ()
  : ::xml_schema::Type (),
    name_ (this),
    handle_ (this)
  {
  }

  T_method::
  T_method (const NameType& name,
            const HandleType& handle)
  : ::xml_schema::Type (),
    name_ (name, this),
    handle_ (handle, this)
  {
  }

  T_method::
  T_method (const T_method& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    handle_ (x.handle_, f, this)
  {
  }

  T_method::
  T_method (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_method::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (::std::move (r));
          continue;
        }
      }

      // handle
      //
      if (n.name () == "handle" && n.namespace_ () == "uri:poosl")
      {
        if (!handle_.present ())
        {
          this->handle_.set (HandleTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "uri:poosl");
    }

    if (!handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "handle",
        "uri:poosl");
    }
  }

  T_method* T_method::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_method (*this, f, c);
  }

  T_method& T_method::
  operator= (const T_method& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  T_method::
  ~T_method ()
  {
  }

  // T_executiontree
  //

  T_executiontree::
  T_executiontree ()
  : ::xml_schema::Type (),
    sequential_ (this),
    method_call_ (this),
    parallel_ (this),
    select_ (this),
    statement_ (this),
    expression_ (this),
    process_method_call_ (this),
    message_send_ (this),
    message_receive_ (this),
    guard_ (this),
    while__ (this),
    abort_ (this),
    interrupt_ (this),
    skip_ (this),
    delay_ (this),
    sequence_of_expressions_ (this),
    assignment_ (this),
    data_method_call_ (this),
    constant_ (this),
    variable_ (this),
    binary_operation_ (this),
    unary_operation_ (this),
    self_ (this),
    nil_ (this),
    current_time_ (this),
    if__ (this),
    switch__ (this),
    new__ (this),
    return__ (this),
    execution_tree_ (this)
  {
  }

  T_executiontree::
  T_executiontree (const T_executiontree& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    sequential_ (x.sequential_, f, this),
    method_call_ (x.method_call_, f, this),
    parallel_ (x.parallel_, f, this),
    select_ (x.select_, f, this),
    statement_ (x.statement_, f, this),
    expression_ (x.expression_, f, this),
    process_method_call_ (x.process_method_call_, f, this),
    message_send_ (x.message_send_, f, this),
    message_receive_ (x.message_receive_, f, this),
    guard_ (x.guard_, f, this),
    while__ (x.while__, f, this),
    abort_ (x.abort_, f, this),
    interrupt_ (x.interrupt_, f, this),
    skip_ (x.skip_, f, this),
    delay_ (x.delay_, f, this),
    sequence_of_expressions_ (x.sequence_of_expressions_, f, this),
    assignment_ (x.assignment_, f, this),
    data_method_call_ (x.data_method_call_, f, this),
    constant_ (x.constant_, f, this),
    variable_ (x.variable_, f, this),
    binary_operation_ (x.binary_operation_, f, this),
    unary_operation_ (x.unary_operation_, f, this),
    self_ (x.self_, f, this),
    nil_ (x.nil_, f, this),
    current_time_ (x.current_time_, f, this),
    if__ (x.if__, f, this),
    switch__ (x.switch__, f, this),
    new__ (x.new__, f, this),
    return__ (x.return__, f, this),
    execution_tree_ (x.execution_tree_, f, this)
  {
  }

  T_executiontree::
  T_executiontree (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    sequential_ (this),
    method_call_ (this),
    parallel_ (this),
    select_ (this),
    statement_ (this),
    expression_ (this),
    process_method_call_ (this),
    message_send_ (this),
    message_receive_ (this),
    guard_ (this),
    while__ (this),
    abort_ (this),
    interrupt_ (this),
    skip_ (this),
    delay_ (this),
    sequence_of_expressions_ (this),
    assignment_ (this),
    data_method_call_ (this),
    constant_ (this),
    variable_ (this),
    binary_operation_ (this),
    unary_operation_ (this),
    self_ (this),
    nil_ (this),
    current_time_ (this),
    if__ (this),
    switch__ (this),
    new__ (this),
    return__ (this),
    execution_tree_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_executiontree::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sequential
      //
      if (n.name () == "sequential" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SequentialType > r (
          SequentialTraits::create (i, f, this));

        this->sequential_.push_back (::std::move (r));
        continue;
      }

      // method_call
      //
      if (n.name () == "method_call" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Method_callType > r (
          Method_callTraits::create (i, f, this));

        this->method_call_.push_back (::std::move (r));
        continue;
      }

      // parallel
      //
      if (n.name () == "parallel" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ParallelType > r (
          ParallelTraits::create (i, f, this));

        this->parallel_.push_back (::std::move (r));
        continue;
      }

      // select
      //
      if (n.name () == "select" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SelectType > r (
          SelectTraits::create (i, f, this));

        this->select_.push_back (::std::move (r));
        continue;
      }

      // statement
      //
      if (n.name () == "statement" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< StatementType > r (
          StatementTraits::create (i, f, this));

        this->statement_.push_back (::std::move (r));
        continue;
      }

      // expression
      //
      if (n.name () == "expression" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ExpressionType > r (
          ExpressionTraits::create (i, f, this));

        this->expression_.push_back (::std::move (r));
        continue;
      }

      // process_method_call
      //
      if (n.name () == "process_method_call" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Process_method_callType > r (
          Process_method_callTraits::create (i, f, this));

        this->process_method_call_.push_back (::std::move (r));
        continue;
      }

      // message_send
      //
      if (n.name () == "message_send" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Message_sendType > r (
          Message_sendTraits::create (i, f, this));

        this->message_send_.push_back (::std::move (r));
        continue;
      }

      // message_receive
      //
      if (n.name () == "message_receive" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Message_receiveType > r (
          Message_receiveTraits::create (i, f, this));

        this->message_receive_.push_back (::std::move (r));
        continue;
      }

      // guard
      //
      if (n.name () == "guard" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< GuardType > r (
          GuardTraits::create (i, f, this));

        this->guard_.push_back (::std::move (r));
        continue;
      }

      // while
      //
      if (n.name () == "while" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< WhileType > r (
          WhileTraits::create (i, f, this));

        this->while__.push_back (::std::move (r));
        continue;
      }

      // abort
      //
      if (n.name () == "abort" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AbortType > r (
          AbortTraits::create (i, f, this));

        this->abort_.push_back (::std::move (r));
        continue;
      }

      // interrupt
      //
      if (n.name () == "interrupt" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InterruptType > r (
          InterruptTraits::create (i, f, this));

        this->interrupt_.push_back (::std::move (r));
        continue;
      }

      // skip
      //
      if (n.name () == "skip" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SkipType > r (
          SkipTraits::create (i, f, this));

        this->skip_.push_back (::std::move (r));
        continue;
      }

      // delay
      //
      if (n.name () == "delay" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< DelayType > r (
          DelayTraits::create (i, f, this));

        this->delay_.push_back (::std::move (r));
        continue;
      }

      // sequence_of_expressions
      //
      if (n.name () == "sequence_of_expressions" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Sequence_of_expressionsType > r (
          Sequence_of_expressionsTraits::create (i, f, this));

        this->sequence_of_expressions_.push_back (::std::move (r));
        continue;
      }

      // assignment
      //
      if (n.name () == "assignment" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< AssignmentType > r (
          AssignmentTraits::create (i, f, this));

        this->assignment_.push_back (::std::move (r));
        continue;
      }

      // data_method_call
      //
      if (n.name () == "data_method_call" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Data_method_callType > r (
          Data_method_callTraits::create (i, f, this));

        this->data_method_call_.push_back (::std::move (r));
        continue;
      }

      // constant
      //
      if (n.name () == "constant" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ConstantType > r (
          ConstantTraits::create (i, f, this));

        this->constant_.push_back (::std::move (r));
        continue;
      }

      // variable
      //
      if (n.name () == "variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        this->variable_.push_back (::std::move (r));
        continue;
      }

      // binary_operation
      //
      if (n.name () == "binary_operation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Binary_operationType > r (
          Binary_operationTraits::create (i, f, this));

        this->binary_operation_.push_back (::std::move (r));
        continue;
      }

      // unary_operation
      //
      if (n.name () == "unary_operation" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Unary_operationType > r (
          Unary_operationTraits::create (i, f, this));

        this->unary_operation_.push_back (::std::move (r));
        continue;
      }

      // self
      //
      if (n.name () == "self" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SelfType > r (
          SelfTraits::create (i, f, this));

        this->self_.push_back (::std::move (r));
        continue;
      }

      // nil
      //
      if (n.name () == "nil" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NilType > r (
          NilTraits::create (i, f, this));

        this->nil_.push_back (::std::move (r));
        continue;
      }

      // current_time
      //
      if (n.name () == "current_time" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Current_timeType > r (
          Current_timeTraits::create (i, f, this));

        this->current_time_.push_back (::std::move (r));
        continue;
      }

      // if
      //
      if (n.name () == "if" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< IfType > r (
          IfTraits::create (i, f, this));

        this->if__.push_back (::std::move (r));
        continue;
      }

      // switch
      //
      if (n.name () == "switch" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SwitchType > r (
          SwitchTraits::create (i, f, this));

        this->switch__.push_back (::std::move (r));
        continue;
      }

      // new
      //
      if (n.name () == "new" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NewType > r (
          NewTraits::create (i, f, this));

        this->new__.push_back (::std::move (r));
        continue;
      }

      // return
      //
      if (n.name () == "return" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ReturnType > r (
          ReturnTraits::create (i, f, this));

        this->return__.push_back (::std::move (r));
        continue;
      }

      // execution_tree
      //
      if (n.name () == "execution_tree" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Execution_treeType > r (
          Execution_treeTraits::create (i, f, this));

        this->execution_tree_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_executiontree* T_executiontree::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_executiontree (*this, f, c);
  }

  T_executiontree& T_executiontree::
  operator= (const T_executiontree& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->sequential_ = x.sequential_;
      this->method_call_ = x.method_call_;
      this->parallel_ = x.parallel_;
      this->select_ = x.select_;
      this->statement_ = x.statement_;
      this->expression_ = x.expression_;
      this->process_method_call_ = x.process_method_call_;
      this->message_send_ = x.message_send_;
      this->message_receive_ = x.message_receive_;
      this->guard_ = x.guard_;
      this->while__ = x.while__;
      this->abort_ = x.abort_;
      this->interrupt_ = x.interrupt_;
      this->skip_ = x.skip_;
      this->delay_ = x.delay_;
      this->sequence_of_expressions_ = x.sequence_of_expressions_;
      this->assignment_ = x.assignment_;
      this->data_method_call_ = x.data_method_call_;
      this->constant_ = x.constant_;
      this->variable_ = x.variable_;
      this->binary_operation_ = x.binary_operation_;
      this->unary_operation_ = x.unary_operation_;
      this->self_ = x.self_;
      this->nil_ = x.nil_;
      this->current_time_ = x.current_time_;
      this->if__ = x.if__;
      this->switch__ = x.switch__;
      this->new__ = x.new__;
      this->return__ = x.return__;
      this->execution_tree_ = x.execution_tree_;
    }

    return *this;
  }

  T_executiontree::
  ~T_executiontree ()
  {
  }

  // T_executiontree_base
  //

  T_executiontree_base::
  T_executiontree_base ()
  : ::xml_schema::Type (),
    process_ (this),
    parent_ (this),
    handle_ (this),
    global_ (this),
    local_ (this),
    stmt_handle_ (this)
  {
  }

  T_executiontree_base::
  T_executiontree_base (const T_executiontree_base& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    process_ (x.process_, f, this),
    parent_ (x.parent_, f, this),
    handle_ (x.handle_, f, this),
    global_ (x.global_, f, this),
    local_ (x.local_, f, this),
    stmt_handle_ (x.stmt_handle_, f, this)
  {
  }

  T_executiontree_base::
  T_executiontree_base (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    process_ (this),
    parent_ (this),
    handle_ (this),
    global_ (this),
    local_ (this),
    stmt_handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void T_executiontree_base::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "process" && n.namespace_ ().empty ())
      {
        this->process_.set (ProcessTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "parent" && n.namespace_ ().empty ())
      {
        this->parent_.set (ParentTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "handle" && n.namespace_ ().empty ())
      {
        this->handle_.set (HandleTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "global" && n.namespace_ ().empty ())
      {
        this->global_.set (GlobalTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "local" && n.namespace_ ().empty ())
      {
        this->local_.set (LocalTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "stmt_handle" && n.namespace_ ().empty ())
      {
        this->stmt_handle_.set (Stmt_handleTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_executiontree_base* T_executiontree_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_executiontree_base (*this, f, c);
  }

  T_executiontree_base& T_executiontree_base::
  operator= (const T_executiontree_base& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->process_ = x.process_;
      this->parent_ = x.parent_;
      this->handle_ = x.handle_;
      this->global_ = x.global_;
      this->local_ = x.local_;
      this->stmt_handle_ = x.stmt_handle_;
    }

    return *this;
  }

  T_executiontree_base::
  ~T_executiontree_base ()
  {
  }

  // T_executiontree_statements
  //

  T_executiontree_statements::
  T_executiontree_statements ()
  : ::poosl::T_executiontree_base (),
    statement_ (this)
  {
  }

  T_executiontree_statements::
  T_executiontree_statements (const T_executiontree_statements& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::poosl::T_executiontree_base (x, f, c),
    statement_ (x.statement_, f, this)
  {
  }

  T_executiontree_statements::
  T_executiontree_statements (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::poosl::T_executiontree_base (e, f | ::xml_schema::Flags::base, c),
    statement_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_executiontree_statements::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::poosl::T_executiontree_base::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // statement
      //
      if (n.name () == "statement" && n.namespace_ () == "uri:poosl")
      {
        this->statement_.push_back (StatementTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  T_executiontree_statements* T_executiontree_statements::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_executiontree_statements (*this, f, c);
  }

  T_executiontree_statements& T_executiontree_statements::
  operator= (const T_executiontree_statements& x)
  {
    if (this != &x)
    {
      static_cast< ::poosl::T_executiontree_base& > (*this) = x;
      this->statement_ = x.statement_;
    }

    return *this;
  }

  T_executiontree_statements::
  ~T_executiontree_statements ()
  {
  }

  // T_executiontree_method_call
  //

  T_executiontree_method_call::
  T_executiontree_method_call ()
  : ::poosl::T_executiontree_base (),
    name_ (this),
    state_ (this)
  {
  }

  T_executiontree_method_call::
  T_executiontree_method_call (const NameType& name)
  : ::poosl::T_executiontree_base (),
    name_ (name, this),
    state_ (this)
  {
  }

  T_executiontree_method_call::
  T_executiontree_method_call (const T_executiontree_method_call& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::poosl::T_executiontree_base (x, f, c),
    name_ (x.name_, f, this),
    state_ (x.state_, f, this)
  {
  }

  T_executiontree_method_call::
  T_executiontree_method_call (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::poosl::T_executiontree_base (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    state_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void T_executiontree_method_call::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::poosl::T_executiontree_base::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "state" && n.namespace_ ().empty ())
      {
        this->state_.set (StateTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  T_executiontree_method_call* T_executiontree_method_call::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_executiontree_method_call (*this, f, c);
  }

  T_executiontree_method_call& T_executiontree_method_call::
  operator= (const T_executiontree_method_call& x)
  {
    if (this != &x)
    {
      static_cast< ::poosl::T_executiontree_base& > (*this) = x;
      this->name_ = x.name_;
      this->state_ = x.state_;
    }

    return *this;
  }

  T_executiontree_method_call::
  ~T_executiontree_method_call ()
  {
  }

  // T_executiontree_message_receive
  //

  T_executiontree_message_receive::
  T_executiontree_message_receive ()
  : ::poosl::T_executiontree_base (),
    port_ (this),
    message_ (this),
    parameter_count_ (this)
  {
  }

  T_executiontree_message_receive::
  T_executiontree_message_receive (const T_executiontree_message_receive& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::poosl::T_executiontree_base (x, f, c),
    port_ (x.port_, f, this),
    message_ (x.message_, f, this),
    parameter_count_ (x.parameter_count_, f, this)
  {
  }

  T_executiontree_message_receive::
  T_executiontree_message_receive (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
  : ::poosl::T_executiontree_base (e, f | ::xml_schema::Flags::base, c),
    port_ (this),
    message_ (this),
    parameter_count_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void T_executiontree_message_receive::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::poosl::T_executiontree_base::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (PortTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "message" && n.namespace_ ().empty ())
      {
        this->message_.set (MessageTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "parameter_count" && n.namespace_ ().empty ())
      {
        this->parameter_count_.set (Parameter_countTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_executiontree_message_receive* T_executiontree_message_receive::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_executiontree_message_receive (*this, f, c);
  }

  T_executiontree_message_receive& T_executiontree_message_receive::
  operator= (const T_executiontree_message_receive& x)
  {
    if (this != &x)
    {
      static_cast< ::poosl::T_executiontree_base& > (*this) = x;
      this->port_ = x.port_;
      this->message_ = x.message_;
      this->parameter_count_ = x.parameter_count_;
    }

    return *this;
  }

  T_executiontree_message_receive::
  ~T_executiontree_message_receive ()
  {
  }

  // T_executiontree_expression
  //

  T_executiontree_expression::
  T_executiontree_expression ()
  : ::poosl::T_executiontree_base ()
  {
  }

  T_executiontree_expression::
  T_executiontree_expression (const T_executiontree_expression& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::poosl::T_executiontree_base (x, f, c)
  {
  }

  T_executiontree_expression::
  T_executiontree_expression (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::poosl::T_executiontree_base (e, f, c)
  {
  }

  T_executiontree_expression* T_executiontree_expression::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_executiontree_expression (*this, f, c);
  }

  T_executiontree_expression::
  ~T_executiontree_expression ()
  {
  }

  // T_cluster_instance_interface
  //

  T_cluster_instance_interface::
  T_cluster_instance_interface ()
  : ::xml_schema::Type (),
    port_ (this)
  {
  }

  T_cluster_instance_interface::
  T_cluster_instance_interface (const T_cluster_instance_interface& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    port_ (x.port_, f, this)
  {
  }

  T_cluster_instance_interface::
  T_cluster_instance_interface (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    port_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_cluster_instance_interface::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // port
      //
      if (n.name () == "port" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< PortType > r (
          PortTraits::create (i, f, this));

        this->port_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_cluster_instance_interface* T_cluster_instance_interface::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_cluster_instance_interface (*this, f, c);
  }

  T_cluster_instance_interface& T_cluster_instance_interface::
  operator= (const T_cluster_instance_interface& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->port_ = x.port_;
    }

    return *this;
  }

  T_cluster_instance_interface::
  ~T_cluster_instance_interface ()
  {
  }

  // T_cluster_instance_port
  //

  T_cluster_instance_port::
  T_cluster_instance_port ()
  : ::xml_schema::Type (),
    graphics_ (this),
    name_ (this)
  {
  }

  T_cluster_instance_port::
  T_cluster_instance_port (const T_cluster_instance_port& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    graphics_ (x.graphics_, f, this),
    name_ (x.name_, f, this)
  {
  }

  T_cluster_instance_port::
  T_cluster_instance_port (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    graphics_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_cluster_instance_port::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // graphics
      //
      if (n.name () == "graphics" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< GraphicsType > r (
          GraphicsTraits::create (i, f, this));

        if (!this->graphics_)
        {
          this->graphics_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_cluster_instance_port* T_cluster_instance_port::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_cluster_instance_port (*this, f, c);
  }

  T_cluster_instance_port& T_cluster_instance_port::
  operator= (const T_cluster_instance_port& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->graphics_ = x.graphics_;
      this->name_ = x.name_;
    }

    return *this;
  }

  T_cluster_instance_port::
  ~T_cluster_instance_port ()
  {
  }

  // T_graphics_port
  //

  T_graphics_port::
  T_graphics_port ()
  : ::xml_schema::Type (),
    location_ (this),
    name_location_ (this)
  {
  }

  T_graphics_port::
  T_graphics_port (const LocationType& location,
                   const Name_locationType& name_location)
  : ::xml_schema::Type (),
    location_ (location, this),
    name_location_ (name_location, this)
  {
  }

  T_graphics_port::
  T_graphics_port (::std::unique_ptr< LocationType > location,
                   ::std::unique_ptr< Name_locationType > name_location)
  : ::xml_schema::Type (),
    location_ (std::move (location), this),
    name_location_ (std::move (name_location), this)
  {
  }

  T_graphics_port::
  T_graphics_port (const T_graphics_port& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    location_ (x.location_, f, this),
    name_location_ (x.name_location_, f, this)
  {
  }

  T_graphics_port::
  T_graphics_port (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    location_ (this),
    name_location_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_graphics_port::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // location
      //
      if (n.name () == "location" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< LocationType > r (
          LocationTraits::create (i, f, this));

        if (!location_.present ())
        {
          this->location_.set (::std::move (r));
          continue;
        }
      }

      // name_location
      //
      if (n.name () == "name_location" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Name_locationType > r (
          Name_locationTraits::create (i, f, this));

        if (!name_location_.present ())
        {
          this->name_location_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "location",
        "uri:poosl");
    }

    if (!name_location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name_location",
        "uri:poosl");
    }
  }

  T_graphics_port* T_graphics_port::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_graphics_port (*this, f, c);
  }

  T_graphics_port& T_graphics_port::
  operator= (const T_graphics_port& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->location_ = x.location_;
      this->name_location_ = x.name_location_;
    }

    return *this;
  }

  T_graphics_port::
  ~T_graphics_port ()
  {
  }

  // T_graphics_channel
  //

  T_graphics_channel::
  T_graphics_channel ()
  : ::xml_schema::Type (),
    node_ (this),
    segment_ (this),
    name_location_ (this),
    message_location_ (this),
    scenario_ (this)
  {
  }

  T_graphics_channel::
  T_graphics_channel (const Name_locationType& name_location,
                      const Message_locationType& message_location)
  : ::xml_schema::Type (),
    node_ (this),
    segment_ (this),
    name_location_ (name_location, this),
    message_location_ (message_location, this),
    scenario_ (this)
  {
  }

  T_graphics_channel::
  T_graphics_channel (::std::unique_ptr< Name_locationType > name_location,
                      ::std::unique_ptr< Message_locationType > message_location)
  : ::xml_schema::Type (),
    node_ (this),
    segment_ (this),
    name_location_ (std::move (name_location), this),
    message_location_ (std::move (message_location), this),
    scenario_ (this)
  {
  }

  T_graphics_channel::
  T_graphics_channel (const T_graphics_channel& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    node_ (x.node_, f, this),
    segment_ (x.segment_, f, this),
    name_location_ (x.name_location_, f, this),
    message_location_ (x.message_location_, f, this),
    scenario_ (x.scenario_, f, this)
  {
  }

  T_graphics_channel::
  T_graphics_channel (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    node_ (this),
    segment_ (this),
    name_location_ (this),
    message_location_ (this),
    scenario_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_graphics_channel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // node
      //
      if (n.name () == "node" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NodeType > r (
          NodeTraits::create (i, f, this));

        this->node_.push_back (::std::move (r));
        continue;
      }

      // segment
      //
      if (n.name () == "segment" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SegmentType > r (
          SegmentTraits::create (i, f, this));

        this->segment_.push_back (::std::move (r));
        continue;
      }

      // name_location
      //
      if (n.name () == "name_location" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Name_locationType > r (
          Name_locationTraits::create (i, f, this));

        if (!name_location_.present ())
        {
          this->name_location_.set (::std::move (r));
          continue;
        }
      }

      // message_location
      //
      if (n.name () == "message_location" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Message_locationType > r (
          Message_locationTraits::create (i, f, this));

        if (!message_location_.present ())
        {
          this->message_location_.set (::std::move (r));
          continue;
        }
      }

      // scenario
      //
      if (n.name () == "scenario" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ScenarioType > r (
          ScenarioTraits::create (i, f, this));

        this->scenario_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!name_location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name_location",
        "uri:poosl");
    }

    if (!message_location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "message_location",
        "uri:poosl");
    }
  }

  T_graphics_channel* T_graphics_channel::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_graphics_channel (*this, f, c);
  }

  T_graphics_channel& T_graphics_channel::
  operator= (const T_graphics_channel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->node_ = x.node_;
      this->segment_ = x.segment_;
      this->name_location_ = x.name_location_;
      this->message_location_ = x.message_location_;
      this->scenario_ = x.scenario_;
    }

    return *this;
  }

  T_graphics_channel::
  ~T_graphics_channel ()
  {
  }

  // T_channel_node
  //

  T_channel_node::
  T_channel_node ()
  : ::xml_schema::Type (),
    node_ (this),
    instance_port_ (this),
    cluster_port_ (this)
  {
  }

  T_channel_node::
  T_channel_node (const T_channel_node& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    node_ (x.node_, f, this),
    instance_port_ (x.instance_port_, f, this),
    cluster_port_ (x.cluster_port_, f, this)
  {
  }

  T_channel_node::
  T_channel_node (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    node_ (this),
    instance_port_ (this),
    cluster_port_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_channel_node::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // node
      //
      if (n.name () == "node" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< NodeType > r (
          NodeTraits::create (i, f, this));

        this->node_.push_back (::std::move (r));
        continue;
      }

      // instance_port
      //
      if (n.name () == "instance_port" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Instance_portType > r (
          Instance_portTraits::create (i, f, this));

        this->instance_port_.push_back (::std::move (r));
        continue;
      }

      // cluster_port
      //
      if (n.name () == "cluster_port" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Cluster_portType > r (
          Cluster_portTraits::create (i, f, this));

        this->cluster_port_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  T_channel_node* T_channel_node::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_channel_node (*this, f, c);
  }

  T_channel_node& T_channel_node::
  operator= (const T_channel_node& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->node_ = x.node_;
      this->instance_port_ = x.instance_port_;
      this->cluster_port_ = x.cluster_port_;
    }

    return *this;
  }

  T_channel_node::
  ~T_channel_node ()
  {
  }

  // T_message_location
  //

  T_message_location::
  T_message_location ()
  : ::poosl::T_point (),
    width_ (this)
  {
  }

  T_message_location::
  T_message_location (const ::poosl::T_point& _xsd_T_point_base)
  : ::poosl::T_point (_xsd_T_point_base),
    width_ (this)
  {
  }

  T_message_location::
  T_message_location (const XType& x,
                      const YType& y)
  : ::poosl::T_point (x,
                      y),
    width_ (this)
  {
  }

  T_message_location::
  T_message_location (const T_message_location& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::poosl::T_point (x, f, c),
    width_ (x.width_, f, this)
  {
  }

  T_message_location::
  T_message_location (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::poosl::T_point (e, f | ::xml_schema::Flags::base, c),
    width_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void T_message_location::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::poosl::T_point::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "width" && n.namespace_ ().empty ())
      {
        this->width_.set (WidthTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_message_location* T_message_location::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_message_location (*this, f, c);
  }

  T_message_location& T_message_location::
  operator= (const T_message_location& x)
  {
    if (this != &x)
    {
      static_cast< ::poosl::T_point& > (*this) = x;
      this->width_ = x.width_;
    }

    return *this;
  }

  T_message_location::
  ~T_message_location ()
  {
  }

  // T_scenario
  //

  T_scenario::
  T_scenario ()
  : ::poosl::T_identifier ()
  {
  }

  T_scenario::
  T_scenario (const char* _xsd_String_base)
  : ::poosl::T_identifier (_xsd_String_base)
  {
  }

  T_scenario::
  T_scenario (const ::std::string& _xsd_String_base)
  : ::poosl::T_identifier (_xsd_String_base)
  {
  }

  T_scenario::
  T_scenario (const ::xml_schema::String& _xsd_String_base)
  : ::poosl::T_identifier (_xsd_String_base)
  {
  }

  T_scenario::
  T_scenario (const T_scenario& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::poosl::T_identifier (x, f, c)
  {
  }

  T_scenario::
  T_scenario (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::poosl::T_identifier (e, f, c)
  {
  }

  T_scenario::
  T_scenario (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::poosl::T_identifier (a, f, c)
  {
  }

  T_scenario::
  T_scenario (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::poosl::T_identifier (s, e, f, c)
  {
  }

  T_scenario* T_scenario::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_scenario (*this, f, c);
  }

  T_scenario::
  ~T_scenario ()
  {
  }

  // T_inspector_instance
  //

  T_inspector_instance::
  T_inspector_instance ()
  : ::xml_schema::Type (),
    connection_ (this),
    graphics_ (this),
    type_ (this),
    class__ (this),
    name_ (this)
  {
  }

  T_inspector_instance::
  T_inspector_instance (const T_inspector_instance& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    connection_ (x.connection_, f, this),
    graphics_ (x.graphics_, f, this),
    type_ (x.type_, f, this),
    class__ (x.class__, f, this),
    name_ (x.name_, f, this)
  {
  }

  T_inspector_instance::
  T_inspector_instance (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    connection_ (this),
    graphics_ (this),
    type_ (this),
    class__ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void T_inspector_instance::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // connection
      //
      if (n.name () == "connection" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ConnectionType > r (
          ConnectionTraits::create (i, f, this));

        this->connection_.push_back (::std::move (r));
        continue;
      }

      // graphics
      //
      if (n.name () == "graphics" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< GraphicsType > r (
          GraphicsTraits::create (i, f, this));

        if (!this->graphics_)
        {
          this->graphics_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "class" && n.namespace_ ().empty ())
      {
        this->class__.set (ClassTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  T_inspector_instance* T_inspector_instance::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_inspector_instance (*this, f, c);
  }

  T_inspector_instance& T_inspector_instance::
  operator= (const T_inspector_instance& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->connection_ = x.connection_;
      this->graphics_ = x.graphics_;
      this->type_ = x.type_;
      this->class__ = x.class__;
      this->name_ = x.name_;
    }

    return *this;
  }

  T_inspector_instance::
  ~T_inspector_instance ()
  {
  }

  // T_box_name_scenarios
  //

  T_box_name_scenarios::
  T_box_name_scenarios ()
  : ::xml_schema::Type (),
    box_ (this),
    name_location_ (this),
    scenario_ (this)
  {
  }

  T_box_name_scenarios::
  T_box_name_scenarios (const BoxType& box,
                        const Name_locationType& name_location)
  : ::xml_schema::Type (),
    box_ (box, this),
    name_location_ (name_location, this),
    scenario_ (this)
  {
  }

  T_box_name_scenarios::
  T_box_name_scenarios (::std::unique_ptr< BoxType > box,
                        ::std::unique_ptr< Name_locationType > name_location)
  : ::xml_schema::Type (),
    box_ (std::move (box), this),
    name_location_ (std::move (name_location), this),
    scenario_ (this)
  {
  }

  T_box_name_scenarios::
  T_box_name_scenarios (const T_box_name_scenarios& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    box_ (x.box_, f, this),
    name_location_ (x.name_location_, f, this),
    scenario_ (x.scenario_, f, this)
  {
  }

  T_box_name_scenarios::
  T_box_name_scenarios (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    box_ (this),
    name_location_ (this),
    scenario_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_box_name_scenarios::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // box
      //
      if (n.name () == "box" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< BoxType > r (
          BoxTraits::create (i, f, this));

        if (!box_.present ())
        {
          this->box_.set (::std::move (r));
          continue;
        }
      }

      // name_location
      //
      if (n.name () == "name_location" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Name_locationType > r (
          Name_locationTraits::create (i, f, this));

        if (!name_location_.present ())
        {
          this->name_location_.set (::std::move (r));
          continue;
        }
      }

      // scenario
      //
      if (n.name () == "scenario" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ScenarioType > r (
          ScenarioTraits::create (i, f, this));

        this->scenario_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!box_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "box",
        "uri:poosl");
    }

    if (!name_location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name_location",
        "uri:poosl");
    }
  }

  T_box_name_scenarios* T_box_name_scenarios::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_box_name_scenarios (*this, f, c);
  }

  T_box_name_scenarios& T_box_name_scenarios::
  operator= (const T_box_name_scenarios& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->box_ = x.box_;
      this->name_location_ = x.name_location_;
      this->scenario_ = x.scenario_;
    }

    return *this;
  }

  T_box_name_scenarios::
  ~T_box_name_scenarios ()
  {
  }

  // T_set_variable_response
  //

  T_set_variable_response::
  T_set_variable_response ()
  : ::xml_schema::Type (),
    result_ (this),
    var_handle_ (this),
    list_handle_ (this),
    error_ (this)
  {
  }

  T_set_variable_response::
  T_set_variable_response (const ResultType& result,
                           const Var_handleType& var_handle,
                           const List_handleType& list_handle,
                           const ErrorType& error)
  : ::xml_schema::Type (),
    result_ (result, this),
    var_handle_ (var_handle, this),
    list_handle_ (list_handle, this),
    error_ (error, this)
  {
  }

  T_set_variable_response::
  T_set_variable_response (const T_set_variable_response& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    result_ (x.result_, f, this),
    var_handle_ (x.var_handle_, f, this),
    list_handle_ (x.list_handle_, f, this),
    error_ (x.error_, f, this)
  {
  }

  T_set_variable_response::
  T_set_variable_response (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    result_ (this),
    var_handle_ (this),
    list_handle_ (this),
    error_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void T_set_variable_response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // result
      //
      if (n.name () == "result" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ResultType > r (
          ResultTraits::create (i, f, this));

        if (!result_.present ())
        {
          this->result_.set (::std::move (r));
          continue;
        }
      }

      // var_handle
      //
      if (n.name () == "var_handle" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Var_handleType > r (
          Var_handleTraits::create (i, f, this));

        if (!var_handle_.present ())
        {
          this->var_handle_.set (::std::move (r));
          continue;
        }
      }

      // list_handle
      //
      if (n.name () == "list_handle" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< List_handleType > r (
          List_handleTraits::create (i, f, this));

        if (!list_handle_.present ())
        {
          this->list_handle_.set (::std::move (r));
          continue;
        }
      }

      // error
      //
      if (n.name () == "error" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ErrorType > r (
          ErrorTraits::create (i, f, this));

        if (!error_.present ())
        {
          this->error_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!result_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "result",
        "uri:poosl");
    }

    if (!var_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "var_handle",
        "uri:poosl");
    }

    if (!list_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "list_handle",
        "uri:poosl");
    }

    if (!error_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "error",
        "uri:poosl");
    }
  }

  T_set_variable_response* T_set_variable_response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class T_set_variable_response (*this, f, c);
  }

  T_set_variable_response& T_set_variable_response::
  operator= (const T_set_variable_response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->result_ = x.result_;
      this->var_handle_ = x.var_handle_;
      this->list_handle_ = x.list_handle_;
      this->error_ = x.error_;
    }

    return *this;
  }

  T_set_variable_response::
  ~T_set_variable_response ()
  {
  }

  // Response
  //

  Response::
  Response ()
  : ::xml_schema::Type (),
    load_ (this),
    save_ (this),
    serialize_ (this),
    deserialize_ (this),
    compile_ (this),
    list_files_ (this),
    get_position_ (this),
    list_classes_ (this),
    get_top_level_specification_ (this),
    get_class_definition_ (this),
    get_method_definition_ (this),
    get_object_handle_ (this),
    rename_object_response_ (this),
    insert_object_response_ (this),
    delete_object_response_ (this),
    instantiate_ (this),
    command_ (this),
    execution_state_ (this),
    get_transitions_ (this),
    perform_transition_ (this),
    inspect_ (this),
    observe_ (this),
    create_breakpoint_ (this),
    set_breakpoint_condition_ (this),
    enable_breakpoint_ (this),
    disable_breakpoint_ (this),
    delete_breakpoint_ (this),
    eengine_event_setup_ (this),
    communication_event_ (this),
    eengine_event_error_ (this),
    set_variable_ (this)
  {
  }

  Response::
  Response (const Response& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    load_ (x.load_, f, this),
    save_ (x.save_, f, this),
    serialize_ (x.serialize_, f, this),
    deserialize_ (x.deserialize_, f, this),
    compile_ (x.compile_, f, this),
    list_files_ (x.list_files_, f, this),
    get_position_ (x.get_position_, f, this),
    list_classes_ (x.list_classes_, f, this),
    get_top_level_specification_ (x.get_top_level_specification_, f, this),
    get_class_definition_ (x.get_class_definition_, f, this),
    get_method_definition_ (x.get_method_definition_, f, this),
    get_object_handle_ (x.get_object_handle_, f, this),
    rename_object_response_ (x.rename_object_response_, f, this),
    insert_object_response_ (x.insert_object_response_, f, this),
    delete_object_response_ (x.delete_object_response_, f, this),
    instantiate_ (x.instantiate_, f, this),
    command_ (x.command_, f, this),
    execution_state_ (x.execution_state_, f, this),
    get_transitions_ (x.get_transitions_, f, this),
    perform_transition_ (x.perform_transition_, f, this),
    inspect_ (x.inspect_, f, this),
    observe_ (x.observe_, f, this),
    create_breakpoint_ (x.create_breakpoint_, f, this),
    set_breakpoint_condition_ (x.set_breakpoint_condition_, f, this),
    enable_breakpoint_ (x.enable_breakpoint_, f, this),
    disable_breakpoint_ (x.disable_breakpoint_, f, this),
    delete_breakpoint_ (x.delete_breakpoint_, f, this),
    eengine_event_setup_ (x.eengine_event_setup_, f, this),
    communication_event_ (x.communication_event_, f, this),
    eengine_event_error_ (x.eengine_event_error_, f, this),
    set_variable_ (x.set_variable_, f, this)
  {
  }

  Response::
  Response (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    load_ (this),
    save_ (this),
    serialize_ (this),
    deserialize_ (this),
    compile_ (this),
    list_files_ (this),
    get_position_ (this),
    list_classes_ (this),
    get_top_level_specification_ (this),
    get_class_definition_ (this),
    get_method_definition_ (this),
    get_object_handle_ (this),
    rename_object_response_ (this),
    insert_object_response_ (this),
    delete_object_response_ (this),
    instantiate_ (this),
    command_ (this),
    execution_state_ (this),
    get_transitions_ (this),
    perform_transition_ (this),
    inspect_ (this),
    observe_ (this),
    create_breakpoint_ (this),
    set_breakpoint_condition_ (this),
    enable_breakpoint_ (this),
    disable_breakpoint_ (this),
    delete_breakpoint_ (this),
    eengine_event_setup_ (this),
    communication_event_ (this),
    eengine_event_error_ (this),
    set_variable_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Response::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // load
      //
      if (n.name () == "load" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< LoadType > r (
          LoadTraits::create (i, f, this));

        if (!this->load_)
        {
          this->load_.set (::std::move (r));
          continue;
        }
      }

      // save
      //
      if (n.name () == "save" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SaveType > r (
          SaveTraits::create (i, f, this));

        if (!this->save_)
        {
          this->save_.set (::std::move (r));
          continue;
        }
      }

      // serialize
      //
      if (n.name () == "serialize" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< SerializeType > r (
          SerializeTraits::create (i, f, this));

        if (!this->serialize_)
        {
          this->serialize_.set (::std::move (r));
          continue;
        }
      }

      // deserialize
      //
      if (n.name () == "deserialize" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< DeserializeType > r (
          DeserializeTraits::create (i, f, this));

        if (!this->deserialize_)
        {
          this->deserialize_.set (::std::move (r));
          continue;
        }
      }

      // compile
      //
      if (n.name () == "compile" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< CompileType > r (
          CompileTraits::create (i, f, this));

        if (!this->compile_)
        {
          this->compile_.set (::std::move (r));
          continue;
        }
      }

      // list_files
      //
      if (n.name () == "list_files" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< List_filesType > r (
          List_filesTraits::create (i, f, this));

        if (!this->list_files_)
        {
          this->list_files_.set (::std::move (r));
          continue;
        }
      }

      // get_position
      //
      if (n.name () == "get_position" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Get_positionType > r (
          Get_positionTraits::create (i, f, this));

        if (!this->get_position_)
        {
          this->get_position_.set (::std::move (r));
          continue;
        }
      }

      // list_classes
      //
      if (n.name () == "list_classes" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< List_classesType > r (
          List_classesTraits::create (i, f, this));

        if (!this->list_classes_)
        {
          this->list_classes_.set (::std::move (r));
          continue;
        }
      }

      // get_top_level_specification
      //
      if (n.name () == "get_top_level_specification" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Get_top_level_specificationType > r (
          Get_top_level_specificationTraits::create (i, f, this));

        if (!this->get_top_level_specification_)
        {
          this->get_top_level_specification_.set (::std::move (r));
          continue;
        }
      }

      // get_class_definition
      //
      if (n.name () == "get_class_definition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Get_class_definitionType > r (
          Get_class_definitionTraits::create (i, f, this));

        if (!this->get_class_definition_)
        {
          this->get_class_definition_.set (::std::move (r));
          continue;
        }
      }

      // get_method_definition
      //
      if (n.name () == "get_method_definition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Get_method_definitionType > r (
          Get_method_definitionTraits::create (i, f, this));

        if (!this->get_method_definition_)
        {
          this->get_method_definition_.set (::std::move (r));
          continue;
        }
      }

      // get_object_handle
      //
      if (n.name () == "get_object_handle" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Get_object_handleType > r (
          Get_object_handleTraits::create (i, f, this));

        if (!this->get_object_handle_)
        {
          this->get_object_handle_.set (::std::move (r));
          continue;
        }
      }

      // rename_object_response
      //
      if (n.name () == "rename_object_response" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Rename_object_responseType > r (
          Rename_object_responseTraits::create (i, f, this));

        if (!this->rename_object_response_)
        {
          this->rename_object_response_.set (::std::move (r));
          continue;
        }
      }

      // insert_object_response
      //
      if (n.name () == "insert_object_response" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Insert_object_responseType > r (
          Insert_object_responseTraits::create (i, f, this));

        if (!this->insert_object_response_)
        {
          this->insert_object_response_.set (::std::move (r));
          continue;
        }
      }

      // delete_object_response
      //
      if (n.name () == "delete_object_response" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Delete_object_responseType > r (
          Delete_object_responseTraits::create (i, f, this));

        if (!this->delete_object_response_)
        {
          this->delete_object_response_.set (::std::move (r));
          continue;
        }
      }

      // instantiate
      //
      if (n.name () == "instantiate" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InstantiateType > r (
          InstantiateTraits::create (i, f, this));

        if (!this->instantiate_)
        {
          this->instantiate_.set (::std::move (r));
          continue;
        }
      }

      // command
      //
      if (n.name () == "command" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< CommandType > r (
          CommandTraits::create (i, f, this));

        if (!this->command_)
        {
          this->command_.set (::std::move (r));
          continue;
        }
      }

      // execution_state
      //
      if (n.name () == "execution_state" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Execution_stateType > r (
          Execution_stateTraits::create (i, f, this));

        if (!this->execution_state_)
        {
          this->execution_state_.set (::std::move (r));
          continue;
        }
      }

      // get_transitions
      //
      if (n.name () == "get_transitions" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Get_transitionsType > r (
          Get_transitionsTraits::create (i, f, this));

        if (!this->get_transitions_)
        {
          this->get_transitions_.set (::std::move (r));
          continue;
        }
      }

      // perform_transition
      //
      if (n.name () == "perform_transition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Perform_transitionType > r (
          Perform_transitionTraits::create (i, f, this));

        if (!this->perform_transition_)
        {
          this->perform_transition_.set (::std::move (r));
          continue;
        }
      }

      // inspect
      //
      if (n.name () == "inspect" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< InspectType > r (
          InspectTraits::create (i, f, this));

        if (!this->inspect_)
        {
          this->inspect_.set (::std::move (r));
          continue;
        }
      }

      // observe
      //
      if (n.name () == "observe" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< ObserveType > r (
          ObserveTraits::create (i, f, this));

        if (!this->observe_)
        {
          this->observe_.set (::std::move (r));
          continue;
        }
      }

      // create_breakpoint
      //
      if (n.name () == "create_breakpoint" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Create_breakpointType > r (
          Create_breakpointTraits::create (i, f, this));

        if (!this->create_breakpoint_)
        {
          this->create_breakpoint_.set (::std::move (r));
          continue;
        }
      }

      // set_breakpoint_condition
      //
      if (n.name () == "set_breakpoint_condition" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Set_breakpoint_conditionType > r (
          Set_breakpoint_conditionTraits::create (i, f, this));

        if (!this->set_breakpoint_condition_)
        {
          this->set_breakpoint_condition_.set (::std::move (r));
          continue;
        }
      }

      // enable_breakpoint
      //
      if (n.name () == "enable_breakpoint" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Enable_breakpointType > r (
          Enable_breakpointTraits::create (i, f, this));

        if (!this->enable_breakpoint_)
        {
          this->enable_breakpoint_.set (::std::move (r));
          continue;
        }
      }

      // disable_breakpoint
      //
      if (n.name () == "disable_breakpoint" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Disable_breakpointType > r (
          Disable_breakpointTraits::create (i, f, this));

        if (!this->disable_breakpoint_)
        {
          this->disable_breakpoint_.set (::std::move (r));
          continue;
        }
      }

      // delete_breakpoint
      //
      if (n.name () == "delete_breakpoint" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Delete_breakpointType > r (
          Delete_breakpointTraits::create (i, f, this));

        if (!this->delete_breakpoint_)
        {
          this->delete_breakpoint_.set (::std::move (r));
          continue;
        }
      }

      // eengine_event_setup
      //
      if (n.name () == "eengine_event_setup" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Eengine_event_setupType > r (
          Eengine_event_setupTraits::create (i, f, this));

        if (!this->eengine_event_setup_)
        {
          this->eengine_event_setup_.set (::std::move (r));
          continue;
        }
      }

      // communication_event
      //
      if (n.name () == "communication_event" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Communication_eventType > r (
          Communication_eventTraits::create (i, f, this));

        if (!this->communication_event_)
        {
          this->communication_event_.set (::std::move (r));
          continue;
        }
      }

      // eengine_event_error
      //
      if (n.name () == "eengine_event_error" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Eengine_event_errorType > r (
          Eengine_event_errorTraits::create (i, f, this));

        if (!this->eengine_event_error_)
        {
          this->eengine_event_error_.set (::std::move (r));
          continue;
        }
      }

      // set_variable
      //
      if (n.name () == "set_variable" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< Set_variableType > r (
          Set_variableTraits::create (i, f, this));

        if (!this->set_variable_)
        {
          this->set_variable_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Response* Response::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Response (*this, f, c);
  }

  Response& Response::
  operator= (const Response& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->load_ = x.load_;
      this->save_ = x.save_;
      this->serialize_ = x.serialize_;
      this->deserialize_ = x.deserialize_;
      this->compile_ = x.compile_;
      this->list_files_ = x.list_files_;
      this->get_position_ = x.get_position_;
      this->list_classes_ = x.list_classes_;
      this->get_top_level_specification_ = x.get_top_level_specification_;
      this->get_class_definition_ = x.get_class_definition_;
      this->get_method_definition_ = x.get_method_definition_;
      this->get_object_handle_ = x.get_object_handle_;
      this->rename_object_response_ = x.rename_object_response_;
      this->insert_object_response_ = x.insert_object_response_;
      this->delete_object_response_ = x.delete_object_response_;
      this->instantiate_ = x.instantiate_;
      this->command_ = x.command_;
      this->execution_state_ = x.execution_state_;
      this->get_transitions_ = x.get_transitions_;
      this->perform_transition_ = x.perform_transition_;
      this->inspect_ = x.inspect_;
      this->observe_ = x.observe_;
      this->create_breakpoint_ = x.create_breakpoint_;
      this->set_breakpoint_condition_ = x.set_breakpoint_condition_;
      this->enable_breakpoint_ = x.enable_breakpoint_;
      this->disable_breakpoint_ = x.disable_breakpoint_;
      this->delete_breakpoint_ = x.delete_breakpoint_;
      this->eengine_event_setup_ = x.eengine_event_setup_;
      this->communication_event_ = x.communication_event_;
      this->eengine_event_error_ = x.eengine_event_error_;
      this->set_variable_ = x.set_variable_;
    }

    return *this;
  }

  Response::
  ~Response ()
  {
  }

  // File
  //

  File::
  File ()
  : ::xml_schema::String (),
    handle_ (this)
  {
  }

  File::
  File (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    handle_ (this)
  {
  }

  File::
  File (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    handle_ (this)
  {
  }

  File::
  File (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    handle_ (this)
  {
  }

  File::
  File (const File& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c),
    handle_ (x.handle_, f, this)
  {
  }

  File::
  File (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
    handle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void File::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "handle" && n.namespace_ ().empty ())
      {
        this->handle_.set (HandleTraits::create (i, f, this));
        continue;
      }
    }
  }

  File* File::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class File (*this, f, c);
  }

  File& File::
  operator= (const File& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::String& > (*this) = x;
      this->handle_ = x.handle_;
    }

    return *this;
  }

  File::
  ~File ()
  {
  }

  // Channel
  //

  Channel::
  Channel ()
  : ::xml_schema::Type (),
    name_ (this),
    output_port_ (this)
  {
  }

  Channel::
  Channel (const NameType& name)
  : ::xml_schema::Type (),
    name_ (name, this),
    output_port_ (this)
  {
  }

  Channel::
  Channel (const Channel& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    output_port_ (x.output_port_, f, this)
  {
  }

  Channel::
  Channel (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    output_port_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Channel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "output_port" && n.namespace_ ().empty ())
      {
        this->output_port_.set (Output_portTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  Channel* Channel::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Channel (*this, f, c);
  }

  Channel& Channel::
  operator= (const Channel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->output_port_ = x.output_port_;
    }

    return *this;
  }

  Channel::
  ~Channel ()
  {
  }

  // Aspect
  //

  Aspect::
  Aspect ()
  : ::xml_schema::Type (),
    type_ (this)
  {
  }

  Aspect::
  Aspect (const TypeType& type)
  : ::xml_schema::Type (),
    type_ (type, this)
  {
  }

  Aspect::
  Aspect (const Aspect& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  Aspect::
  Aspect (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Aspect::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  Aspect* Aspect::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Aspect (*this, f, c);
  }

  Aspect& Aspect::
  operator= (const Aspect& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  Aspect::
  ~Aspect ()
  {
  }

  // Parameter
  //

  Parameter::
  Parameter ()
  : ::xml_schema::Type (),
    value_ (this),
    type_ (this)
  {
  }

  Parameter::
  Parameter (const Parameter& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_ (x.value_, f, this),
    type_ (x.type_, f, this)
  {
  }

  Parameter::
  Parameter (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Parameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  Parameter* Parameter::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Parameter (*this, f, c);
  }

  Parameter& Parameter::
  operator= (const Parameter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->value_ = x.value_;
      this->type_ = x.type_;
    }

    return *this;
  }

  Parameter::
  ~Parameter ()
  {
  }

  // Node
  //

  Node::
  Node ()
  : ::xml_schema::Type (),
    number_ (this)
  {
  }

  Node::
  Node (const NumberType& number)
  : ::xml_schema::Type (),
    number_ (number, this)
  {
  }

  Node::
  Node (const Node& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    number_ (x.number_, f, this)
  {
  }

  Node::
  Node (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    number_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Node::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (NumberTraits::create (i, f, this));
        continue;
      }
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }
  }

  Node* Node::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Node (*this, f, c);
  }

  Node& Node::
  operator= (const Node& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->number_ = x.number_;
    }

    return *this;
  }

  Node::
  ~Node ()
  {
  }

  // Instance_port
  //

  Instance_port::
  Instance_port ()
  : ::xml_schema::Type (),
    instance_name_ (this),
    port_name_ (this)
  {
  }

  Instance_port::
  Instance_port (const Instance_nameType& instance_name,
                 const Port_nameType& port_name)
  : ::xml_schema::Type (),
    instance_name_ (instance_name, this),
    port_name_ (port_name, this)
  {
  }

  Instance_port::
  Instance_port (const Instance_port& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    instance_name_ (x.instance_name_, f, this),
    port_name_ (x.port_name_, f, this)
  {
  }

  Instance_port::
  Instance_port (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    instance_name_ (this),
    port_name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Instance_port::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "instance_name" && n.namespace_ ().empty ())
      {
        this->instance_name_.set (Instance_nameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "port_name" && n.namespace_ ().empty ())
      {
        this->port_name_.set (Port_nameTraits::create (i, f, this));
        continue;
      }
    }

    if (!instance_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "instance_name",
        "");
    }

    if (!port_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port_name",
        "");
    }
  }

  Instance_port* Instance_port::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Instance_port (*this, f, c);
  }

  Instance_port& Instance_port::
  operator= (const Instance_port& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->instance_name_ = x.instance_name_;
      this->port_name_ = x.port_name_;
    }

    return *this;
  }

  Instance_port::
  ~Instance_port ()
  {
  }

  // Cluster_port
  //

  Cluster_port::
  Cluster_port ()
  : ::xml_schema::Type (),
    port_name_ (this)
  {
  }

  Cluster_port::
  Cluster_port (const Port_nameType& port_name)
  : ::xml_schema::Type (),
    port_name_ (port_name, this)
  {
  }

  Cluster_port::
  Cluster_port (const Cluster_port& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    port_name_ (x.port_name_, f, this)
  {
  }

  Cluster_port::
  Cluster_port (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    port_name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Cluster_port::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "port_name" && n.namespace_ ().empty ())
      {
        this->port_name_.set (Port_nameTraits::create (i, f, this));
        continue;
      }
    }

    if (!port_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port_name",
        "");
    }
  }

  Cluster_port* Cluster_port::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Cluster_port (*this, f, c);
  }

  Cluster_port& Cluster_port::
  operator= (const Cluster_port& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->port_name_ = x.port_name_;
    }

    return *this;
  }

  Cluster_port::
  ~Cluster_port ()
  {
  }

  // Connection
  //

  Connection::
  Connection ()
  : ::xml_schema::Type (),
    graphics_ (this),
    port_ (this),
    channel_ (this)
  {
  }

  Connection::
  Connection (const PortType& port,
              const ChannelType& channel)
  : ::xml_schema::Type (),
    graphics_ (this),
    port_ (port, this),
    channel_ (channel, this)
  {
  }

  Connection::
  Connection (const Connection& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    graphics_ (x.graphics_, f, this),
    port_ (x.port_, f, this),
    channel_ (x.channel_, f, this)
  {
  }

  Connection::
  Connection (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    graphics_ (this),
    port_ (this),
    channel_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Connection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // graphics
      //
      if (n.name () == "graphics" && n.namespace_ () == "uri:poosl")
      {
        ::std::unique_ptr< GraphicsType > r (
          GraphicsTraits::create (i, f, this));

        if (!this->graphics_)
        {
          this->graphics_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (PortTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "channel" && n.namespace_ ().empty ())
      {
        this->channel_.set (ChannelTraits::create (i, f, this));
        continue;
      }
    }

    if (!port_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "port",
        "");
    }

    if (!channel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "channel",
        "");
    }
  }

  Connection* Connection::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Connection (*this, f, c);
  }

  Connection& Connection::
  operator= (const Connection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->graphics_ = x.graphics_;
      this->port_ = x.port_;
      this->channel_ = x.channel_;
    }

    return *this;
  }

  Connection::
  ~Connection ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace poosl
{
  ::std::ostream&
  operator<< (::std::ostream& o, const T_load_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    o << ::std::endl << "error: " << i.getError ();
    o << ::std::endl << "contents: " << i.getContents ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_save_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    o << ::std::endl << "error: " << i.getError ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_file_io_result::Value i)
  {
    return o << T_file_io_result::_xsd_T_file_io_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_file_io_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_serialize_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    o << ::std::endl << "contents: " << i.getContents ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_deserialize_response& i)
  {
    o << ::std::endl << "error: " << i.getError ();
    o << ::std::endl << "handle: " << i.getHandle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_compile_response& i)
  {
    o << ::std::endl << "error: " << i.getError ();
    o << ::std::endl << "handle: " << i.getHandle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_serialize_result::Value i)
  {
    return o << T_serialize_result::_xsd_T_serialize_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_serialize_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_parse_result::Value i)
  {
    return o << T_parse_result::_xsd_T_parse_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_parse_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_list_classes_response& i)
  {
    for (T_list_classes_response::Class_nameConstIterator
         b (i.getClass_name ().begin ()), e (i.getClass_name ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "class_name: " << *b;
    }

    for (T_list_classes_response::HandleConstIterator
         b (i.getHandle ().begin ()), e (i.getHandle ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "handle: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_list_files_response& i)
  {
    for (T_list_files_response::FileConstIterator
         b (i.getFile ().begin ()), e (i.getFile ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "file: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_get_position_response& i)
  {
    o << ::std::endl << "stmt_handle: " << i.getStmt_handle ();
    o << ::std::endl << "begin: " << i.getBegin ();
    o << ::std::endl << "end: " << i.getEnd ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_get_top_level_specification_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    o << ::std::endl << "class_name: " << i.getClass_name ();
    o << ::std::endl << "handle: " << i.getHandle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_get_class_definition_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    if (i.getCluster_class ())
    {
      o << ::std::endl << "cluster_class: " << *i.getCluster_class ();
    }

    if (i.getProcess_class ())
    {
      o << ::std::endl << "process_class: " << *i.getProcess_class ();
    }

    if (i.getData_class ())
    {
      o << ::std::endl << "data_class: " << *i.getData_class ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_cluster_class_def& i)
  {
    o << ::std::endl << "class: " << i.getClass ();
    o << ::std::endl << "handle: " << i.getHandle ();
    o << ::std::endl << "instatiation_parameters: " << i.getInstatiation_parameters ();
    for (T_cluster_class_def::InstanceConstIterator
         b (i.getInstance ().begin ()), e (i.getInstance ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instance: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_process_class_def& i)
  {
    o << ::std::endl << "class: " << i.getClass ();
    o << ::std::endl << "handle: " << i.getHandle ();
    o << ::std::endl << "instatiation_parameters: " << i.getInstatiation_parameters ();
    o << ::std::endl << "interface: " << i.getInterface ();
    o << ::std::endl << "instance_variables: " << i.getInstance_variables ();
    o << ::std::endl << "initial_method_call: " << i.getInitial_method_call ();
    o << ::std::endl << "methods: " << i.getMethods ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_data_class_def& i)
  {
    o << ::std::endl << "class: " << i.getClass ();
    o << ::std::endl << "handle: " << i.getHandle ();
    o << ::std::endl << "instance_variables: " << i.getInstance_variables ();
    o << ::std::endl << "methods: " << i.getMethods ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_get_method_definition_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    if (i.getProcess_method ())
    {
      o << ::std::endl << "process_method: " << *i.getProcess_method ();
    }

    if (i.getData_method ())
    {
      o << ::std::endl << "data_method: " << *i.getData_method ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_process_method_def& i)
  {
    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    for (T_process_method_def::Input_parameterConstIterator
         b (i.getInput_parameter ().begin ()), e (i.getInput_parameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "input_parameter: " << *b;
    }

    for (T_process_method_def::Output_parameterConstIterator
         b (i.getOutput_parameter ().begin ()), e (i.getOutput_parameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "output_parameter: " << *b;
    }

    for (T_process_method_def::Local_variableConstIterator
         b (i.getLocal_variable ().begin ()), e (i.getLocal_variable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "local_variable: " << *b;
    }

    o << ::std::endl << "body_text: " << i.getBody_text ();
    if (i.getBody_statements ())
    {
      o << ::std::endl << "body_statements: " << *i.getBody_statements ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_data_method_def& i)
  {
    o << ::std::endl << "name: " << i.getName ();
    for (T_data_method_def::ArgumentConstIterator
         b (i.getArgument ().begin ()), e (i.getArgument ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "argument: " << *b;
    }

    for (T_data_method_def::Local_variableConstIterator
         b (i.getLocal_variable ().begin ()), e (i.getLocal_variable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "local_variable: " << *b;
    }

    o << ::std::endl << "body_text: " << i.getBody_text ();
    if (i.getBody_expression ())
    {
      o << ::std::endl << "body_expression: " << *i.getBody_expression ();
    }

    o << ::std::endl << "return_type: " << i.getReturn_type ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_get_object_handle_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    o << ::std::endl << "handle: " << i.getHandle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_rename_object_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_rename_object_response_result::Value i)
  {
    return o << T_rename_object_response_result::_xsd_T_rename_object_response_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_rename_object_response_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_insert_object_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_insert_object_response_result::Value i)
  {
    return o << T_insert_object_response_result::_xsd_T_insert_object_response_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_insert_object_response_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_delete_object_response& i)
  {
    for (T_delete_object_response::ObjectConstIterator
         b (i.getObject ().begin ()), e (i.getObject ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "object: " << *b;
    }

    for (T_delete_object_response::ResultConstIterator
         b (i.getResult ().begin ()), e (i.getResult ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "result: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_object_query_result::Value i)
  {
    return o << T_object_query_result::_xsd_T_object_query_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_object_query_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_instantiate_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_instantiate_result::Value i)
  {
    return o << T_instantiate_result::_xsd_T_instantiate_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_instantiate_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_command_response& i)
  {
    if (i.getType ())
    {
      o << ::std::endl << "type: " << *i.getType ();
    }

    if (i.getResult ())
    {
      o << ::std::endl << "result: " << *i.getResult ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_get_transitions_response& i)
  {
    o << ::std::endl << "transitions: " << i.getTransitions ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_perform_transition_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_perform_transition_response_result::Value i)
  {
    return o << T_perform_transition_response_result::_xsd_T_perform_transition_response_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_perform_transition_response_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_response& i)
  {
    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    o << ::std::endl << "handle: " << i.getHandle ();
    o << ::std::endl << "result: " << i.getResult ();
    if (i.getProcess ())
    {
      o << ::std::endl << "process: " << *i.getProcess ();
    }

    if (i.getData ())
    {
      o << ::std::endl << "data: " << *i.getData ();
    }

    if (i.getSystem ())
    {
      o << ::std::endl << "system: " << *i.getSystem ();
    }

    if (i.getChannel ())
    {
      o << ::std::endl << "channel: " << *i.getChannel ();
    }

    if (i.getStackframe ())
    {
      o << ::std::endl << "stackframe: " << *i.getStackframe ();
    }

    if (i.getVariable ())
    {
      o << ::std::endl << "variable: " << *i.getVariable ();
    }

    if (i.getVariable_context ())
    {
      o << ::std::endl << "variable_context: " << *i.getVariable_context ();
    }

    if (i.getTransition ())
    {
      o << ::std::endl << "transition: " << *i.getTransition ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_process& i)
  {
    o << ::std::endl << "instance_variables: " << i.getInstance_variables ();
    o << ::std::endl << "execution_tree: " << i.getExecution_tree ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_port& i)
  {
    o << ::std::endl << "name: " << i.getName ();
    if (i.getUp_channel ())
    {
      o << ::std::endl << "up_channel: " << *i.getUp_channel ();
    }

    if (i.getDown_channel ())
    {
      o << ::std::endl << "down_channel: " << *i.getDown_channel ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_instance& i)
  {
    o << ::std::endl << "name: " << i.getName ();
    o << ::std::endl << "type: " << i.getType ();
    o << ::std::endl << "process_path: " << i.getProcess_path ();
    if (i.getCluster ())
    {
      o << ::std::endl << "cluster: " << *i.getCluster ();
    }

    for (T_inspect_instance::PortConstIterator
         b (i.getPort ().begin ()), e (i.getPort ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "port: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_cluster& i)
  {
    for (T_inspect_cluster::ChannelConstIterator
         b (i.getChannel ().begin ()), e (i.getChannel ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channel: " << *b;
    }

    for (T_inspect_cluster::InstanceConstIterator
         b (i.getInstance ().begin ()), e (i.getInstance ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instance: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_system& i)
  {
    for (T_inspect_system::ChannelConstIterator
         b (i.getChannel ().begin ()), e (i.getChannel ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "channel: " << *b;
    }

    for (T_inspect_system::InstanceConstIterator
         b (i.getInstance ().begin ()), e (i.getInstance ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instance: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_channel& i)
  {
    o << ::std::endl << "name: " << i.getName ();
    o << ::std::endl << "is_root: " << i.getIs_root ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_stackframe& i)
  {
    o << ::std::endl << "dataclass_handle: " << i.getDataclass_handle ();
    o << ::std::endl << "dataclass_name: " << i.getDataclass_name ();
    o << ::std::endl << "method_name: " << i.getMethod_name ();
    o << ::std::endl << "local_variables: " << i.getLocal_variables ();
    o << ::std::endl << "downframe: " << i.getDownframe ();
    o << ::std::endl << "upframe: " << i.getUpframe ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_variable_context& i)
  {
    for (T_inspect_variable_context::VariableConstIterator
         b (i.getVariable ().begin ()), e (i.getVariable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variable: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_variable& i)
  {
    o << ::std::endl << "handle: " << i.getHandle ();
    o << ::std::endl << "object: " << i.getObject ();
    o << ::std::endl << "type: " << i.getType ();
    if (i.getLiteral ())
    {
      o << ::std::endl << "literal: " << *i.getLiteral ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_data& i)
  {
    o << ::std::endl << "handle: " << i.getHandle ();
    o << ::std::endl << "type: " << i.getType ();
    if (i.getLiteral ())
    {
      o << ::std::endl << "literal: " << *i.getLiteral ();
    }

    if (i.getVariables ())
    {
      o << ::std::endl << "variables: " << *i.getVariables ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspect_transition& i)
  {
    o << ::std::endl << "transition: " << i.getTransition ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_observe_response& i)
  {
    o << ::std::endl << "aspect: " << i.getAspect ();
    o << ::std::endl << "type: " << i.getType ();
    o << ::std::endl << "handle: " << i.getHandle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_execution_state_change_response& i)
  {
    if (i.getBreakpoints ())
    {
      o << ::std::endl << "breakpoints: " << *i.getBreakpoints ();
    }

    if (i.getError ())
    {
      o << ::std::endl << "error: " << *i.getError ();
    }

    if (i.getTransition ())
    {
      o << ::std::endl << "transition: " << *i.getTransition ();
    }

    if (i.getMessage ())
    {
      o << ::std::endl << "message: " << *i.getMessage ();
    }

    o << ::std::endl << "state: " << i.getState ();
    o << ::std::endl << "time: " << i.getTime ();
    o << ::std::endl << "minimal_time_step: " << i.getMinimal_time_step ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_eengine_event_setup_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_communication_event& i)
  {
    o << ::std::endl << "simulation_time: " << i.getSimulation_time ();
    o << ::std::endl << "sender: " << i.getSender ();
    o << ::std::endl << "receiver: " << i.getReceiver ();
    o << ::std::endl << "message: " << i.getMessage ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_eengine_event_error_response& i)
  {
    o << ::std::endl << "error: " << i.getError ();
    o << ::std::endl << "stmt_handle: " << i.getStmt_handle ();
    o << ::std::endl << "process_path: " << i.getProcess_path ();
    o << ::std::endl << "stacktrace: " << i.getStacktrace ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_communcation_event_node& i)
  {
    o << ::std::endl << "process_path: " << i.getProcess_path ();
    o << ::std::endl << "stmt_handle: " << i.getStmt_handle ();
    o << ::std::endl << "port_name: " << i.getPort_name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_error_stacktrace& i)
  {
    for (T_error_stacktrace::StackframeConstIterator
         b (i.getStackframe ().begin ()), e (i.getStackframe ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "stackframe: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_error_stackframe& i)
  {
    o << ::std::endl << "method: " << i.getMethod ();
    o << ::std::endl << "stmt_handle: " << i.getStmt_handle ();
    o << ::std::endl << "variable_context_global: " << i.getVariable_context_global ();
    o << ::std::endl << "variable_context_local: " << i.getVariable_context_local ();
    if (i.getId ())
    {
      o << ::std::endl << "id: " << *i.getId ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_communication_event_message& i)
  {
    o << ::std::endl << "name: " << i.getName ();
    o << ::std::endl << "parameters: " << i.getParameters ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_communication_event_parameter& i)
  {
    for (T_communication_event_parameter::ParameterConstIterator
         b (i.getParameter ().begin ()), e (i.getParameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "parameter: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_breakpoint& i)
  {
    for (T_breakpoint::BreakpointConstIterator
         b (i.getBreakpoint ().begin ()), e (i.getBreakpoint ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "breakpoint: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_breakpoint_info& i)
  {
    o << ::std::endl << "name: " << i.getName ();
    o << ::std::endl << "breakpoint_id: " << i.getBreakpoint_id ();
    o << ::std::endl << "control_point: " << i.getControl_point ();
    o << ::std::endl << "stmt_handle: " << i.getStmt_handle ();
    o << ::std::endl << "is_active: " << i.getIs_active ();
    o << ::std::endl << "hit_count: " << i.getHit_count ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_error_info& i)
  {
    o << ::std::endl << "stmt_handle: " << i.getStmt_handle ();
    o << ::std::endl << "message: " << i.getMessage ();
    if (i.getProcess_path ())
    {
      o << ::std::endl << "process_path: " << *i.getProcess_path ();
    }

    o << ::std::endl << "node: " << i.getNode ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_create_breakpoint_response& i)
  {
    o << ::std::endl << "name: " << i.getName ();
    o << ::std::endl << "breakpoint_id: " << i.getBreakpoint_id ();
    o << ::std::endl << "result: " << i.getResult ();
    o << ::std::endl << "control_point: " << i.getControl_point ();
    o << ::std::endl << "stmt_handle: " << i.getStmt_handle ();
    if (i.getPosition ())
    {
      o << ::std::endl << "position: " << *i.getPosition ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_create_breakpoint_response_result::Value i)
  {
    return o << T_create_breakpoint_response_result::_xsd_T_create_breakpoint_response_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_create_breakpoint_response_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_set_breakpoint_condition_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    o << ::std::endl << "error: " << i.getError ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_set_breakpoint_condition_response_result::Value i)
  {
    return o << T_set_breakpoint_condition_response_result::_xsd_T_set_breakpoint_condition_response_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_set_breakpoint_condition_response_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_enable_breakpoint_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_disable_breakpoint_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_delete_breakpoint_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_breakpoint_result& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, T_breakpoint_result_result::Value i)
  {
    return o << T_breakpoint_result_result::_xsd_T_breakpoint_result_result_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_breakpoint_result_result& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_var_list& i)
  {
    for (T_var_list::VariableConstIterator
         b (i.getVariable ().begin ()), e (i.getVariable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variable: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_variable& i)
  {
    o << ::std::endl << "name: " << i.getName ();
    if (i.getClass ())
    {
      o << ::std::endl << "class: " << *i.getClass ();
    }

    o << ::std::endl << "handle: " << i.getHandle ();
    o << ::std::endl << "type: " << i.getType ();
    o << ::std::endl << "literal: " << i.getLiteral ();
    o << ::std::endl << "object: " << i.getObject ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_method_list& i)
  {
    for (T_method_list::MethodConstIterator
         b (i.getMethod ().begin ()), e (i.getMethod ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "method: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_method& i)
  {
    o << ::std::endl << "name: " << i.getName ();
    o << ::std::endl << "handle: " << i.getHandle ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_executiontree& i)
  {
    for (T_executiontree::SequentialConstIterator
         b (i.getSequential ().begin ()), e (i.getSequential ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "sequential: " << *b;
    }

    for (T_executiontree::Method_callConstIterator
         b (i.getMethod_call ().begin ()), e (i.getMethod_call ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "method_call: " << *b;
    }

    for (T_executiontree::ParallelConstIterator
         b (i.getParallel ().begin ()), e (i.getParallel ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "parallel: " << *b;
    }

    for (T_executiontree::SelectConstIterator
         b (i.getSelect ().begin ()), e (i.getSelect ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "select: " << *b;
    }

    for (T_executiontree::StatementConstIterator
         b (i.getStatement ().begin ()), e (i.getStatement ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "statement: " << *b;
    }

    for (T_executiontree::ExpressionConstIterator
         b (i.getExpression ().begin ()), e (i.getExpression ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "expression: " << *b;
    }

    for (T_executiontree::Process_method_callConstIterator
         b (i.getProcess_method_call ().begin ()), e (i.getProcess_method_call ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "process_method_call: " << *b;
    }

    for (T_executiontree::Message_sendConstIterator
         b (i.getMessage_send ().begin ()), e (i.getMessage_send ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "message_send: " << *b;
    }

    for (T_executiontree::Message_receiveConstIterator
         b (i.getMessage_receive ().begin ()), e (i.getMessage_receive ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "message_receive: " << *b;
    }

    for (T_executiontree::GuardConstIterator
         b (i.getGuard ().begin ()), e (i.getGuard ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "guard: " << *b;
    }

    for (T_executiontree::WhileConstIterator
         b (i.getWhile ().begin ()), e (i.getWhile ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "while: " << *b;
    }

    for (T_executiontree::AbortConstIterator
         b (i.getAbort ().begin ()), e (i.getAbort ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "abort: " << *b;
    }

    for (T_executiontree::InterruptConstIterator
         b (i.getInterrupt ().begin ()), e (i.getInterrupt ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "interrupt: " << *b;
    }

    for (T_executiontree::SkipConstIterator
         b (i.getSkip ().begin ()), e (i.getSkip ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "skip: " << *b;
    }

    for (T_executiontree::DelayConstIterator
         b (i.getDelay ().begin ()), e (i.getDelay ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "delay: " << *b;
    }

    for (T_executiontree::Sequence_of_expressionsConstIterator
         b (i.getSequence_of_expressions ().begin ()), e (i.getSequence_of_expressions ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "sequence_of_expressions: " << *b;
    }

    for (T_executiontree::AssignmentConstIterator
         b (i.getAssignment ().begin ()), e (i.getAssignment ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "assignment: " << *b;
    }

    for (T_executiontree::Data_method_callConstIterator
         b (i.getData_method_call ().begin ()), e (i.getData_method_call ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "data_method_call: " << *b;
    }

    for (T_executiontree::ConstantConstIterator
         b (i.getConstant ().begin ()), e (i.getConstant ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "constant: " << *b;
    }

    for (T_executiontree::VariableConstIterator
         b (i.getVariable ().begin ()), e (i.getVariable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "variable: " << *b;
    }

    for (T_executiontree::Binary_operationConstIterator
         b (i.getBinary_operation ().begin ()), e (i.getBinary_operation ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "binary_operation: " << *b;
    }

    for (T_executiontree::Unary_operationConstIterator
         b (i.getUnary_operation ().begin ()), e (i.getUnary_operation ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "unary_operation: " << *b;
    }

    for (T_executiontree::SelfConstIterator
         b (i.getSelf ().begin ()), e (i.getSelf ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "self: " << *b;
    }

    for (T_executiontree::NilConstIterator
         b (i.getNil ().begin ()), e (i.getNil ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "nil: " << *b;
    }

    for (T_executiontree::Current_timeConstIterator
         b (i.getCurrent_time ().begin ()), e (i.getCurrent_time ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "current_time: " << *b;
    }

    for (T_executiontree::IfConstIterator
         b (i.getIf ().begin ()), e (i.getIf ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "if: " << *b;
    }

    for (T_executiontree::SwitchConstIterator
         b (i.getSwitch ().begin ()), e (i.getSwitch ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "switch: " << *b;
    }

    for (T_executiontree::NewConstIterator
         b (i.getNew ().begin ()), e (i.getNew ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "new: " << *b;
    }

    for (T_executiontree::ReturnConstIterator
         b (i.getReturn ().begin ()), e (i.getReturn ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "return: " << *b;
    }

    for (T_executiontree::Execution_treeConstIterator
         b (i.getExecution_tree ().begin ()), e (i.getExecution_tree ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "execution_tree: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_executiontree_base& i)
  {
    if (i.getProcess ())
    {
      o << ::std::endl << "process: " << *i.getProcess ();
    }

    if (i.getParent ())
    {
      o << ::std::endl << "parent: " << *i.getParent ();
    }

    if (i.getHandle ())
    {
      o << ::std::endl << "handle: " << *i.getHandle ();
    }

    if (i.getGlobal ())
    {
      o << ::std::endl << "global: " << *i.getGlobal ();
    }

    if (i.getLocal ())
    {
      o << ::std::endl << "local: " << *i.getLocal ();
    }

    if (i.getStmt_handle ())
    {
      o << ::std::endl << "stmt_handle: " << *i.getStmt_handle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_executiontree_statements& i)
  {
    o << static_cast< const ::poosl::T_executiontree_base& > (i);

    for (T_executiontree_statements::StatementConstIterator
         b (i.getStatement ().begin ()), e (i.getStatement ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "statement: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_executiontree_method_call& i)
  {
    o << static_cast< const ::poosl::T_executiontree_base& > (i);

    o << ::std::endl << "name: " << i.getName ();
    if (i.getState ())
    {
      o << ::std::endl << "state: " << *i.getState ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_executiontree_message_receive& i)
  {
    o << static_cast< const ::poosl::T_executiontree_base& > (i);

    if (i.getPort ())
    {
      o << ::std::endl << "port: " << *i.getPort ();
    }

    if (i.getMessage ())
    {
      o << ::std::endl << "message: " << *i.getMessage ();
    }

    if (i.getParameter_count ())
    {
      o << ::std::endl << "parameter_count: " << *i.getParameter_count ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_executiontree_expression& i)
  {
    o << static_cast< const ::poosl::T_executiontree_base& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_cluster_instance_interface& i)
  {
    for (T_cluster_instance_interface::PortConstIterator
         b (i.getPort ().begin ()), e (i.getPort ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "port: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_cluster_instance_port& i)
  {
    if (i.getGraphics ())
    {
      o << ::std::endl << "graphics: " << *i.getGraphics ();
    }

    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_graphics_port& i)
  {
    o << ::std::endl << "location: " << i.getLocation ();
    o << ::std::endl << "name_location: " << i.getName_location ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_graphics_channel& i)
  {
    for (T_graphics_channel::NodeConstIterator
         b (i.getNode ().begin ()), e (i.getNode ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "node: " << *b;
    }

    for (T_graphics_channel::SegmentConstIterator
         b (i.getSegment ().begin ()), e (i.getSegment ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "segment: " << *b;
    }

    o << ::std::endl << "name_location: " << i.getName_location ();
    o << ::std::endl << "message_location: " << i.getMessage_location ();
    for (T_graphics_channel::ScenarioConstIterator
         b (i.getScenario ().begin ()), e (i.getScenario ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "scenario: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_channel_node& i)
  {
    for (T_channel_node::NodeConstIterator
         b (i.getNode ().begin ()), e (i.getNode ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "node: " << *b;
    }

    for (T_channel_node::Instance_portConstIterator
         b (i.getInstance_port ().begin ()), e (i.getInstance_port ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "instance_port: " << *b;
    }

    for (T_channel_node::Cluster_portConstIterator
         b (i.getCluster_port ().begin ()), e (i.getCluster_port ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "cluster_port: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_message_location& i)
  {
    o << static_cast< const ::poosl::T_point& > (i);

    if (i.getWidth ())
    {
      o << ::std::endl << "width: " << *i.getWidth ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_scenario& i)
  {
    o << static_cast< const ::poosl::T_identifier& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_inspector_instance& i)
  {
    for (T_inspector_instance::ConnectionConstIterator
         b (i.getConnection ().begin ()), e (i.getConnection ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "connection: " << *b;
    }

    if (i.getGraphics ())
    {
      o << ::std::endl << "graphics: " << *i.getGraphics ();
    }

    if (i.getType ())
    {
      o << ::std::endl << "type: " << *i.getType ();
    }

    if (i.getClass ())
    {
      o << ::std::endl << "class: " << *i.getClass ();
    }

    if (i.getName ())
    {
      o << ::std::endl << "name: " << *i.getName ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_box_name_scenarios& i)
  {
    o << ::std::endl << "box: " << i.getBox ();
    o << ::std::endl << "name_location: " << i.getName_location ();
    for (T_box_name_scenarios::ScenarioConstIterator
         b (i.getScenario ().begin ()), e (i.getScenario ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "scenario: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const T_set_variable_response& i)
  {
    o << ::std::endl << "result: " << i.getResult ();
    o << ::std::endl << "var_handle: " << i.getVar_handle ();
    o << ::std::endl << "list_handle: " << i.getList_handle ();
    o << ::std::endl << "error: " << i.getError ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Response& i)
  {
    if (i.getLoad ())
    {
      o << ::std::endl << "load: " << *i.getLoad ();
    }

    if (i.getSave ())
    {
      o << ::std::endl << "save: " << *i.getSave ();
    }

    if (i.getSerialize ())
    {
      o << ::std::endl << "serialize: " << *i.getSerialize ();
    }

    if (i.getDeserialize ())
    {
      o << ::std::endl << "deserialize: " << *i.getDeserialize ();
    }

    if (i.getCompile ())
    {
      o << ::std::endl << "compile: " << *i.getCompile ();
    }

    if (i.getList_files ())
    {
      o << ::std::endl << "list_files: " << *i.getList_files ();
    }

    if (i.getGet_position ())
    {
      o << ::std::endl << "get_position: " << *i.getGet_position ();
    }

    if (i.getList_classes ())
    {
      o << ::std::endl << "list_classes: " << *i.getList_classes ();
    }

    if (i.getGet_top_level_specification ())
    {
      o << ::std::endl << "get_top_level_specification: " << *i.getGet_top_level_specification ();
    }

    if (i.getGet_class_definition ())
    {
      o << ::std::endl << "get_class_definition: " << *i.getGet_class_definition ();
    }

    if (i.getGet_method_definition ())
    {
      o << ::std::endl << "get_method_definition: " << *i.getGet_method_definition ();
    }

    if (i.getGet_object_handle ())
    {
      o << ::std::endl << "get_object_handle: " << *i.getGet_object_handle ();
    }

    if (i.getRename_object_response ())
    {
      o << ::std::endl << "rename_object_response: " << *i.getRename_object_response ();
    }

    if (i.getInsert_object_response ())
    {
      o << ::std::endl << "insert_object_response: " << *i.getInsert_object_response ();
    }

    if (i.getDelete_object_response ())
    {
      o << ::std::endl << "delete_object_response: " << *i.getDelete_object_response ();
    }

    if (i.getInstantiate ())
    {
      o << ::std::endl << "instantiate: " << *i.getInstantiate ();
    }

    if (i.getCommand ())
    {
      o << ::std::endl << "command: " << *i.getCommand ();
    }

    if (i.getExecution_state ())
    {
      o << ::std::endl << "execution_state: " << *i.getExecution_state ();
    }

    if (i.getGet_transitions ())
    {
      o << ::std::endl << "get_transitions: " << *i.getGet_transitions ();
    }

    if (i.getPerform_transition ())
    {
      o << ::std::endl << "perform_transition: " << *i.getPerform_transition ();
    }

    if (i.getInspect ())
    {
      o << ::std::endl << "inspect: " << *i.getInspect ();
    }

    if (i.getObserve ())
    {
      o << ::std::endl << "observe: " << *i.getObserve ();
    }

    if (i.getCreate_breakpoint ())
    {
      o << ::std::endl << "create_breakpoint: " << *i.getCreate_breakpoint ();
    }

    if (i.getSet_breakpoint_condition ())
    {
      o << ::std::endl << "set_breakpoint_condition: " << *i.getSet_breakpoint_condition ();
    }

    if (i.getEnable_breakpoint ())
    {
      o << ::std::endl << "enable_breakpoint: " << *i.getEnable_breakpoint ();
    }

    if (i.getDisable_breakpoint ())
    {
      o << ::std::endl << "disable_breakpoint: " << *i.getDisable_breakpoint ();
    }

    if (i.getDelete_breakpoint ())
    {
      o << ::std::endl << "delete_breakpoint: " << *i.getDelete_breakpoint ();
    }

    if (i.getEengine_event_setup ())
    {
      o << ::std::endl << "eengine_event_setup: " << *i.getEengine_event_setup ();
    }

    if (i.getCommunication_event ())
    {
      o << ::std::endl << "communication_event: " << *i.getCommunication_event ();
    }

    if (i.getEengine_event_error ())
    {
      o << ::std::endl << "eengine_event_error: " << *i.getEengine_event_error ();
    }

    if (i.getSet_variable ())
    {
      o << ::std::endl << "set_variable: " << *i.getSet_variable ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const File& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    if (i.getHandle ())
    {
      o << ::std::endl << "handle: " << *i.getHandle ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Channel& i)
  {
    o << ::std::endl << "name: " << i.getName ();
    if (i.getOutput_port ())
    {
      o << ::std::endl << "output_port: " << *i.getOutput_port ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Aspect& i)
  {
    o << ::std::endl << "type: " << i.getType ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Parameter& i)
  {
    if (i.getValue ())
    {
      o << ::std::endl << "value: " << *i.getValue ();
    }

    if (i.getType ())
    {
      o << ::std::endl << "type: " << *i.getType ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Node& i)
  {
    o << ::std::endl << "number: " << i.getNumber ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Instance_port& i)
  {
    o << ::std::endl << "instance_name: " << i.getInstance_name ();
    o << ::std::endl << "port_name: " << i.getPort_name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Cluster_port& i)
  {
    o << ::std::endl << "port_name: " << i.getPort_name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const Connection& i)
  {
    if (i.getGraphics ())
    {
      o << ::std::endl << "graphics: " << *i.getGraphics ();
    }

    o << ::std::endl << "port: " << i.getPort ();
    o << ::std::endl << "channel: " << i.getChannel ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace poosl
{
  ::std::unique_ptr< ::poosl::Response >
  parseResponse (const ::std::string& u,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::poosl::Response > (
      ::poosl::parseResponse (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (const ::std::string& u,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::poosl::Response > (
      ::poosl::parseResponse (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::poosl::Response > (
      ::poosl::parseResponse (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::poosl::parseResponse (isrc, f, p);
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::poosl::parseResponse (isrc, h, f, p);
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::poosl::parseResponse (isrc, h, f, p);
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::poosl::parseResponse (isrc, f, p);
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::poosl::parseResponse (isrc, h, f, p);
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::poosl::parseResponse (isrc, h, f, p);
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::xercesc::InputSource& i,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::poosl::Response > (
      ::poosl::parseResponse (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::xercesc::InputSource& i,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::poosl::Response > (
      ::poosl::parseResponse (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::poosl::Response > (
      ::poosl::parseResponse (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::poosl::Response > (
        ::poosl::parseResponse (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "response" &&
        n.namespace_ () == "uri:poosl")
    {
      ::std::unique_ptr< ::poosl::Response > r (
        ::xsd::cxx::tree::traits< ::poosl::Response, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "response",
      "uri:poosl");
  }

  ::std::unique_ptr< ::poosl::Response >
  parseResponse (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "response" &&
        n.namespace_ () == "uri:poosl")
    {
      ::std::unique_ptr< ::poosl::Response > r (
        ::xsd::cxx::tree::traits< ::poosl::Response, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "response",
      "uri:poosl");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace poosl
{
  void
  serializeResponse (::std::ostream& o,
                     const ::poosl::Response& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializeResponse (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeResponse (::std::ostream& o,
                     const ::poosl::Response& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializeResponse (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResponse (::std::ostream& o,
                     const ::poosl::Response& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializeResponse (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResponse (::xercesc::XMLFormatTarget& t,
                     const ::poosl::Response& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializeResponse (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeResponse (::xercesc::XMLFormatTarget& t,
                     const ::poosl::Response& s,
                     ::xml_schema::ErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializeResponse (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResponse (::xercesc::XMLFormatTarget& t,
                     const ::poosl::Response& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::NamespaceInfomap& m,
                     const ::std::string& e,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::poosl::serializeResponse (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeResponse (::xercesc::DOMDocument& d,
                     const ::poosl::Response& s,
                     ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "response" &&
        n.namespace_ () == "uri:poosl")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "response",
        "uri:poosl");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeResponse (const ::poosl::Response& s,
                     const ::xml_schema::NamespaceInfomap& m,
                     ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "response",
        "uri:poosl",
        m, f));

    ::poosl::serializeResponse (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_load_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }

    // error
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "uri:poosl",
          e));

      s << i.getError ();
    }

    // contents
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contents",
          "uri:poosl",
          e));

      s << i.getContents ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_save_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }

    // error
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "uri:poosl",
          e));

      s << i.getError ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_file_io_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_file_io_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_file_io_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_serialize_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }

    // contents
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contents",
          "uri:poosl",
          e));

      s << i.getContents ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_deserialize_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // error
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "uri:poosl",
          e));

      s << i.getError ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_compile_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // error
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "uri:poosl",
          e));

      s << i.getError ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_serialize_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_serialize_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_serialize_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_parse_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_parse_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_parse_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_list_classes_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // class_name
    //
    for (T_list_classes_response::Class_nameConstIterator
         b (i.getClass_name ().begin ()), n (i.getClass_name ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "class_name",
          "uri:poosl",
          e));

      s << *b;
    }

    // handle
    //
    for (T_list_classes_response::HandleConstIterator
         b (i.getHandle ().begin ()), n (i.getHandle ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_list_files_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // file
    //
    for (T_list_files_response::FileConstIterator
         b (i.getFile ().begin ()), n (i.getFile ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "file",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_get_position_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // stmt_handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stmt_handle",
          "uri:poosl",
          e));

      s << i.getStmt_handle ();
    }

    // begin
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "begin",
          "uri:poosl",
          e));

      s << i.getBegin ();
    }

    // end
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "end",
          "uri:poosl",
          e));

      s << i.getEnd ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_get_top_level_specification_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }

    // class_name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "class_name",
          "uri:poosl",
          e));

      s << i.getClass_name ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_get_class_definition_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }

    // cluster_class
    //
    if (i.getCluster_class ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cluster_class",
          "uri:poosl",
          e));

      s << *i.getCluster_class ();
    }

    // process_class
    //
    if (i.getProcess_class ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_class",
          "uri:poosl",
          e));

      s << *i.getProcess_class ();
    }

    // data_class
    //
    if (i.getData_class ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data_class",
          "uri:poosl",
          e));

      s << *i.getData_class ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_cluster_class_def& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // class
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "class",
          "uri:poosl",
          e));

      s << i.getClass ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }

    // instatiation_parameters
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instatiation_parameters",
          "uri:poosl",
          e));

      s << i.getInstatiation_parameters ();
    }

    // instance
    //
    for (T_cluster_class_def::InstanceConstIterator
         b (i.getInstance ().begin ()), n (i.getInstance ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_process_class_def& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // class
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "class",
          "uri:poosl",
          e));

      s << i.getClass ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }

    // instatiation_parameters
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instatiation_parameters",
          "uri:poosl",
          e));

      s << i.getInstatiation_parameters ();
    }

    // interface
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interface",
          "uri:poosl",
          e));

      s << i.getInterface ();
    }

    // instance_variables
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance_variables",
          "uri:poosl",
          e));

      s << i.getInstance_variables ();
    }

    // initial_method_call
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "initial_method_call",
          "uri:poosl",
          e));

      s << i.getInitial_method_call ();
    }

    // methods
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "methods",
          "uri:poosl",
          e));

      s << i.getMethods ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_data_class_def& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // class
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "class",
          "uri:poosl",
          e));

      s << i.getClass ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }

    // instance_variables
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance_variables",
          "uri:poosl",
          e));

      s << i.getInstance_variables ();
    }

    // methods
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "methods",
          "uri:poosl",
          e));

      s << i.getMethods ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_get_method_definition_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }

    // process_method
    //
    if (i.getProcess_method ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_method",
          "uri:poosl",
          e));

      s << *i.getProcess_method ();
    }

    // data_method
    //
    if (i.getData_method ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data_method",
          "uri:poosl",
          e));

      s << *i.getData_method ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_process_method_def& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << *i.getName ();
    }

    // input_parameter
    //
    for (T_process_method_def::Input_parameterConstIterator
         b (i.getInput_parameter ().begin ()), n (i.getInput_parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "input_parameter",
          "uri:poosl",
          e));

      s << *b;
    }

    // output_parameter
    //
    for (T_process_method_def::Output_parameterConstIterator
         b (i.getOutput_parameter ().begin ()), n (i.getOutput_parameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "output_parameter",
          "uri:poosl",
          e));

      s << *b;
    }

    // local_variable
    //
    for (T_process_method_def::Local_variableConstIterator
         b (i.getLocal_variable ().begin ()), n (i.getLocal_variable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "local_variable",
          "uri:poosl",
          e));

      s << *b;
    }

    // body_text
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body_text",
          "uri:poosl",
          e));

      s << i.getBody_text ();
    }

    // body_statements
    //
    if (i.getBody_statements ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body_statements",
          "uri:poosl",
          e));

      s << *i.getBody_statements ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_data_method_def& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << i.getName ();
    }

    // argument
    //
    for (T_data_method_def::ArgumentConstIterator
         b (i.getArgument ().begin ()), n (i.getArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          "uri:poosl",
          e));

      s << *b;
    }

    // local_variable
    //
    for (T_data_method_def::Local_variableConstIterator
         b (i.getLocal_variable ().begin ()), n (i.getLocal_variable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "local_variable",
          "uri:poosl",
          e));

      s << *b;
    }

    // body_text
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body_text",
          "uri:poosl",
          e));

      s << i.getBody_text ();
    }

    // body_expression
    //
    if (i.getBody_expression ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "body_expression",
          "uri:poosl",
          e));

      s << *i.getBody_expression ();
    }

    // return_type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "return_type",
          "uri:poosl",
          e));

      s << i.getReturn_type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_get_object_handle_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_rename_object_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_rename_object_response_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_rename_object_response_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_rename_object_response_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_insert_object_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_insert_object_response_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_insert_object_response_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_insert_object_response_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_delete_object_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // object
    //
    for (T_delete_object_response::ObjectConstIterator
         b (i.getObject ().begin ()), n (i.getObject ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "object",
          "uri:poosl",
          e));

      s << *b;
    }

    // result
    //
    for (T_delete_object_response::ResultConstIterator
         b (i.getResult ().begin ()), n (i.getResult ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_object_query_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_object_query_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_object_query_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_instantiate_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_instantiate_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_instantiate_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_instantiate_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_command_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // type
    //
    if (i.getType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.getType ();
    }

    // result
    //
    if (i.getResult ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "result",
          e));

      a << *i.getResult ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_get_transitions_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // transitions
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "transitions",
          "uri:poosl",
          e));

      s << i.getTransitions ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_perform_transition_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_perform_transition_response_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_perform_transition_response_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_perform_transition_response_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << *i.getName ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }

    // process
    //
    if (i.getProcess ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process",
          "uri:poosl",
          e));

      s << *i.getProcess ();
    }

    // data
    //
    if (i.getData ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data",
          "uri:poosl",
          e));

      s << *i.getData ();
    }

    // system
    //
    if (i.getSystem ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "system",
          "uri:poosl",
          e));

      s << *i.getSystem ();
    }

    // channel
    //
    if (i.getChannel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channel",
          "uri:poosl",
          e));

      s << *i.getChannel ();
    }

    // stackframe
    //
    if (i.getStackframe ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stackframe",
          "uri:poosl",
          e));

      s << *i.getStackframe ();
    }

    // variable
    //
    if (i.getVariable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "uri:poosl",
          e));

      s << *i.getVariable ();
    }

    // variable_context
    //
    if (i.getVariable_context ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable_context",
          "uri:poosl",
          e));

      s << *i.getVariable_context ();
    }

    // transition
    //
    if (i.getTransition ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "transition",
          "uri:poosl",
          e));

      s << *i.getTransition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_process& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // instance_variables
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance_variables",
          "uri:poosl",
          e));

      s << i.getInstance_variables ();
    }

    // execution_tree
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "execution_tree",
          "uri:poosl",
          e));

      s << i.getExecution_tree ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_port& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << i.getName ();
    }

    // up_channel
    //
    if (i.getUp_channel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "up_channel",
          "uri:poosl",
          e));

      s << *i.getUp_channel ();
    }

    // down_channel
    //
    if (i.getDown_channel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "down_channel",
          "uri:poosl",
          e));

      s << *i.getDown_channel ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_instance& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << i.getName ();
    }

    // type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          "uri:poosl",
          e));

      s << i.getType ();
    }

    // process_path
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_path",
          "uri:poosl",
          e));

      s << i.getProcess_path ();
    }

    // cluster
    //
    if (i.getCluster ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cluster",
          "uri:poosl",
          e));

      s << *i.getCluster ();
    }

    // port
    //
    for (T_inspect_instance::PortConstIterator
         b (i.getPort ().begin ()), n (i.getPort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "port",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_cluster& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // channel
    //
    for (T_inspect_cluster::ChannelConstIterator
         b (i.getChannel ().begin ()), n (i.getChannel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channel",
          "uri:poosl",
          e));

      s << *b;
    }

    // instance
    //
    for (T_inspect_cluster::InstanceConstIterator
         b (i.getInstance ().begin ()), n (i.getInstance ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_system& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // channel
    //
    for (T_inspect_system::ChannelConstIterator
         b (i.getChannel ().begin ()), n (i.getChannel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "channel",
          "uri:poosl",
          e));

      s << *b;
    }

    // instance
    //
    for (T_inspect_system::InstanceConstIterator
         b (i.getInstance ().begin ()), n (i.getInstance ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_channel& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << i.getName ();
    }

    // is_root
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "is_root",
          "uri:poosl",
          e));

      s << i.getIs_root ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_stackframe& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // dataclass_handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataclass_handle",
          "uri:poosl",
          e));

      s << i.getDataclass_handle ();
    }

    // dataclass_name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataclass_name",
          "uri:poosl",
          e));

      s << i.getDataclass_name ();
    }

    // method_name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "method_name",
          "uri:poosl",
          e));

      s << i.getMethod_name ();
    }

    // local_variables
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "local_variables",
          "uri:poosl",
          e));

      s << i.getLocal_variables ();
    }

    // downframe
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "downframe",
          "uri:poosl",
          e));

      s << i.getDownframe ();
    }

    // upframe
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "upframe",
          "uri:poosl",
          e));

      s << i.getUpframe ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_variable_context& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variable
    //
    for (T_inspect_variable_context::VariableConstIterator
         b (i.getVariable ().begin ()), n (i.getVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_variable& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }

    // object
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "object",
          "uri:poosl",
          e));

      s << i.getObject ();
    }

    // type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          "uri:poosl",
          e));

      s << i.getType ();
    }

    // literal
    //
    if (i.getLiteral ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "literal",
          "uri:poosl",
          e));

      s << *i.getLiteral ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_data& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }

    // type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          "uri:poosl",
          e));

      s << i.getType ();
    }

    // literal
    //
    if (i.getLiteral ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "literal",
          "uri:poosl",
          e));

      s << *i.getLiteral ();
    }

    // variables
    //
    if (i.getVariables ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variables",
          "uri:poosl",
          e));

      s << *i.getVariables ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspect_transition& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // transition
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "transition",
          "uri:poosl",
          e));

      s << i.getTransition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_observe_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // aspect
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "aspect",
          "uri:poosl",
          e));

      s << i.getAspect ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.getType ();
    }

    // handle
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "handle",
          e));

      a << i.getHandle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_execution_state_change_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // breakpoints
    //
    if (i.getBreakpoints ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "breakpoints",
          "uri:poosl",
          e));

      s << *i.getBreakpoints ();
    }

    // error
    //
    if (i.getError ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "uri:poosl",
          e));

      s << *i.getError ();
    }

    // transition
    //
    if (i.getTransition ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "transition",
          "uri:poosl",
          e));

      s << *i.getTransition ();
    }

    // message
    //
    if (i.getMessage ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "message",
          "uri:poosl",
          e));

      s << *i.getMessage ();
    }

    // state
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "state",
          "uri:poosl",
          e));

      s << i.getState ();
    }

    // time
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "time",
          "uri:poosl",
          e));

      s << ::xml_schema::AsDecimal(i.getTime ());
    }

    // minimal_time_step
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "minimal_time_step",
          "uri:poosl",
          e));

      s << ::xml_schema::AsDouble(i.getMinimal_time_step ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_eengine_event_setup_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_communication_event& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // simulation_time
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "simulation_time",
          "uri:poosl",
          e));

      s << ::xml_schema::AsDecimal(i.getSimulation_time ());
    }

    // sender
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sender",
          "uri:poosl",
          e));

      s << i.getSender ();
    }

    // receiver
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "receiver",
          "uri:poosl",
          e));

      s << i.getReceiver ();
    }

    // message
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "message",
          "uri:poosl",
          e));

      s << i.getMessage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_eengine_event_error_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // error
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "uri:poosl",
          e));

      s << i.getError ();
    }

    // stmt_handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stmt_handle",
          "uri:poosl",
          e));

      s << i.getStmt_handle ();
    }

    // process_path
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_path",
          "uri:poosl",
          e));

      s << i.getProcess_path ();
    }

    // stacktrace
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stacktrace",
          "uri:poosl",
          e));

      s << i.getStacktrace ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_communcation_event_node& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // process_path
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_path",
          "uri:poosl",
          e));

      s << i.getProcess_path ();
    }

    // stmt_handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stmt_handle",
          "uri:poosl",
          e));

      s << i.getStmt_handle ();
    }

    // port_name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "port_name",
          "uri:poosl",
          e));

      s << i.getPort_name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_error_stacktrace& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // stackframe
    //
    for (T_error_stacktrace::StackframeConstIterator
         b (i.getStackframe ().begin ()), n (i.getStackframe ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stackframe",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_error_stackframe& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // method
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "method",
          "uri:poosl",
          e));

      s << i.getMethod ();
    }

    // stmt_handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stmt_handle",
          "uri:poosl",
          e));

      s << i.getStmt_handle ();
    }

    // variable_context_global
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable_context_global",
          "uri:poosl",
          e));

      s << i.getVariable_context_global ();
    }

    // variable_context_local
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable_context_local",
          "uri:poosl",
          e));

      s << i.getVariable_context_local ();
    }

    // id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_communication_event_message& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << i.getName ();
    }

    // parameters
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameters",
          "uri:poosl",
          e));

      s << i.getParameters ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_communication_event_parameter& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // parameter
    //
    for (T_communication_event_parameter::ParameterConstIterator
         b (i.getParameter ().begin ()), n (i.getParameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameter",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_breakpoint& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // breakpoint
    //
    for (T_breakpoint::BreakpointConstIterator
         b (i.getBreakpoint ().begin ()), n (i.getBreakpoint ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "breakpoint",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_breakpoint_info& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << i.getName ();
    }

    // breakpoint_id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "breakpoint_id",
          "uri:poosl",
          e));

      s << i.getBreakpoint_id ();
    }

    // control_point
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "control_point",
          "uri:poosl",
          e));

      s << i.getControl_point ();
    }

    // stmt_handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stmt_handle",
          "uri:poosl",
          e));

      s << i.getStmt_handle ();
    }

    // is_active
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "is_active",
          "uri:poosl",
          e));

      s << i.getIs_active ();
    }

    // hit_count
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "hit_count",
          "uri:poosl",
          e));

      s << i.getHit_count ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_error_info& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // stmt_handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stmt_handle",
          "uri:poosl",
          e));

      s << i.getStmt_handle ();
    }

    // message
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "message",
          "uri:poosl",
          e));

      s << i.getMessage ();
    }

    // process_path
    //
    if (i.getProcess_path ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_path",
          "uri:poosl",
          e));

      s << *i.getProcess_path ();
    }

    // node
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "node",
          "uri:poosl",
          e));

      s << i.getNode ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_create_breakpoint_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << i.getName ();
    }

    // breakpoint_id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "breakpoint_id",
          "uri:poosl",
          e));

      s << i.getBreakpoint_id ();
    }

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }

    // control_point
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "control_point",
          "uri:poosl",
          e));

      s << i.getControl_point ();
    }

    // stmt_handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stmt_handle",
          "uri:poosl",
          e));

      s << i.getStmt_handle ();
    }

    // position
    //
    if (i.getPosition ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "position",
          "uri:poosl",
          e));

      s << *i.getPosition ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_create_breakpoint_response_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_create_breakpoint_response_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_create_breakpoint_response_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_set_breakpoint_condition_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }

    // error
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "uri:poosl",
          e));

      s << i.getError ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_set_breakpoint_condition_response_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_set_breakpoint_condition_response_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_set_breakpoint_condition_response_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_enable_breakpoint_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_disable_breakpoint_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_delete_breakpoint_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_breakpoint_result& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_breakpoint_result_result& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_breakpoint_result_result& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_breakpoint_result_result& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_var_list& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variable
    //
    for (T_var_list::VariableConstIterator
         b (i.getVariable ().begin ()), n (i.getVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_variable& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << i.getName ();
    }

    // class
    //
    if (i.getClass ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "class",
          "uri:poosl",
          e));

      s << *i.getClass ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }

    // type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          "uri:poosl",
          e));

      s << i.getType ();
    }

    // literal
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "literal",
          "uri:poosl",
          e));

      s << i.getLiteral ();
    }

    // object
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "object",
          "uri:poosl",
          e));

      s << i.getObject ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_method_list& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // method
    //
    for (T_method_list::MethodConstIterator
         b (i.getMethod ().begin ()), n (i.getMethod ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "method",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_method& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "uri:poosl",
          e));

      s << i.getName ();
    }

    // handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "handle",
          "uri:poosl",
          e));

      s << i.getHandle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_executiontree& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // sequential
    //
    for (T_executiontree::SequentialConstIterator
         b (i.getSequential ().begin ()), n (i.getSequential ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sequential",
          "uri:poosl",
          e));

      s << *b;
    }

    // method_call
    //
    for (T_executiontree::Method_callConstIterator
         b (i.getMethod_call ().begin ()), n (i.getMethod_call ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "method_call",
          "uri:poosl",
          e));

      s << *b;
    }

    // parallel
    //
    for (T_executiontree::ParallelConstIterator
         b (i.getParallel ().begin ()), n (i.getParallel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parallel",
          "uri:poosl",
          e));

      s << *b;
    }

    // select
    //
    for (T_executiontree::SelectConstIterator
         b (i.getSelect ().begin ()), n (i.getSelect ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "select",
          "uri:poosl",
          e));

      s << *b;
    }

    // statement
    //
    for (T_executiontree::StatementConstIterator
         b (i.getStatement ().begin ()), n (i.getStatement ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "statement",
          "uri:poosl",
          e));

      s << *b;
    }

    // expression
    //
    for (T_executiontree::ExpressionConstIterator
         b (i.getExpression ().begin ()), n (i.getExpression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expression",
          "uri:poosl",
          e));

      s << *b;
    }

    // process_method_call
    //
    for (T_executiontree::Process_method_callConstIterator
         b (i.getProcess_method_call ().begin ()), n (i.getProcess_method_call ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_method_call",
          "uri:poosl",
          e));

      s << *b;
    }

    // message_send
    //
    for (T_executiontree::Message_sendConstIterator
         b (i.getMessage_send ().begin ()), n (i.getMessage_send ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "message_send",
          "uri:poosl",
          e));

      s << *b;
    }

    // message_receive
    //
    for (T_executiontree::Message_receiveConstIterator
         b (i.getMessage_receive ().begin ()), n (i.getMessage_receive ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "message_receive",
          "uri:poosl",
          e));

      s << *b;
    }

    // guard
    //
    for (T_executiontree::GuardConstIterator
         b (i.getGuard ().begin ()), n (i.getGuard ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "guard",
          "uri:poosl",
          e));

      s << *b;
    }

    // while
    //
    for (T_executiontree::WhileConstIterator
         b (i.getWhile ().begin ()), n (i.getWhile ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "while",
          "uri:poosl",
          e));

      s << *b;
    }

    // abort
    //
    for (T_executiontree::AbortConstIterator
         b (i.getAbort ().begin ()), n (i.getAbort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "abort",
          "uri:poosl",
          e));

      s << *b;
    }

    // interrupt
    //
    for (T_executiontree::InterruptConstIterator
         b (i.getInterrupt ().begin ()), n (i.getInterrupt ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interrupt",
          "uri:poosl",
          e));

      s << *b;
    }

    // skip
    //
    for (T_executiontree::SkipConstIterator
         b (i.getSkip ().begin ()), n (i.getSkip ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "skip",
          "uri:poosl",
          e));

      s << *b;
    }

    // delay
    //
    for (T_executiontree::DelayConstIterator
         b (i.getDelay ().begin ()), n (i.getDelay ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "delay",
          "uri:poosl",
          e));

      s << *b;
    }

    // sequence_of_expressions
    //
    for (T_executiontree::Sequence_of_expressionsConstIterator
         b (i.getSequence_of_expressions ().begin ()), n (i.getSequence_of_expressions ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sequence_of_expressions",
          "uri:poosl",
          e));

      s << *b;
    }

    // assignment
    //
    for (T_executiontree::AssignmentConstIterator
         b (i.getAssignment ().begin ()), n (i.getAssignment ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "assignment",
          "uri:poosl",
          e));

      s << *b;
    }

    // data_method_call
    //
    for (T_executiontree::Data_method_callConstIterator
         b (i.getData_method_call ().begin ()), n (i.getData_method_call ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "data_method_call",
          "uri:poosl",
          e));

      s << *b;
    }

    // constant
    //
    for (T_executiontree::ConstantConstIterator
         b (i.getConstant ().begin ()), n (i.getConstant ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "constant",
          "uri:poosl",
          e));

      s << *b;
    }

    // variable
    //
    for (T_executiontree::VariableConstIterator
         b (i.getVariable ().begin ()), n (i.getVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variable",
          "uri:poosl",
          e));

      s << *b;
    }

    // binary_operation
    //
    for (T_executiontree::Binary_operationConstIterator
         b (i.getBinary_operation ().begin ()), n (i.getBinary_operation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "binary_operation",
          "uri:poosl",
          e));

      s << *b;
    }

    // unary_operation
    //
    for (T_executiontree::Unary_operationConstIterator
         b (i.getUnary_operation ().begin ()), n (i.getUnary_operation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "unary_operation",
          "uri:poosl",
          e));

      s << *b;
    }

    // self
    //
    for (T_executiontree::SelfConstIterator
         b (i.getSelf ().begin ()), n (i.getSelf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "self",
          "uri:poosl",
          e));

      s << *b;
    }

    // nil
    //
    for (T_executiontree::NilConstIterator
         b (i.getNil ().begin ()), n (i.getNil ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "nil",
          "uri:poosl",
          e));

      s << *b;
    }

    // current_time
    //
    for (T_executiontree::Current_timeConstIterator
         b (i.getCurrent_time ().begin ()), n (i.getCurrent_time ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "current_time",
          "uri:poosl",
          e));

      s << *b;
    }

    // if
    //
    for (T_executiontree::IfConstIterator
         b (i.getIf ().begin ()), n (i.getIf ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "if",
          "uri:poosl",
          e));

      s << *b;
    }

    // switch
    //
    for (T_executiontree::SwitchConstIterator
         b (i.getSwitch ().begin ()), n (i.getSwitch ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "switch",
          "uri:poosl",
          e));

      s << *b;
    }

    // new
    //
    for (T_executiontree::NewConstIterator
         b (i.getNew ().begin ()), n (i.getNew ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "new",
          "uri:poosl",
          e));

      s << *b;
    }

    // return
    //
    for (T_executiontree::ReturnConstIterator
         b (i.getReturn ().begin ()), n (i.getReturn ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "return",
          "uri:poosl",
          e));

      s << *b;
    }

    // execution_tree
    //
    for (T_executiontree::Execution_treeConstIterator
         b (i.getExecution_tree ().begin ()), n (i.getExecution_tree ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "execution_tree",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_executiontree_base& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // process
    //
    if (i.getProcess ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "process",
          e));

      a << *i.getProcess ();
    }

    // parent
    //
    if (i.getParent ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "parent",
          e));

      a << *i.getParent ();
    }

    // handle
    //
    if (i.getHandle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "handle",
          e));

      a << *i.getHandle ();
    }

    // global
    //
    if (i.getGlobal ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "global",
          e));

      a << *i.getGlobal ();
    }

    // local
    //
    if (i.getLocal ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "local",
          e));

      a << *i.getLocal ();
    }

    // stmt_handle
    //
    if (i.getStmt_handle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "stmt_handle",
          e));

      a << *i.getStmt_handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_executiontree_statements& i)
  {
    e << static_cast< const ::poosl::T_executiontree_base& > (i);

    // statement
    //
    for (T_executiontree_statements::StatementConstIterator
         b (i.getStatement ().begin ()), n (i.getStatement ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "statement",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_executiontree_method_call& i)
  {
    e << static_cast< const ::poosl::T_executiontree_base& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.getName ();
    }

    // state
    //
    if (i.getState ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "state",
          e));

      a << *i.getState ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_executiontree_message_receive& i)
  {
    e << static_cast< const ::poosl::T_executiontree_base& > (i);

    // port
    //
    if (i.getPort ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "port",
          e));

      a << *i.getPort ();
    }

    // message
    //
    if (i.getMessage ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "message",
          e));

      a << *i.getMessage ();
    }

    // parameter_count
    //
    if (i.getParameter_count ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "parameter_count",
          e));

      a << *i.getParameter_count ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_executiontree_expression& i)
  {
    e << static_cast< const ::poosl::T_executiontree_base& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_cluster_instance_interface& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // port
    //
    for (T_cluster_instance_interface::PortConstIterator
         b (i.getPort ().begin ()), n (i.getPort ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "port",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_cluster_instance_port& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // graphics
    //
    if (i.getGraphics ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "graphics",
          "uri:poosl",
          e));

      s << *i.getGraphics ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_graphics_port& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // location
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "location",
          "uri:poosl",
          e));

      s << i.getLocation ();
    }

    // name_location
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name_location",
          "uri:poosl",
          e));

      s << i.getName_location ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_graphics_channel& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // node
    //
    for (T_graphics_channel::NodeConstIterator
         b (i.getNode ().begin ()), n (i.getNode ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "node",
          "uri:poosl",
          e));

      s << *b;
    }

    // segment
    //
    for (T_graphics_channel::SegmentConstIterator
         b (i.getSegment ().begin ()), n (i.getSegment ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "segment",
          "uri:poosl",
          e));

      s << *b;
    }

    // name_location
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name_location",
          "uri:poosl",
          e));

      s << i.getName_location ();
    }

    // message_location
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "message_location",
          "uri:poosl",
          e));

      s << i.getMessage_location ();
    }

    // scenario
    //
    for (T_graphics_channel::ScenarioConstIterator
         b (i.getScenario ().begin ()), n (i.getScenario ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scenario",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_channel_node& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // node
    //
    for (T_channel_node::NodeConstIterator
         b (i.getNode ().begin ()), n (i.getNode ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "node",
          "uri:poosl",
          e));

      s << *b;
    }

    // instance_port
    //
    for (T_channel_node::Instance_portConstIterator
         b (i.getInstance_port ().begin ()), n (i.getInstance_port ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instance_port",
          "uri:poosl",
          e));

      s << *b;
    }

    // cluster_port
    //
    for (T_channel_node::Cluster_portConstIterator
         b (i.getCluster_port ().begin ()), n (i.getCluster_port ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "cluster_port",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_message_location& i)
  {
    e << static_cast< const ::poosl::T_point& > (i);

    // width
    //
    if (i.getWidth ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "width",
          e));

      a << *i.getWidth ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_scenario& i)
  {
    e << static_cast< const ::poosl::T_identifier& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const T_scenario& i)
  {
    a << static_cast< const ::poosl::T_identifier& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const T_scenario& i)
  {
    l << static_cast< const ::poosl::T_identifier& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_inspector_instance& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // connection
    //
    for (T_inspector_instance::ConnectionConstIterator
         b (i.getConnection ().begin ()), n (i.getConnection ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "connection",
          "uri:poosl",
          e));

      s << *b;
    }

    // graphics
    //
    if (i.getGraphics ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "graphics",
          "uri:poosl",
          e));

      s << *i.getGraphics ();
    }

    // type
    //
    if (i.getType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.getType ();
    }

    // class
    //
    if (i.getClass ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "class",
          e));

      a << *i.getClass ();
    }

    // name
    //
    if (i.getName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_box_name_scenarios& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // box
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "box",
          "uri:poosl",
          e));

      s << i.getBox ();
    }

    // name_location
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name_location",
          "uri:poosl",
          e));

      s << i.getName_location ();
    }

    // scenario
    //
    for (T_box_name_scenarios::ScenarioConstIterator
         b (i.getScenario ().begin ()), n (i.getScenario ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scenario",
          "uri:poosl",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const T_set_variable_response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // result
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "result",
          "uri:poosl",
          e));

      s << i.getResult ();
    }

    // var_handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "var_handle",
          "uri:poosl",
          e));

      s << i.getVar_handle ();
    }

    // list_handle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "list_handle",
          "uri:poosl",
          e));

      s << i.getList_handle ();
    }

    // error
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "error",
          "uri:poosl",
          e));

      s << i.getError ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Response& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // load
    //
    if (i.getLoad ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "load",
          "uri:poosl",
          e));

      s << *i.getLoad ();
    }

    // save
    //
    if (i.getSave ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "save",
          "uri:poosl",
          e));

      s << *i.getSave ();
    }

    // serialize
    //
    if (i.getSerialize ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "serialize",
          "uri:poosl",
          e));

      s << *i.getSerialize ();
    }

    // deserialize
    //
    if (i.getDeserialize ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "deserialize",
          "uri:poosl",
          e));

      s << *i.getDeserialize ();
    }

    // compile
    //
    if (i.getCompile ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "compile",
          "uri:poosl",
          e));

      s << *i.getCompile ();
    }

    // list_files
    //
    if (i.getList_files ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "list_files",
          "uri:poosl",
          e));

      s << *i.getList_files ();
    }

    // get_position
    //
    if (i.getGet_position ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "get_position",
          "uri:poosl",
          e));

      s << *i.getGet_position ();
    }

    // list_classes
    //
    if (i.getList_classes ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "list_classes",
          "uri:poosl",
          e));

      s << *i.getList_classes ();
    }

    // get_top_level_specification
    //
    if (i.getGet_top_level_specification ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "get_top_level_specification",
          "uri:poosl",
          e));

      s << *i.getGet_top_level_specification ();
    }

    // get_class_definition
    //
    if (i.getGet_class_definition ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "get_class_definition",
          "uri:poosl",
          e));

      s << *i.getGet_class_definition ();
    }

    // get_method_definition
    //
    if (i.getGet_method_definition ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "get_method_definition",
          "uri:poosl",
          e));

      s << *i.getGet_method_definition ();
    }

    // get_object_handle
    //
    if (i.getGet_object_handle ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "get_object_handle",
          "uri:poosl",
          e));

      s << *i.getGet_object_handle ();
    }

    // rename_object_response
    //
    if (i.getRename_object_response ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rename_object_response",
          "uri:poosl",
          e));

      s << *i.getRename_object_response ();
    }

    // insert_object_response
    //
    if (i.getInsert_object_response ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "insert_object_response",
          "uri:poosl",
          e));

      s << *i.getInsert_object_response ();
    }

    // delete_object_response
    //
    if (i.getDelete_object_response ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "delete_object_response",
          "uri:poosl",
          e));

      s << *i.getDelete_object_response ();
    }

    // instantiate
    //
    if (i.getInstantiate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "instantiate",
          "uri:poosl",
          e));

      s << *i.getInstantiate ();
    }

    // command
    //
    if (i.getCommand ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "command",
          "uri:poosl",
          e));

      s << *i.getCommand ();
    }

    // execution_state
    //
    if (i.getExecution_state ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "execution_state",
          "uri:poosl",
          e));

      s << *i.getExecution_state ();
    }

    // get_transitions
    //
    if (i.getGet_transitions ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "get_transitions",
          "uri:poosl",
          e));

      s << *i.getGet_transitions ();
    }

    // perform_transition
    //
    if (i.getPerform_transition ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "perform_transition",
          "uri:poosl",
          e));

      s << *i.getPerform_transition ();
    }

    // inspect
    //
    if (i.getInspect ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inspect",
          "uri:poosl",
          e));

      s << *i.getInspect ();
    }

    // observe
    //
    if (i.getObserve ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "observe",
          "uri:poosl",
          e));

      s << *i.getObserve ();
    }

    // create_breakpoint
    //
    if (i.getCreate_breakpoint ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "create_breakpoint",
          "uri:poosl",
          e));

      s << *i.getCreate_breakpoint ();
    }

    // set_breakpoint_condition
    //
    if (i.getSet_breakpoint_condition ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "set_breakpoint_condition",
          "uri:poosl",
          e));

      s << *i.getSet_breakpoint_condition ();
    }

    // enable_breakpoint
    //
    if (i.getEnable_breakpoint ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "enable_breakpoint",
          "uri:poosl",
          e));

      s << *i.getEnable_breakpoint ();
    }

    // disable_breakpoint
    //
    if (i.getDisable_breakpoint ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "disable_breakpoint",
          "uri:poosl",
          e));

      s << *i.getDisable_breakpoint ();
    }

    // delete_breakpoint
    //
    if (i.getDelete_breakpoint ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "delete_breakpoint",
          "uri:poosl",
          e));

      s << *i.getDelete_breakpoint ();
    }

    // eengine_event_setup
    //
    if (i.getEengine_event_setup ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "eengine_event_setup",
          "uri:poosl",
          e));

      s << *i.getEengine_event_setup ();
    }

    // communication_event
    //
    if (i.getCommunication_event ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "communication_event",
          "uri:poosl",
          e));

      s << *i.getCommunication_event ();
    }

    // eengine_event_error
    //
    if (i.getEengine_event_error ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "eengine_event_error",
          "uri:poosl",
          e));

      s << *i.getEengine_event_error ();
    }

    // set_variable
    //
    if (i.getSet_variable ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "set_variable",
          "uri:poosl",
          e));

      s << *i.getSet_variable ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const File& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);

    // handle
    //
    if (i.getHandle ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "handle",
          e));

      a << *i.getHandle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Channel& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.getName ();
    }

    // output_port
    //
    if (i.getOutput_port ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "output_port",
          e));

      a << *i.getOutput_port ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Aspect& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.getType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Parameter& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // value
    //
    if (i.getValue ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << *i.getValue ();
    }

    // type
    //
    if (i.getType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.getType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Node& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // number
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "number",
          e));

      a << i.getNumber ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Instance_port& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // instance_name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "instance_name",
          e));

      a << i.getInstance_name ();
    }

    // port_name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "port_name",
          e));

      a << i.getPort_name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Cluster_port& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // port_name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "port_name",
          e));

      a << i.getPort_name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Connection& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // graphics
    //
    if (i.getGraphics ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "graphics",
          "uri:poosl",
          e));

      s << *i.getGraphics ();
    }

    // port
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "port",
          e));

      a << i.getPort ();
    }

    // channel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "channel",
          e));

      a << i.getChannel ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

